Index: lib/coderay/encoders/html.rb
===================================================================
--- lib/coderay/encoders/html.rb	(revision 644)
+++ lib/coderay/encoders/html.rb	(revision 1729)
@@ -25,6 +25,10 @@
   #
   # == Options
   #
+  # === :escape
+  # Escape html entities
+  # Default: true
+  #
   # === :tab_width
   # Convert \t characters to +n+ spaces (a number.)
   # Default: 8
@@ -70,6 +74,7 @@
     FILE_EXTENSION = 'html'
 
     DEFAULT_OPTIONS = {
+      :escape => true,
       :tab_width => 8,
 
       :level => :xhtml,
@@ -145,6 +150,7 @@
       @HTML_ESCAPE = HTML_ESCAPE.dup
       @HTML_ESCAPE["\t"] = ' ' * options[:tab_width]
 
+      @escape = options[:escape]
       @opened = [nil]
       @css = CSS.new options[:style]
 
@@ -222,7 +228,7 @@
 
     def token text, type
       if text.is_a? ::String
-        if text =~ /#{HTML_ESCAPE_PATTERN}/o
+        if @escape && (text =~ /#{HTML_ESCAPE_PATTERN}/o)
           text = text.gsub(/#{HTML_ESCAPE_PATTERN}/o) { |m| @HTML_ESCAPE[m] }
         end
         @opened[0] = type
Index: lib/coderay/helpers/file_type.rb
===================================================================
--- lib/coderay/helpers/file_type.rb	(revision 644)
+++ lib/coderay/helpers/file_type.rb	(revision 1729)
@@ -84,9 +84,15 @@
     'cpp' => :c,
     'c' => :c,
     'h' => :c,
+    'java' => :java,
+    'js' => :javascript,
     'xml' => :xml,
     'htm' => :html,
     'html' => :html,
+    'php' => :php,
+    'php3' => :php,
+    'php4' => :php,
+    'php5' => :php,
     'xhtml' => :xhtml,
     'raydebug' => :debug,
     'rhtml' => :rhtml,
Index: lib/coderay/scanners/java.rb
===================================================================
--- lib/coderay/scanners/java.rb	(revision 0)
+++ lib/coderay/scanners/java.rb	(revision 1729)
@@ -0,0 +1,130 @@
+module CodeRay
+  module Scanners
+    class Java < Scanner
+    
+      register_for :java
+    
+      RESERVED_WORDS = %w(abstract assert break case catch class
+      const continue default do else enum extends final finally for
+      goto if implements import instanceof interface native new
+      package private protected public return static strictfp super switch
+      synchronized this throw throws transient try void volatile while)
+    
+      PREDEFINED_TYPES = %w(boolean byte char double float int long short)
+    
+      PREDEFINED_CONSTANTS = %w(true false null)
+    
+      IDENT_KIND = WordList.new(:ident).
+        add(RESERVED_WORDS, :reserved).
+        add(PREDEFINED_TYPES, :pre_type).
+        add(PREDEFINED_CONSTANTS, :pre_constant)
+    
+      ESCAPE = / [rbfnrtv\n\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x
+      UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x
+    
+      def scan_tokens tokens, options
+        state = :initial
+  
+        until eos?
+          kind = nil
+          match = nil
+  
+          case state
+          when :initial
+  
+            if scan(/ \s+ | \\\n /x)
+              kind = :space
+              
+            elsif scan(%r! // [^\n\\]* (?: \\. [^\n\\]* )* | /\* (?: .*? \*/ | .* ) !mx)
+              kind = :comment
+  
+            elsif match = scan(/ \# \s* if \s* 0 /x)
+              match << scan_until(/ ^\# (?:elif|else|endif) .*? $ | \z /xm) unless eos?
+              kind = :comment
+  
+            elsif scan(/ [-+*\/=<>?:;,!&^|()\[\]{}~%]+ | \.(?!\d) /x)
+              kind = :operator
+  
+            elsif match = scan(/ [A-Za-z_][A-Za-z_0-9]* /x)
+              kind = IDENT_KIND[match]
+              if kind == :ident and check(/:(?!:)/)
+                match << scan(/:/)
+                kind = :label
+              end
+  
+            elsif match = scan(/L?"/)
+              tokens << [:open, :string]
+              if match[0] == ?L
+                tokens << ['L', :modifier]
+                match = '"'
+              end
+              state = :string
+              kind = :delimiter
+  
+            elsif scan(%r! \@ .* !x)
+              kind = :preprocessor
+  
+            elsif scan(/ L?' (?: [^\'\n\\] | \\ #{ESCAPE} )? '? /ox)
+              kind = :char
+  
+            elsif scan(/0[xX][0-9A-Fa-f]+/)
+              kind = :hex
+  
+            elsif scan(/(?:0[0-7]+)(?![89.eEfF])/)
+              kind = :oct
+  
+            elsif scan(/(?:\d+)(?![.eEfF])/)
+              kind = :integer
+  
+            elsif scan(/\d[fF]?|\d*\.\d+(?:[eE][+-]?\d+)?[fF]?|\d+[eE][+-]?\d+[fF]?/)
+              kind = :float
+  
+            else
+              getch
+              kind = :error
+  
+            end
+  
+          when :string
+            if scan(/[^\\\n"]+/)
+              kind = :content
+            elsif scan(/"/)
+              tokens << ['"', :delimiter]
+              tokens << [:close, :string]
+              state = :initial
+              next
+            elsif scan(/ \\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} ) /mox)
+              kind = :char
+            elsif scan(/ \\ | $ /x)
+              tokens << [:close, :string]
+              kind = :error
+              state = :initial
+            else
+              raise_inspect "else case \" reached; %p not handled." % peek(1), tokens
+            end
+  
+          else
+            raise_inspect 'Unknown state', tokens
+  
+          end
+  
+          match ||= matched
+          if $DEBUG and not kind
+            raise_inspect 'Error token %p in line %d' %
+              [[match, kind], line], tokens
+          end
+          raise_inspect 'Empty token', tokens unless match
+  
+          tokens << [match, kind]
+  
+        end
+  
+        if state == :string
+          tokens << [:close, :string]
+        end
+  
+        tokens
+      end
+    end
+  end
+end

Property changes on: lib/coderay/scanners/java.rb
___________________________________________________________________
Name: svn:eol-style
   + native

Index: lib/coderay/scanners/c.rb
===================================================================
--- lib/coderay/scanners/c.rb	(revision 644)
+++ lib/coderay/scanners/c.rb	(revision 1729)
@@ -122,7 +122,7 @@
           end
 
         when :include_expected
-          if scan(/<[^>\n]+>?|"[^"\n\\]*(?:\\.[^"\n\\]*)*"?/)
+          if scan(/[^\n]+/)
             kind = :include
             state = :initial
 
Index: lib/coderay/scanners/javascript.rb
===================================================================
--- lib/coderay/scanners/javascript.rb	(revision 0)
+++ lib/coderay/scanners/javascript.rb	(revision 1729)
@@ -0,0 +1,176 @@
+# http://pastie.textmate.org/50774/
+module CodeRay module Scanners
+	
+	class JavaScript < Scanner
+
+		register_for :javascript
+		
+		RESERVED_WORDS = [
+			'asm', 'break', 'case', 'continue', 'default', 'do', 'else',
+			'for', 'goto', 'if', 'return', 'switch', 'while',
+#			'struct', 'union', 'enum', 'typedef',
+#			'static', 'register', 'auto', 'extern',
+#			'sizeof',
+      'typeof',
+#			'volatile', 'const',  # C89
+#			'inline', 'restrict', # C99			
+			'var', 'function','try','new','in',
+			'instanceof','throw','catch'
+		]
+
+		PREDEFINED_CONSTANTS = [
+			'void', 'null', 'this',
+			'true', 'false','undefined',
+		]
+
+		IDENT_KIND = WordList.new(:ident).
+			add(RESERVED_WORDS, :reserved).
+			add(PREDEFINED_CONSTANTS, :pre_constant)
+
+		ESCAPE = / [rbfnrtv\n\\\/'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x
+		UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x
+
+		def scan_tokens tokens, options
+
+			state = :initial
+			string_type = nil
+			regexp_allowed = true
+
+			until eos?
+
+				kind = :error
+				match = nil
+
+				if state == :initial
+					
+					if scan(/ \s+ | \\\n /x)
+						kind = :space
+						
+					elsif scan(%r! // [^\n\\]* (?: \\. [^\n\\]* )* | /\* (?: .*? \*/ | .* ) !mx)
+						kind = :comment
+						regexp_allowed = false
+
+					elsif match = scan(/ \# \s* if \s* 0 /x)
+						match << scan_until(/ ^\# (?:elif|else|endif) .*? $ | \z /xm) unless eos?
+						kind = :comment
+						regexp_allowed = false
+
+				  elsif regexp_allowed and scan(/\//)
+				    tokens << [:open, :regexp]
+				    state = :regex
+						kind = :delimiter
+						
+					elsif scan(/ [-+*\/=<>?:;,!&^|()\[\]{}~%] | \.(?!\d) /x)
+						kind = :operator
+						regexp_allowed=true
+						
+					elsif match = scan(/ [$A-Za-z_][A-Za-z_0-9]* /x)
+						kind = IDENT_KIND[match]
+#						if kind == :ident and check(/:(?!:)/)
+#							match << scan(/:/)
+#							kind = :label
+#						end
+						regexp_allowed=false
+						
+					elsif match = scan(/["']/)
+						tokens << [:open, :string]
+            string_type = matched
+						state = :string
+						kind = :delimiter
+						
+#					elsif scan(/#\s*(\w*)/)
+#						kind = :preprocessor  # FIXME multiline preprocs
+#						state = :include_expected if self[1] == 'include'
+#						
+#					elsif scan(/ L?' (?: [^\'\n\\] | \\ #{ESCAPE} )? '? /ox)
+#						kind = :char
+				
+					elsif scan(/0[xX][0-9A-Fa-f]+/)
+						kind = :hex
+						regexp_allowed=false
+						
+					elsif scan(/(?:0[0-7]+)(?![89.eEfF])/)
+						kind = :oct
+						regexp_allowed=false
+						
+					elsif scan(/(?:\d+)(?![.eEfF])/)
+						kind = :integer
+						regexp_allowed=false
+						
+					elsif scan(/\d[fF]?|\d*\.\d+(?:[eE][+-]?\d+)?[fF]?|\d+[eE][+-]?\d+[fF]?/)
+						kind = :float
+						regexp_allowed=false
+
+					else
+						getch
+					end
+					
+				elsif state == :regex
+					if scan(/[^\\\/]+/)
+						kind = :content
+				  elsif scan(/\\\/|\\\\/)
+						kind = :content
+				  elsif scan(/\//)
+					  tokens << [matched, :delimiter]
+				    tokens << [:close, :regexp]
+				    state = :initial
+				    next
+				  else
+				    getch
+				    kind = :content
+					end
+				  
+				elsif state == :string
+					if scan(/[^\\"']+/)
+						kind = :content
+					elsif scan(/["']/)
+						if string_type==matched
+						  tokens << [matched, :delimiter]
+						  tokens << [:close, :string]
+						  state = :initial
+						  string_type=nil
+						  next
+						else
+						  kind = :content
+						end
+					elsif scan(/ \\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} ) /mox)
+						kind = :char
+					elsif scan(/ \\ | $ /x)
+						kind = :error
+						state = :initial
+					else
+						raise "else case \" reached; %p not handled." % peek(1), tokens
+					end
+					
+#				elsif state == :include_expected
+#					if scan(/<[^>\n]+>?|"[^"\n\\]*(?:\\.[^"\n\\]*)*"?/)
+#						kind = :include
+#						state = :initial
+#						
+#					elsif match = scan(/\s+/)
+#						kind = :space
+#						state = :initial if match.index ?\n
+#						
+#					else
+#						getch
+#						
+#					end
+#					
+				else
+					raise 'else-case reached', tokens
+					
+				end
+				
+				match ||= matched
+#				raise [match, kind], tokens if kind == :error
+        
+				tokens << [match, kind]
+				
+			end
+		  tokens
+			
+		end
+
+	end
+
+end end
\ No newline at end of file
Index: lib/coderay/scanners/php.rb
===================================================================
--- lib/coderay/scanners/php.rb	(revision 0)
+++ lib/coderay/scanners/php.rb	(revision 1729)
@@ -0,0 +1,165 @@
+module CodeRay module Scanners
+	
+	class PHP < Scanner
+
+		register_for :php
+		
+		RESERVED_WORDS = [
+          'and', 'or', 'xor', '__FILE__', 'exception', '__LINE__', 'array', 'as', 'break', 'case',
+          'class', 'const', 'continue', 'declare', 'default',
+          'die', 'do', 'echo', 'else', 'elseif',
+          'empty', 'enddeclare', 'endfor', 'endforeach', 'endif',
+          'endswitch', 'endwhile', 'eval', 'exit', 'extends',
+          'for', 'foreach', 'function', 'global', 'if',
+          'include', 'include_once', 'isset', 'list', 'new',
+          'print', 'require', 'require_once', 'return', 'static',
+          'switch', 'unset', 'use', 'var', 'while',
+          '__FUNCTION__', '__CLASS__', '__METHOD__', 'final', 'php_user_filter',
+          'interface', 'implements', 'extends', 'public', 'private',
+          'protected', 'abstract', 'clone', 'try', 'catch',
+          'throw', 'cfunction', 'old_function' 
+		]
+
+		PREDEFINED_CONSTANTS = [
+			'null', '$this', 'true', 'false'
+		]
+
+		IDENT_KIND = WordList.new(:ident).
+			add(RESERVED_WORDS, :reserved).
+			add(PREDEFINED_CONSTANTS, :pre_constant)
+
+		ESCAPE = / [\$\wrbfnrtv\n\\\/'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x
+		UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x
+
+		def scan_tokens tokens, options
+
+			state = :waiting_php
+			string_type = nil
+			regexp_allowed = true
+
+			until eos?
+
+				kind = :error
+				match = nil
+
+				if state == :initial
+					
+					if scan(/ \s+ | \\\n /x)
+						kind = :space
+						
+				    elsif scan(/\?>/)
+    				    kind = :char
+    				    state = :waiting_php
+						
+					elsif scan(%r{ (//|\#) [^\n\\]* (?: \\. [^\n\\]* )* | /\* (?: .*? \*/ | .* ) }mx)
+						kind = :comment
+						regexp_allowed = false
+
+					elsif match = scan(/ \# \s* if \s* 0 /x)
+						match << scan_until(/ ^\# (?:elif|else|endif) .*? $ | \z /xm) unless eos?
+						kind = :comment
+						regexp_allowed = false
+
+				  elsif regexp_allowed and scan(/\//)
+				    tokens << [:open, :regexp]
+				    state = :regex
+						kind = :delimiter
+						
+					elsif scan(/ [-+*\/=<>?:;,!&^|()\[\]{}~%] | \.(?!\d) /x)
+						kind = :operator
+						regexp_allowed=true
+						
+					elsif match = scan(/ [$@A-Za-z_][A-Za-z_0-9]* /x)
+						kind = IDENT_KIND[match]
+						regexp_allowed=false
+						
+					elsif match = scan(/["']/)
+						tokens << [:open, :string]
+                        string_type = matched
+						state = :string
+						kind = :delimiter
+				
+					elsif scan(/0[xX][0-9A-Fa-f]+/)
+						kind = :hex
+						regexp_allowed=false
+						
+					elsif scan(/(?:0[0-7]+)(?![89.eEfF])/)
+						kind = :oct
+						regexp_allowed=false
+						
+					elsif scan(/(?:\d+)(?![.eEfF])/)
+						kind = :integer
+						regexp_allowed=false
+						
+					elsif scan(/\d[fF]?|\d*\.\d+(?:[eE][+-]?\d+)?[fF]?|\d+[eE][+-]?\d+[fF]?/)
+						kind = :float
+						regexp_allowed=false
+
+					else
+						getch
+					end
+					
+				elsif state == :regex
+					if scan(/[^\\\/]+/)
+						kind = :content
+				  elsif scan(/\\\/|\\/)
+						kind = :content
+				  elsif scan(/\//)
+					  tokens << [matched, :delimiter]
+				    tokens << [:close, :regexp]
+				    state = :initial
+				    next
+				  else
+				    getch
+				    kind = :content
+					end
+				  
+				elsif state == :string
+					if scan(/[^\\"']+/)
+						kind = :content
+					elsif scan(/["']/)
+						if string_type==matched
+						  tokens << [matched, :delimiter]
+						  tokens << [:close, :string]
+						  state = :initial
+						  string_type=nil
+						  next
+						else
+						  kind = :content
+						end
+					elsif scan(/ \\ (?: \S ) /mox)
+						kind = :char
+					elsif scan(/ \\ | $ /x)
+						kind = :error
+						state = :initial
+					else
+						raise "else case \" reached; %p not handled." % peek(1), tokens
+					end		
+						
+				elsif state == :waiting_php
+                  if scan(/<\?php/m)
+				    kind = :char
+				    state = :initial
+				  elsif scan(/[^<]+/)
+				    kind = :comment
+                  else
+                    kind = :comment
+                    getch
+				  end
+				else
+					raise 'else-case reached', tokens
+					
+				end
+				
+				match ||= matched
+        
+				tokens << [match, kind]
+				
+			end
+		  tokens
+			
+		end
+
+	end
+
+end end
\ No newline at end of file

Property changes on: lib/coderay/scanners/php.rb
___________________________________________________________________
Name: svn:eol-style
   + native

