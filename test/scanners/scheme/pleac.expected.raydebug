comment(;;; -*- scheme -*-)

comment(;;; @@PLEAC@@_NAME)
comment(;;; @@SKIP@@ Guile 1.8)

comment(;;; @@PLEAC@@_WEB)
comment(;;; @@SKIP@@ http://www.gnu.org/software/guile/)

comment(;;; @@PLEAC@@_INTRO)
comment(;;; @@SKIP@@ Sections 1 - 3, and 7 - 9, largely completed using Guile 1.5; subsequent additions use Guile 1.8.)

comment(;;; @@PLEAC@@_APPENDIX)
comment(;;; @@SKIP@@ General-purpose, custom functions that might be used in several sections, appear here )

comment(;; Helper which aims to reduce code clutter by:)
comment(;; * Replacing the oft-used, '(display item\) (newline\)' combination)
comment(;; * Avoiding overuse of '(string-append\)' for simple output tasks)
operator_fat(()reserved(define) operator_fat(()(print) (item) operator(.) (rest)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(all-item) operator_fat(()reserved(cons) (item) (rest)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\)) operator_fat(()(display) (item)operator_fat(\)) operator_fat(()(display) string<delimiter(")content( )delimiter(")>operator_fat(\))operator_fat(\))      
      (all-item)operator_fat(\))operator_fat(\))
  operator_fat(()(newline)operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(;; Slightly modified version of '(qx\)' from Chapter 4)
operator_fat(()(use-modules) operator_fat(()(ice-9) (popen)operator_fat(\)) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(drain-output) (port)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(chars) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
             operator_fat(()(next) operator_fat(()(read-char) (port)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(eof-object?) (next)operator_fat(\))
        comment(; Modified to not return last 'line' with newline)
        operator_fat(()(list->string) operator_fat(()(reverse!) operator_fat(()(cdr) (chars)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()reserved(cons) (next) (chars)operator_fat(\))
              operator_fat(()(read-char) (port)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(qx) (pipeline)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(pipe) operator_fat(()(open-input-pipe) (pipeline)operator_fat(\))operator_fat(\))
         operator_fat(()(output) operator_fat(()(drain-output) (pipe)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(close-pipe) (pipe)operator_fat(\))
    (output)operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(;; @@PLEAC@@_1.0)
operator_fat(()reserved(define) (string) string<delimiter(")content(\\\\)content(n)delimiter(")>operator_fat(\))                    comment(; two characters, \\ and an n)
operator_fat(()reserved(define) (string) string<delimiter(")content(\\n)delimiter(")>operator_fat(\))                     comment(; a "newline" character)
operator_fat(()reserved(define) (string) string<delimiter(")content(Jon )content(\\")content(Maddog)content(\\")content( Orwant)delimiter(")>operator_fat(\))  comment(; literal double quotes)
operator_fat(()reserved(define) (string) string<delimiter(")content(Jon 'Maddog' Orwant)delimiter(")>operator_fat(\))    comment(; literal single quotes)

operator_fat(()reserved(define) (a) string<delimiter(")content(This is a multiline here document
terminated by a closing double quote)delimiter(")>operator_fat(\))

comment(;; @@PLEAC@@_1.1)
comment(;; Use substring)

operator_fat(()(substring) (str) (start) (end)operator_fat(\))
operator_fat(()(substring) (str) (start)operator_fat(\))

comment(;; You can fill portions of a string with another string)

operator_fat(()(substring-move-right!) (str) (start) (end) (newstring) (newstart)operator_fat(\))
operator_fat(()(substring-move-left!) (str) (start) (end) (newstring) (newstart)operator_fat(\))

comment(;; Guile has a separate character type, and you can treat strings as a)
comment(;; character array.)

operator_fat(()(string-ref) (str) (pos)operator_fat(\))
operator_fat(()(string-set!) (str) (pos) (char)operator_fat(\))
operator_fat(()(string-fill!) (str) (char)operator_fat(\))
operator_fat(()(substring-fill!) (str) (start) (end) (char)operator_fat(\))

operator_fat(()reserved(define) (s) string<delimiter(")content(This is what you have)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (first) operator_fat(()(substring) (s) integer(0) integer(1)operator_fat(\))operator_fat(\))                     comment(; "T")
operator_fat(()reserved(define) (start) operator_fat(()(substring) (s) integer(5) integer(7)operator_fat(\))operator_fat(\))                     comment(; "is")
operator_fat(()reserved(define) (rest)  operator_fat(()(substring) (s) integer(13)operator_fat(\))operator_fat(\))                      comment(; "you have")
operator_fat(()reserved(define) (last)  operator_fat(()(substring) (s) operator_fat(()integer(1)(-) operator_fat(()(string-length) (s)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))  comment(; "e")
operator_fat(()reserved(define) (end)   operator_fat(()(substring) (s) operator_fat(()(-) operator_fat(()(string-length) (s)operator_fat(\)) integer(4)operator_fat(\))operator_fat(\))operator_fat(\)) comment(; "have")
operator_fat(()reserved(define) (piece) operator_fat(()reserved(let) operator_fat(()operator_fat(()(len) operator_fat(()(string-length) (s)operator_fat(\))operator_fat(\))operator_fat(\))
                operator_fat(()(substring) (s) operator_fat(()(-) (len) integer(8)operator_fat(\)) operator_fat(()(-) (len) integer(5)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))  comment(; "you")


comment(;;; Or use the string library SRFI-13)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (s) string<delimiter(")content(This is what you have)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (first) operator_fat(()(string-take) (s) integer(1)operator_fat(\))operator_fat(\))                     comment(; "T")
operator_fat(()reserved(define) (start) operator_fat(()(xsubstring) (s) integer(5) integer(7)operator_fat(\))operator_fat(\))                    comment(; "is")
operator_fat(()reserved(define) (rest)  operator_fat(()(xsubstring) (s) integer(13) (-)integer(1)operator_fat(\))operator_fat(\))                  comment(; "you have")
operator_fat(()reserved(define) (last)  operator_fat(()(string-take-right) (s) integer(1)operator_fat(\))operator_fat(\))               comment(; "e")
operator_fat(()reserved(define) (end)   operator_fat(()(string-take-right) (s) integer(4)operator_fat(\))operator_fat(\))               comment(; "have")
operator_fat(()reserved(define) (piece) operator_fat(()(xsubstring) (s) (-)integer(8) (-)integer(5)operator_fat(\))operator_fat(\))                  comment(; "you")

comment(;; Mutation of different sized strings is not allowed.  You have to)
comment(;; use set! to change the variable.)

operator_fat(()reserved(set!) (s) operator_fat(()(string-replace) (s) string<delimiter(")content(wasn't)delimiter(")> integer(5) integer(7)operator_fat(\))operator_fat(\))
comment(;; This wasn't what you have)
operator_fat(()reserved(set!) (s) operator_fat(()(string-replace) (s) string<delimiter(")content(ondrous)delimiter(")> integer(13) integer(25)operator_fat(\))operator_fat(\))
comment(;; This wasn't wondrous)
operator_fat(()reserved(set!) (s) operator_fat(()(string-take-right) (s) operator_fat(()integer(1)(-) operator_fat(()(string-length) (s)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
comment(;; his wasn't wondrous)
operator_fat(()reserved(set!) (s) operator_fat(()(string-take) (s) integer(9)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.2)
operator_fat(()reserved(define) (a) operator_fat(()reserved(or) (b) (c)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (a) operator_fat(()reserved(if) operator_fat(()(defined?) (b)operator_fat(\)) (b) (c)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (a) operator_fat(()reserved(or) operator_fat(()reserved(and) operator_fat(()(defined?) (b)operator_fat(\)) (b)operator_fat(\)) (c)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.3)
comment(;; This doesn't really make sense in Scheme... temporary variables are)
comment(;; a natural construct and cheap.  If you want to swap variables in a)
comment(;; block without introducing any new variable names, you can use let:)

operator_fat(()reserved(let) operator_fat(()operator_fat(()(a) (b)operator_fat(\)) operator_fat(()(b) (a)operator_fat(\))operator_fat(\))
  comment(;; ...)
  operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(alpha) (beta)operator_fat(\)) operator_fat(()(beta) (production)operator_fat(\)) operator_fat(()(production) (alpha)operator_fat(\))operator_fat(\))
  comment(;; ...)
  operator_fat(\))

comment(;; @@PLEAC@@_1.4)
operator_fat(()reserved(define) (num) operator_fat(()(char->integer) (char)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (char) operator_fat(()(integer->char) (num)operator_fat(\))operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(str) string<delimiter(")content(sample)delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()(display) operator_fat(()(string-join)
            operator_fat(()(map) (number->string)
                 operator_fat(()(map) (char->integer) operator_fat(()(string->list) (str)operator_fat(\))operator_fat(\))operator_fat(\)) string<delimiter(")content( )delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()(newline)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(lst) operator_fat(')operator_fat(()integer(115) integer(97) integer(109) integer(112) integer(108) integer(101)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(display) operator_fat(()(list->string) operator_fat(()(map) (integer->char) (lst)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(newline)operator_fat(\))operator_fat(\))

operator_fat(()reserved(letrec) operator_fat(()operator_fat(()(next) operator_fat(()reserved(lambda) operator_fat(()(c)operator_fat(\)) operator_fat(()(integer->char) operator_fat(()integer(1)(+) operator_fat(()(char->integer) (c)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(hal) string<delimiter(")content(HAL)delimiter(")>operator_fat(\))
         operator_fat(()(ibm) operator_fat(()(list->string) operator_fat(()(map) (next) operator_fat(()(string->list) (hal)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(display) (ibm)operator_fat(\))
    operator_fat(()(newline)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.5)
comment(;; Convert the string to a list of characters)
operator_fat(()(map) (proc)
     operator_fat(()(string->list) (str)operator_fat(\))operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(unique chars are: ~A)content(\\n)delimiter(")>
        operator_fat(()(apply) (string) operator_fat(()(sort) operator_fat(()(delete-duplicates)
                             operator_fat(()(string->list) string<delimiter(")content(an apple a day)delimiter(")>operator_fat(\))operator_fat(\)) (char<?)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(let*) operator_fat(()operator_fat(()(str) string<delimiter(")content(an apple a day)delimiter(")>operator_fat(\))
       operator_fat(()(sum) operator_fat(()(apply) (+) operator_fat(()(map) (char->integer) operator_fat(()(string->list) (str)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(sum is ~A)content(\\n)delimiter(")> (sum)operator_fat(\))operator_fat(\))

comment(;;; or use string-fold/string-map/string-for-each from SRFI-13)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let*) operator_fat(()operator_fat(()(str) string<delimiter(")content(an apple a day)delimiter(")>operator_fat(\))
       operator_fat(()(sum) operator_fat(()(string-fold) operator_fat(()reserved(lambda) operator_fat(()(c) (acc)operator_fat(\)) operator_fat(()(+) (acc) operator_fat(()(char->integer) (c)operator_fat(\))operator_fat(\))operator_fat(\))
                         integer(0) (str)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(sum is ~A)content(\\n)delimiter(")> (sum)operator_fat(\))operator_fat(\))

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; sum - compute 16-bit checksum of all input files)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(checksum) (p)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\))operator_fat(\)) operator_fat(()(sum) integer(0)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(eof-object?) (line)operator_fat(\))
      operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A ~A)content(\\n)delimiter(")> (sum) operator_fat(()(port-filename) (p)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(line-sum) operator_fat(()(string-fold) operator_fat(()reserved(lambda) operator_fat(()(c) (acc)operator_fat(\))
                                     operator_fat(()(+) (acc) operator_fat(()(char->integer) (c)operator_fat(\))operator_fat(\))operator_fat(\))
                                   integer(0) (line)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\)) operator_fat(()(modulo) operator_fat(()(+) (sum) (line-sum)operator_fat(\))
                                            operator_fat(()integer(1)(-) operator_fat(()(expt) integer(2) integer(16)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\))
    operator_fat(()(checksum) operator_fat(()(current-input-port)operator_fat(\))operator_fat(\))
    operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(f)operator_fat(\)) operator_fat(()(call-with-input-file) (f) (checksum)operator_fat(\))operator_fat(\)) (args)operator_fat(\))operator_fat(\))operator_fat(\))

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; slowcat - emulate a  s l o w  line printer)
operator_fat(()(use-modules) operator_fat(()(ice-9) (regex)operator_fat(\)) operator_fat(()(srfi) (srfi-2)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) reserved(delay) integer(1)operator_fat(\))
operator_fat(()(and-let*) operator_fat(()operator_fat(()(p) operator_fat(()(pair?) (args)operator_fat(\))operator_fat(\))
           operator_fat(()(m) operator_fat(()(string-match) string<delimiter(")content(^-([0-9]+\)$)delimiter(")> operator_fat(()(car) (args)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(set!) reserved(delay) operator_fat(()(string->number) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(set!) (args) operator_fat(()(cdr) (args)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(slowcat) (p)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
           operator_fat(()(string-for-each)
            operator_fat(()reserved(lambda) operator_fat(()(c)operator_fat(\)) operator_fat(()(display) (c)operator_fat(\)) operator_fat(()(usleep) operator_fat(()(*) integer(5) reserved(delay)operator_fat(\))operator_fat(\))operator_fat(\)) (line)operator_fat(\))
           operator_fat(()(loop) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\))
  operator_fat(()(slowcat) operator_fat(()(current-input-port)operator_fat(\))operator_fat(\))
  operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(f)operator_fat(\)) operator_fat(()(call-with-input-file) (f) (slowcat)operator_fat(\))operator_fat(\)) (args)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.6)
operator_fat(()reserved(define) (revbytes) operator_fat(()(list->string) operator_fat(()(reverse) operator_fat(()(string->list) (str)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;;; Or from SRFI-13)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (revbytes) operator_fat(()(string-reverse) (str)operator_fat(\))operator_fat(\))
operator_fat(()(string-reverse!) (str)operator_fat(\)) comment(; modifies in place)

operator_fat(()reserved(define) (revwords) operator_fat(()(string-join) operator_fat(()(reverse) operator_fat(()(string-tokenize) (str)operator_fat(\))operator_fat(\)) string<delimiter(")content( )delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()(with-input-from-file) string<delimiter(")content(/usr/share/dict/words)delimiter(")>
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
    operator_fat(()reserved(do) operator_fat(()operator_fat(()(word) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(eof-object?) (word)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()reserved(and) operator_fat(()(>) operator_fat(()(string-length) (word)operator_fat(\)) integer(5)operator_fat(\))
               operator_fat(()(string=?) (word) operator_fat(()(string-reverse) (word)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(write-line) (word)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; A little too verbose on the command line)
comment(;; guile --use-srfi=13 -c '(with-input-from-file "/usr/share/dict/words" (lambda (\) (do ((word (read-line\) (read-line\)\)\) ((eof-object? word\)\) (if (and (> (string-length word\) 5\) (string=? word (string-reverse word\)\)\) (write-line word\)\)\)\)\)')

comment(;; @@PLEAC@@_1.7)
comment(;; Use regexp-substitute/global)
operator_fat(()(regexp-substitute/global)
 pre_constant(#f) string<delimiter(")content(([^)content(\\t)content(]*\)()content(\\t)content(+\))delimiter(")> (str)
 operator_fat(()reserved(lambda) operator_fat(()(m)operator_fat(\))
   operator_fat(()reserved(let*) operator_fat(()operator_fat(()(pre-string) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))
          operator_fat(()(pre-len) operator_fat(()(string-length) (pre-string)operator_fat(\))operator_fat(\))
          operator_fat(()(match-len) operator_fat(()(-) operator_fat(()(match:end) (m) integer(2)operator_fat(\)) operator_fat(()(match:start) (m) integer(2)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()(string-append)
      (pre-string)
      operator_fat(()(make-string)
       operator_fat(()(-) operator_fat(()(*) (match-len) integer(8)operator_fat(\))
          operator_fat(()(modulo) (pre-len) integer(8)operator_fat(\))operator_fat(\))
       char(#\\space)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
 operator_fat(')(post)operator_fat(\))

comment(;; @@PLEAC@@_1.8)
comment(;; just interpolate $abc in strings:)
operator_fat(()reserved(define) operator_fat(()(varsubst) (str)operator_fat(\))
  operator_fat(()(regexp-substitute/global) pre_constant(#f) string<delimiter(")content(\\\\)content($()content(\\\\)content(w+\))delimiter(")> (str)
   operator_fat(')(pre) operator_fat(()reserved(lambda) operator_fat(()(m)operator_fat(\)) operator_fat(()(eval) operator_fat(()(string->symbol) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))
                          operator_fat(()(current-module)operator_fat(\))operator_fat(\))operator_fat(\))
   operator_fat(')(post)operator_fat(\))operator_fat(\))

comment(;; interpolate $abc with error messages:)
operator_fat(()reserved(define) operator_fat(()(safe-varsubst) (str)operator_fat(\))
  operator_fat(()(regexp-substitute/global) pre_constant(#f) string<delimiter(")content(\\\\)content($()content(\\\\)content(w+\))delimiter(")> (str)
   operator_fat(')(pre) operator_fat(()reserved(lambda) operator_fat(()(m)operator_fat(\))
          operator_fat(()(catch) pre_constant(#t)
            operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(eval) operator_fat(()(string->symbol) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))
                             operator_fat(()(current-module)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()reserved(lambda) (args)
              operator_fat(()(format) pre_constant(#f) string<delimiter(")content([NO VARIABLE: ~A])delimiter(")> operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
   operator_fat(')(post)operator_fat(\))operator_fat(\))

comment(;; interpolate ${(any (scheme expression\)\)} in strings:)
operator_fat(()reserved(define) operator_fat(()(interpolate) (str)operator_fat(\))
  operator_fat(()(regexp-substitute/global) pre_constant(#f) string<delimiter(")content(\\\\)content(${([^{}]+\)})delimiter(")> (str)
   operator_fat(')(pre) operator_fat(()reserved(lambda) operator_fat(()(m)operator_fat(\)) operator_fat(()(eval-string) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(')(post)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.9)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()(string-upcase) string<delimiter(")content(bo beep)delimiter(")>operator_fat(\))     comment(; BO PEEP)
operator_fat(()(string-downcase) string<delimiter(")content(JOHN)delimiter(")>operator_fat(\))      comment(; john)
operator_fat(()(string-titlecase) string<delimiter(")content(bo)delimiter(")>operator_fat(\))       comment(; Bo)
operator_fat(()(string-titlecase) string<delimiter(")content(JOHN)delimiter(")>operator_fat(\))     comment(; John)

operator_fat(()(string-titlecase) string<delimiter(")content(thIS is a loNG liNE)delimiter(")>operator_fat(\))  comment(; This Is A Long Line)

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; randcap: filter to randomly capitalize 20% of the time)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()(seed->random-state) operator_fat(()(current-time)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(randcap) (p)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
           operator_fat(()(display) operator_fat(()(string-map) operator_fat(()reserved(lambda) operator_fat(()(c)operator_fat(\))
                                  operator_fat(()reserved(if) operator_fat(()(=) operator_fat(()(random) integer(5)operator_fat(\)) integer(0)operator_fat(\))
                                    operator_fat(()(char-upcase) (c)operator_fat(\))
                                    operator_fat(()(char-downcase) (c)operator_fat(\))operator_fat(\))operator_fat(\))
                                (line)operator_fat(\))operator_fat(\))
           operator_fat(()(loop) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\))
    operator_fat(()(randcap) operator_fat(()(current-input-port)operator_fat(\))operator_fat(\))
    operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(f)operator_fat(\)) operator_fat(()(call-with-input-file) (f) (randcap)operator_fat(\))operator_fat(\)) (args)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.10)
comment(;; You can do this with format.  Lisp/Scheme format is a little)
comment(;; different from what you may be used to with C/Perl style printf)
comment(;; (actually far more powerful\) , but if you keep in mind that we use)
comment(;; ~ instead of %, and , instead of . for the prefix characters, you)
comment(;; won't have trouble getting used to Guile's format.)

operator_fat(()(format) pre_constant(#f) string<delimiter(")content(I have ~A guanacos.)delimiter(")> (n)operator_fat(\))

comment(;; @@PLEAC@@_1.11)
operator_fat(()reserved(define) (var) string<delimiter(")content(
        your text
        goes here)delimiter(")>operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(ice-9) (regexp)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (var) operator_fat(()(regexp-substitute/global) pre_constant(#f) string<delimiter(")content(\\n)content( +)delimiter(")> (var) operator_fat(')(pre) string<delimiter(")content(\\n)delimiter(")> operator_fat(')(post)operator_fat(\))operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (var) operator_fat(()(string-join) operator_fat(()(map) (string-trim) operator_fat(()(string-tokenize) (var) char(#\\newline)operator_fat(\))operator_fat(\)) string<delimiter(")content(\\n)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(ice-9) (regexp)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(srfi) (srfi-14)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(dequote) (str)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(str) operator_fat(()reserved(if) operator_fat(()(char=?) operator_fat(()(string-ref) (str) integer(0)operator_fat(\)) char(#\\newline)operator_fat(\))
                operator_fat(()(substring) (str) integer(1)operator_fat(\)) (str)operator_fat(\))operator_fat(\))
         operator_fat(()(lines) operator_fat(()(string-tokenize) (str) char(#\\newline)operator_fat(\))operator_fat(\))
         operator_fat(()(rx) operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(leader) operator_fat(()(car) (lines)operator_fat(\))operator_fat(\)) operator_fat(()(lst) operator_fat(()(cdr) (lines)operator_fat(\))operator_fat(\))operator_fat(\))
               operator_fat(()reserved(cond) operator_fat(()operator_fat(()(string=) (leader) string<delimiter(")delimiter(")>operator_fat(\))
                      operator_fat(()reserved(let) operator_fat(()operator_fat(()(pos) operator_fat(()reserved(or) operator_fat(()(string-skip) operator_fat(()(car) (lines)operator_fat(\))
                                                  (char-set:whitespace)operator_fat(\)) integer(0)operator_fat(\))operator_fat(\))operator_fat(\))
                        operator_fat(()(make-regexp) operator_fat(()(format) pre_constant(#f) string<delimiter(")content(^[ )content(\\\\)content(t]{1,~A})delimiter(")> (pos)operator_fat(\))
                                     (regexp/newline)operator_fat(\))operator_fat(\))operator_fat(\))
                     operator_fat(()operator_fat(()(null?) (lst)operator_fat(\))
                      operator_fat(()(make-regexp) operator_fat(()(string-append) string<delimiter(")content(^[ )content(\\\\)content(t]*)delimiter(")>
                                                  operator_fat(()(regexp-quote) (leader)operator_fat(\))operator_fat(\))
                                   (regexp/newline)operator_fat(\))operator_fat(\))
                     operator_fat(()(else)
                      operator_fat(()reserved(let) operator_fat(()operator_fat(()(pos) operator_fat(()reserved(or) operator_fat(()(string-prefix-length) (leader) operator_fat(()(car) (lst)operator_fat(\))operator_fat(\)) integer(0)operator_fat(\))operator_fat(\))operator_fat(\))
                        operator_fat(()(loop) operator_fat(()(substring) (leader) integer(0) (pos)operator_fat(\)) operator_fat(()(cdr) (lst)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(regexp-substitute/global) pre_constant(#f) (rx) (str) operator_fat(')(pre) operator_fat(')(post)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.12)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (text) string<delimiter(")content(Folding and splicing is the work of an editor,
not a mere collection of silicon
and
mobile electrons!)delimiter(")>operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(wrap) (str) (max-col)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(words) operator_fat(()(string-tokenize) (str)operator_fat(\))operator_fat(\))
         operator_fat(()(all) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
         operator_fat(()(first) operator_fat(()(car) (words)operator_fat(\))operator_fat(\))
         operator_fat(()(col) operator_fat(()(string-length) (first)operator_fat(\))operator_fat(\))
         operator_fat(()(line) operator_fat(()(list) (first)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(for-each)
     operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\))
       operator_fat(()reserved(let*) operator_fat(()operator_fat(()(len) operator_fat(()(string-length) (x)operator_fat(\))operator_fat(\))
              operator_fat(()(new-col) operator_fat(()(+) (col) (len) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()reserved(cond) operator_fat(()operator_fat(()(>) (new-col) (max-col)operator_fat(\))
                operator_fat(()reserved(set!) (all) operator_fat(()reserved(cons) operator_fat(()(string-join) operator_fat(()(reverse!) (line)operator_fat(\)) string<delimiter(")content( )delimiter(")>operator_fat(\)) (all)operator_fat(\))operator_fat(\))
                operator_fat(()reserved(set!) (line) operator_fat(()(list) (x)operator_fat(\))operator_fat(\))
                operator_fat(()reserved(set!) (col) (len)operator_fat(\))operator_fat(\))
               operator_fat(()(else)
                operator_fat(()reserved(set!) (line) operator_fat(()reserved(cons) (x) (line)operator_fat(\))operator_fat(\))
                operator_fat(()reserved(set!) (col) (new-col)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()(cdr) (words)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(set!) (all) operator_fat(()reserved(cons) operator_fat(()(string-join) operator_fat(()(reverse!) (line)operator_fat(\)) string<delimiter(")content( )delimiter(")>operator_fat(\)) (all)operator_fat(\))operator_fat(\))
    operator_fat(()(string-join) operator_fat(()(reverse!) (all)operator_fat(\)) string<delimiter(")content(\\n)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(display) operator_fat(()(wrap) (text) integer(20)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.13)
operator_fat(()reserved(define) (str) string<delimiter(")content(Mom said, )content(\\")content(Don't do that.)content(\\")delimiter(")>operator_fat(\))
operator_fat(()reserved(set!) (str) operator_fat(()(regexp-substitute/global) pre_constant(#f) string<delimiter(")content([')content(\\")content(])delimiter(")> (str) operator_fat(')(pre) string<delimiter(")content(\\\\)delimiter(")>
                                    (match:substring) operator_fat(')(post)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (str) operator_fat(()(regexp-substitute/global) pre_constant(#f) string<delimiter(")content([^A-Z])delimiter(")> (str) operator_fat(')(pre) string<delimiter(")content(\\\\)delimiter(")>
                                    (match:substring) operator_fat(')(post)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (str) operator_fat(()(string-append) string<delimiter(")content(this )delimiter(")> operator_fat(()(regexp-substitute/global)
                                  pre_constant(#f) string<delimiter(")content(\\W)delimiter(")> string<delimiter(")content(is a test!)delimiter(")> operator_fat(')(pre) string<delimiter(")content(\\\\)delimiter(")>
                                  (match:substring) operator_fat(')(post)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.14)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (str) string<delimiter(")content(  space  )delimiter(")>operator_fat(\))
operator_fat(()(string-trim) (str)operator_fat(\))          comment(; "space  ")
operator_fat(()(string-trim-right) (str)operator_fat(\))    comment(; "  space")
operator_fat(()(string-trim-both) (str)operator_fat(\))     comment(; "space")

comment(;; @@PLEAC@@_1.15)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-2)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (parse-csv)
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(csv-match) operator_fat(()(string-join) operator_fat(')operator_fat(()string<delimiter(")content(\\")content(([^)content(\\")content(\\\\)content(\\\\)content(]*()content(\\\\)content(\\\\)content(.[^)content(\\")content(\\\\)content(\\\\)content(]*\)*\))content(\\")content(,?)delimiter(")>
                                   string<delimiter(")content(([^,]+\),?)delimiter(")>
                                   string<delimiter(")content(,)delimiter(")>operator_fat(\))
                                 string<delimiter(")content(|)delimiter(")>operator_fat(\))operator_fat(\))
         operator_fat(()(csv-rx) operator_fat(()(make-regexp) (csv-match)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(text)operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(start) integer(0)operator_fat(\))
            operator_fat(()(result) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(start) integer(0)operator_fat(\))operator_fat(\))
          operator_fat(()(and-let*) operator_fat(()operator_fat(()(m) operator_fat(()(regexp-exec) (csv-rx) (text) (start)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()reserved(set!) (result) operator_fat(()reserved(cons) operator_fat(()reserved(or) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))
                                   operator_fat(()(match:substring) (m) integer(3)operator_fat(\))operator_fat(\))
                               (result)operator_fat(\))operator_fat(\))
            operator_fat(()(loop) operator_fat(()(match:end) (m)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(reverse) (result)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (line) string<delimiter(")content(XYZZY,)content(\\")content(\\")content(,)content(\\")content(O'Reilly, Inc)content(\\")content(,)content(\\")content(Wall, Larry)content(\\")content(,)content(\\")content(a )content(\\\\)content(\\")content(glug)content(\\\\)content(\\")content( bit,)content(\\")content(,5,)content(\\")content(Error, Core Dumped)content(\\")delimiter(")>operator_fat(\))

operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))
     operator_fat(()(fields) operator_fat(()(parse-csv) (line)operator_fat(\)) operator_fat(()(cdr) (fields)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(null?) (fields)operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~D : ~A)content(\\n)delimiter(")> (i) operator_fat(()(car) (fields)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_1.16)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(srfi) (srfi-14)operator_fat(\))operator_fat(\))

comment(;; Knuth's soundex algorithm from The Art of Computer Programming, Vol 3)
operator_fat(()reserved(define) (soundex)
  operator_fat(()reserved(letrec) operator_fat(()operator_fat(()(chars) string<delimiter(")content(AEIOUYBFPVCGJKQSXZDTLMNR)delimiter(")>operator_fat(\))
           operator_fat(()(nums) string<delimiter(")content(000000111122222222334556)delimiter(")>operator_fat(\))
           operator_fat(()(skipchars) operator_fat(()(string->char-set) string<delimiter(")content(HW)delimiter(")>operator_fat(\))operator_fat(\))
           operator_fat(()(trans) operator_fat(()reserved(lambda) operator_fat(()(c)operator_fat(\))
                    operator_fat(()reserved(let) operator_fat(()operator_fat(()(i) operator_fat(()(string-index) (chars) (c)operator_fat(\))operator_fat(\))operator_fat(\))
                      operator_fat(()reserved(if) (i) operator_fat(()(string-ref) (nums) (i)operator_fat(\)) (c)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(str)operator_fat(\))
      operator_fat(()reserved(let*) operator_fat(()operator_fat(()(ustr) operator_fat(()(string-upcase) (str)operator_fat(\))operator_fat(\))
             operator_fat(()(f) operator_fat(()(string-ref) (ustr) integer(0)operator_fat(\))operator_fat(\))
             operator_fat(()(skip) operator_fat(()(trans) (f)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(let*) operator_fat(()operator_fat(()(mstr) operator_fat(()(string-map) (trans) operator_fat(()(string-delete) (ustr) (skipchars) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
               operator_fat(()(dstr) operator_fat(()(string-map) operator_fat(()reserved(lambda) operator_fat(()(c)operator_fat(\))
                                   operator_fat(()reserved(cond) operator_fat(()operator_fat(()(eq?) (c) (skip)operator_fat(\)) char(#\\0)operator_fat(\))
                                         operator_fat(()(else) operator_fat(()reserved(set!) (skip) (c)operator_fat(\)) (c)operator_fat(\))operator_fat(\))operator_fat(\))
                                 (mstr)operator_fat(\))operator_fat(\))
               operator_fat(()(zstr) operator_fat(()(string-delete) (dstr) char(#\\0)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(substring) operator_fat(()(string-append) operator_fat(()(make-string) integer(1) (f)operator_fat(\)) (zstr) string<delimiter(")content(000)delimiter(")>operator_fat(\)) integer(0) integer(4)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(soundex) string<delimiter(")content(Knuth)delimiter(")>operator_fat(\))  comment(; K530)
operator_fat(()(soundex) string<delimiter(")content(Kant)delimiter(")>operator_fat(\))   comment(; K530)
operator_fat(()(soundex) string<delimiter(")content(Lloyd)delimiter(")>operator_fat(\))  comment(; L300)
operator_fat(()(soundex) string<delimiter(")content(Ladd)delimiter(")>operator_fat(\))   comment(; L300)

comment(;; @@PLEAC@@_1.17)
error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))
             operator_fat(()(srfi) (srfi-14)operator_fat(\))
             operator_fat(()(ice-9) (rw)operator_fat(\))
             operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (data) string<delimiter(")content(analysed        => analyzed
built-in        => builtin
chastized       => chastised
commandline     => command-line
de-allocate     => deallocate
dropin          => drop-in
hardcode        => hard-code
meta-data       => metadata
multicharacter  => multi-character
multiway        => multi-way
non-empty       => nonempty
non-profit      => nonprofit
non-trappable   => nontrappable
pre-define      => predefine
preextend       => pre-extend
re-compiling    => recompiling
reenter         => re-enter
turnkey         => turn-key)delimiter(")>operator_fat(\))

operator_fat(()reserved(define) (input) operator_fat(()reserved(if) operator_fat(()(null?) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
                operator_fat(()(current-input-port)operator_fat(\))
                operator_fat(()(open-input-file) operator_fat(()(cadr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(let*) operator_fat(()operator_fat(()(newline-char-set) operator_fat(()(string->char-set) string<delimiter(")content(\\n)delimiter(")>operator_fat(\))operator_fat(\))
       operator_fat(()(assoc-char-set) operator_fat(()(string->char-set) string<delimiter(")content( =>)delimiter(")>operator_fat(\))operator_fat(\))
       operator_fat(()(dict) operator_fat(()(map)
              operator_fat(()reserved(lambda) operator_fat(()(line)operator_fat(\))
                operator_fat(()(string-tokenize) (line) (assoc-char-set)operator_fat(\))operator_fat(\))
              operator_fat(()(string-tokenize) (data) (newline-char-set)operator_fat(\))operator_fat(\))operator_fat(\))
       operator_fat(()(dict-match) operator_fat(()(string-join) operator_fat(()(map) (car) (dict)operator_fat(\)) string<delimiter(")content(|)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (input)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
           operator_fat(()(regexp-substitute/global)
            operator_fat(()(current-output-port)operator_fat(\)) (dict-match) (line)
            operator_fat(')(pre)
            operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\))
              operator_fat(()(cadr) operator_fat(()(assoc) operator_fat(()(match:substring) (x) integer(0)operator_fat(\)) (dict)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(')(post)operator_fat(\))
           operator_fat(()(loop) operator_fat(()(read-line) (input) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(close-port) (input)operator_fat(\))

comment(;; @@PLEAC@@_2.1)
comment(;; Strings and numbers are separate data types in Scheme, so this)
comment(;; isn't as important as it is in Perl.  More often you would use the)
comment(;; type predicates, string? and number?.)

operator_fat(()reserved(if) operator_fat(()(string-match) string<delimiter(")content([^)content(\\\\)content(d])delimiter(")> (str)operator_fat(\)) operator_fat(()(display) string<delimiter(")content(has nondigits)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(or) operator_fat(()(string-match) string<delimiter(")content(^)content(\\\\)content(d+$)delimiter(")> (str)operator_fat(\)) operator_fat(()(display) string<delimiter(")content(not a natural number)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(or) operator_fat(()(string-match) string<delimiter(")content(^-?)content(\\\\)content(d+$)delimiter(")> (str)operator_fat(\)) operator_fat(()(display) string<delimiter(")content(not an integer)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(or) operator_fat(()(string-match) string<delimiter(")content(^[)content(\\\\)content(-+]?)content(\\\\)content(d+$)delimiter(")> (str)operator_fat(\)) operator_fat(()(display) string<delimiter(")content(not an integer)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(or) operator_fat(()(string-match) string<delimiter(")content(^-?)content(\\\\)content(d+)content(\\.)content(?)content(\\d)content(*$)delimiter(")> (str)operator_fat(\)) operator_fat(()(display) string<delimiter(")content(not a decimal number)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(or) operator_fat(()(string-match) string<delimiter(")content(^-?()content(\\d)content(+()content(\\.)content(\\d)content(*\)?|)content(\\.)content(\\d)content(+\)$)delimiter(")> (str)operator_fat(\))
    operator_fat(()(display) string<delimiter(")content(not a decimal number)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(or) operator_fat(()(string-match) string<delimiter(")content(^([+-]?\)()content(\\d)content(|)content(\\.)content(\\d)content(\))content(\\d)content(*()content(\\.)content(\\d)content(*\)?([Ee]([+-]?)content(\\d)content(+\)\)?$)delimiter(")> (str)operator_fat(\))
    operator_fat(()(display) string<delimiter(")content(not a C float)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (num1) operator_fat(()(string->number) (str)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (num2) operator_fat(()(read)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.2)
comment(;; (approx-equal? num1 num2 accuracy\) : returns #t if num1 and num2 are)
comment(;;   equal to accuracy number of decimal places)
operator_fat(()reserved(define) operator_fat(()(approx-equal?) (num1) (num2) (accuracy)operator_fat(\))
  operator_fat(()(<) operator_fat(()(abs) operator_fat(()(-) (num1) (num2)operator_fat(\))operator_fat(\)) operator_fat(()(expt) integer(10.0) operator_fat(()(-) (accuracy)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (wage) integer(536)operator_fat(\))                     comment(;; $5.36/hour)
operator_fat(()reserved(define) (week) operator_fat(()(*) integer(40) (wage)operator_fat(\))operator_fat(\))             comment(;; $214.40)
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(One week's wage is: $~$)content(\\n)delimiter(")> operator_fat(()(/) (week) integer(100.0)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.3)
operator_fat(()(round) (num)operator_fat(\))                           comment(;; rounds to inexact whole number)
operator_fat(()(inexact->exact) (num)operator_fat(\))                  comment(;; rounds to exact integer)

comment(;; You can also use format to convert numbers to more precisely)
comment(;; formatted strings.  Note Guile has a builtin format which is a more)
comment(;; limited version of that found in the (ice-9 format\) module, to save)
comment(;; load time.  Basically, if you are doing anything you couldn't do)
comment(;; with a series of (display\), (write\) and (newline\), then you'll need)
comment(;; to use the module.)
operator_fat(()(use-modules) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (a) integer(0.255)operator_fat(\))
operator_fat(()reserved(define) (b) operator_fat(()(/) operator_fat(()(round) operator_fat(()(*) integer(100.0) (a)operator_fat(\))operator_fat(\)) integer(100.0)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Unrounded: ~F)content(\\n)content(Rounded: ~F)content(\\n)delimiter(")> (a) (b)operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Unrounded: ~F)content(\\n)content(Rounded: ~,2F)content(\\n)delimiter(")> (a) (a)operator_fat(\))

operator_fat(()reserved(define) (a) operator_fat(')operator_fat(()integer(3.3) integer(3.5) integer(3.7) (-)integer(3.3)operator_fat(\))operator_fat(\))
operator_fat(()(display) string<delimiter(")content(number)content(\\t)content(int)content(\\t)content(floor)content(\\t)content(ceil)content(\\n)delimiter(")>operator_fat(\))
operator_fat(()(for-each)
 operator_fat(()reserved(lambda) operator_fat(()(n)operator_fat(\))
   operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~,1F)content(\\t)content(~,1F)content(\\t)content(~,1F)content(\\t)content(~,1F)content(\\n)delimiter(")>
           (n) operator_fat(()(round) (n)operator_fat(\)) operator_fat(()(floor) (n)operator_fat(\)) operator_fat(()(ceiling) (n)operator_fat(\))operator_fat(\))operator_fat(\))
 (a)operator_fat(\))

comment(;; @@PLEAC@@_2.4)
comment(;; numbers are radix independent internally, so you usually only)
comment(;; convert on output, however to convert strings:)
operator_fat(()reserved(define) operator_fat(()(dec->bin) (num)operator_fat(\))
  operator_fat(()(number->string) operator_fat(()(string->number) (num) integer(10)operator_fat(\)) integer(2)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(bin->dec) (num)operator_fat(\))
  operator_fat(()(number->string) operator_fat(()(string->number) (num) integer(2)operator_fat(\)) integer(10)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (num) operator_fat(()(bin->dec) string<delimiter(")content(0110110)delimiter(")>operator_fat(\))operator_fat(\))  comment(; 54)
operator_fat(()reserved(define) (binstr) operator_fat(()(dec->bin) string<delimiter(")content(54)delimiter(")>operator_fat(\))operator_fat(\))    comment(; 110110)

comment(;; @@PLEAC@@_2.5)
comment(;; do is the most general loop iterator)
operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) (x) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))   comment(; var  init-value  step-value)
    operator_fat(()operator_fat(()(>) (i) (y)operator_fat(\))operator_fat(\))        comment(; end when true)
  comment(;; i is set to every integer from x to y, inclusive)
  comment(;; ...)
  operator_fat(\))

comment(;; Guile also offers a while loop)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(i) (x)operator_fat(\))operator_fat(\))
  operator_fat(()(while) operator_fat(()(<=) (i) (y)operator_fat(\))
         comment(;; i is set to every integer from x to y, inclusive)
         comment(; ...)
         operator_fat(()reserved(set!) (i) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; named let is another common loop)
operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) (x)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(<=) (i) (y)operator_fat(\))
         comment(;; i is set to every integer from x to y, step-size 7)
         comment(;; ...)
         operator_fat(()(loop) operator_fat(()(+) (i) integer(7)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))  comment(; tail-recursive call)

operator_fat(()(display) string<delimiter(")content(Infancy is: )delimiter(")>operator_fat(\))
operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(>) (i) integer(2)operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A )delimiter(")> (i)operator_fat(\))operator_fat(\))
operator_fat(()(newline)operator_fat(\))

operator_fat(()(display) string<delimiter(")content(Toddling is: )delimiter(")>operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(i) integer(3)operator_fat(\))operator_fat(\))
  operator_fat(()(while) operator_fat(()(<=) (i) integer(4)operator_fat(\))
         operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A )delimiter(")> (i)operator_fat(\))
         operator_fat(()reserved(set!) (i) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(newline)operator_fat(\))

operator_fat(()(display) string<delimiter(")content(Childhood is: )delimiter(")>operator_fat(\))
operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) integer(5)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(<=) (i) integer(12)operator_fat(\))
         operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A )delimiter(")> (i)operator_fat(\))
         operator_fat(()(loop) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(newline)operator_fat(\))

comment(;; @@PLEAC@@_2.6)
comment(;; format can output roman numerals - use ~:@R)

operator_fat(()(use-modules) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Roman for ~R is ~:@R)content(\\n)delimiter(")> integer(15) integer(15)operator_fat(\))

comment(;; @@PLEAC@@_2.7)
operator_fat(()(random) integer(5)operator_fat(\))        comment(; an integer from 0 to 4)
operator_fat(()(random) integer(5.0)operator_fat(\))      comment(; an inexact real in the range [0,5\))

comment(;; char sets from SRFI-14 and string-unfold from SRFI-13 make a quick)
comment(;; way to generate passwords)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(srfi) (srfi-14)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (chars) operator_fat(()(char-set->string) (char-set:graphic)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (size) operator_fat(()(char-set-size) (char-set:graphic)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (password)
  operator_fat(()(string-unfold) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(=) (x) integer(8)operator_fat(\))operator_fat(\))
                 operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(string-ref) (chars) operator_fat(()(random) (size)operator_fat(\))operator_fat(\))operator_fat(\))
                 integer(1)(+) integer(0)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.8)
comment(;; if you're working with random numbers you'll probably want to set)
comment(;; the random seed)

operator_fat(()(seed->random-state) operator_fat(()(current-time)operator_fat(\))operator_fat(\))

comment(;; you can also save random states and pass them to any of the above)
comment(;; random functions)

operator_fat(()reserved(define) (state) operator_fat(()(copy-random-state)operator_fat(\))operator_fat(\))
operator_fat(()(random:uniform)operator_fat(\))
comment(;; 0.939377327721761)
operator_fat(()(random:uniform) (state)operator_fat(\))
comment(;; 0.939377327721761)

comment(;; @@PLEAC@@_2.9)
comment(;; @@INCOMPLETE@@)
comment(;; very inefficient)
operator_fat(()(use-modules) operator_fat(()(ice-9) (rw)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (make-true-random)
  operator_fat(()reserved(letrec) operator_fat(()operator_fat(()(bufsize) integer(8)operator_fat(\))
           operator_fat(()(accum) operator_fat(()reserved(lambda) operator_fat(()(c) (acc)operator_fat(\)) operator_fat(()(+) operator_fat(()(*) integer(256) (acc)operator_fat(\))
                                     operator_fat(()(char->integer) (c)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
           operator_fat(()(getbuf) operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
                     operator_fat(()(call-with-input-file) string<delimiter(")content(/dev/urandom)delimiter(")>
                       operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\))
                         operator_fat(()reserved(let) operator_fat(()operator_fat(()(buf) operator_fat(()(make-string) (bufsize)operator_fat(\))operator_fat(\))operator_fat(\))
                           operator_fat(()(read-string!/partial) (buf) (p)operator_fat(\))
                           (buf)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(rand-proc)operator_fat(\))
      operator_fat(()reserved(lambda) (args)
        operator_fat(()reserved(let) operator_fat(()operator_fat(()(state) operator_fat(()(seed->random-state) operator_fat(()(string-fold) (accum) integer(0) operator_fat(()(getbuf)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(apply) (rand-proc) operator_fat(()(append) (args) operator_fat(()(list) (state)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (urandom) operator_fat(()(make-true-random) (random)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (urandom:exp) operator_fat(()(make-true-random) (random:exp)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (urandom:normal) operator_fat(()(make-true-random) (random:normal)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (urandom:uniform) operator_fat(()(make-true-random) (random:uniform)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.10)
comment(;; Guile offers a number of random distributions)

operator_fat(()(random:exp)operator_fat(\))      comment(; an inexact real in an exponential dist with mean 1)
operator_fat(()(random:normal)operator_fat(\))   comment(; an inexact real in a standard normal distribution)
operator_fat(()(random:uniform)operator_fat(\))  comment(; a uniformly distributed inexact real in [0,1\))

comment(;; There are also functions to fill vectors with random distributions)

comment(;; Fills vector v with inexact real random numbers the sum of whose)
comment(;; squares is equal to 1.0.)
operator_fat(()(random:hollow-sphere!) (v)operator_fat(\))

comment(;; Fills vector v with inexact real random numbers that are)
comment(;; independent and standard normally distributed (i.e., with mean 0)
comment(;; and variance 1\).)
operator_fat(()(random:normal-vector!) (v)operator_fat(\))

comment(;; Fills vector v with inexact real random numbers the sum of whose)
comment(;; squares is less than 1.0.)
operator_fat(()(random:solid-sphere!) (v)operator_fat(\))

comment(;; @@PLEAC@@_2.11)
comment(;; Guile's trigonometric functions use radians.)

operator_fat(()reserved(define) (pi) integer(3.14159265358979)operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(degrees->radians) (deg)operator_fat(\))
  operator_fat(()(*) (pi) operator_fat(()(/) (deg) integer(180.0)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(radians->degrees) (rad)operator_fat(\))
  operator_fat(()(*) integer(180.0) operator_fat(()(/) (rad) (pi)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(degree-sine) (deg)operator_fat(\))
  operator_fat(()(sin) operator_fat(()(degrees->radians) (deg)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.12)

comment(;; Guile provides the following standard trigonometric functions (and)
comment(;; their hyperbolic equivalents\), defined for all real and complex)
comment(;; numbers:)

operator_fat(()(sin) (z)operator_fat(\))
operator_fat(()(cos) (z)operator_fat(\))
operator_fat(()(tan) (z)operator_fat(\))
operator_fat(()(asin) (z)operator_fat(\))
operator_fat(()(acos) (z)operator_fat(\))
operator_fat(()(atan) (z)operator_fat(\))

operator_fat(()(acos) integer(3.7)operator_fat(\))  comment(; 0.0+1.9826969446812i)

comment(;; @@PLEAC@@_2.13)
comment(;; Guile provides log in base e and 10 natively, defined for any real)
comment(;; or complex numbers:)

operator_fat(()(log) (z)operator_fat(\))    comment(; natural logarithm)
operator_fat(()(log10) (z)operator_fat(\))  comment(; base-10 logarithm)

comment(;; For other bases, divide by the log of the base:)

operator_fat(()reserved(define) operator_fat(()(log-base) (n) (z)operator_fat(\))
  operator_fat(()(/) operator_fat(()(log) (z)operator_fat(\)) operator_fat(()(log) (n)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; To avoid re-computing (log n\) for a base you want to use)
comment(;; frequently, you can create a custom log function:)

operator_fat(()reserved(define) operator_fat(()(make-log-base) (n)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(divisor) operator_fat(()(log) (n)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(z)operator_fat(\)) operator_fat(()(/) operator_fat(()(log) (z)operator_fat(\)) (divisor)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (log2) operator_fat(()(make-log-base) integer(2)operator_fat(\))operator_fat(\))

operator_fat(()(log2) integer(1024)operator_fat(\))

comment(;; @@PLEAC@@_2.14)
comment(;; In addition to simple vectors, Guile has builtin support for)
comment(;; uniform arrays of an arbitrary dimension.)

comment(;; a rows x cols integer matrix)
operator_fat(()reserved(define) (a) operator_fat(()(make-array) integer(0) (rows) (cols)operator_fat(\))operator_fat(\))
operator_fat(()(array-set!) (a) integer(3) (row) (col)operator_fat(\))
operator_fat(()(array-ref) (a) (row) (col)operator_fat(\))

comment(;; a 3D matrix of reals)
operator_fat(()reserved(define) (b) operator_fat(()(make-array) integer(0.0) (x) (y) (z)operator_fat(\))operator_fat(\))

comment(;; a literal boolean truth table for logical and)
operator_fat(')error(#)integer(2)operator_fat(()operator_fat(()pre_constant(#f) pre_constant(#f)operator_fat(\)) operator_fat(()pre_constant(#f) pre_constant(#t)operator_fat(\))operator_fat(\))

comment(;; simple matrix multiplication)

operator_fat(()reserved(define) operator_fat(()(matrix-mult) (m1) (m2)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(d1) operator_fat(()(array-dimensions) (m1)operator_fat(\))operator_fat(\))
         operator_fat(()(d2) operator_fat(()(array-dimensions) (m2)operator_fat(\))operator_fat(\))
         operator_fat(()(m1rows) operator_fat(()(car) (d1)operator_fat(\))operator_fat(\))
         operator_fat(()(m1cols) operator_fat(()(cadr) (d1)operator_fat(\))operator_fat(\))
         operator_fat(()(m2rows) operator_fat(()(car) (d2)operator_fat(\))operator_fat(\))
         operator_fat(()(m2cols) operator_fat(()(cadr) (d2)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(=) (m1cols) (m2rows)operator_fat(\))operator_fat(\))
      operator_fat(()(error) operator_fat(')(index-error) string<delimiter(")content(matrices don't match)delimiter(")>operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(result) operator_fat(()(make-array) integer(0) (m1rows) (m2cols)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(=) (i) (m1rows)operator_fat(\))operator_fat(\))
        operator_fat(()reserved(do) operator_fat(()operator_fat(()(j) integer(0) operator_fat(()integer(1)(+) (j)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()operator_fat(()(=) (j) (m2cols)operator_fat(\))operator_fat(\))
          operator_fat(()reserved(do) operator_fat(()operator_fat(()(k) integer(0) operator_fat(()integer(1)(+) (k)operator_fat(\))operator_fat(\))operator_fat(\))
              operator_fat(()operator_fat(()(=) (k) (m1cols)operator_fat(\))operator_fat(\))
            operator_fat(()(array-set!) (result) operator_fat(()(+) operator_fat(()(array-ref) (result) (i) (j)operator_fat(\))
                                  operator_fat(()(*) operator_fat(()(array-ref) (m1) (i) (k)operator_fat(\))
                                     operator_fat(()(array-ref) (m2) (k) (j)operator_fat(\))operator_fat(\))operator_fat(\))
                        (i) (j)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
      (result)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(matrix-mult) operator_fat(')error(#)integer(2)operator_fat(()operator_fat(()integer(3) integer(2) integer(3)operator_fat(\)) operator_fat(()integer(5) integer(9) integer(8)operator_fat(\))operator_fat(\)) operator_fat(')error(#)integer(2)operator_fat(()operator_fat(()integer(4) integer(7)operator_fat(\)) operator_fat(()integer(9) integer(3)operator_fat(\)) operator_fat(()integer(8) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.15)
comment(;; Guile has builtin support for complex numbers:)

operator_fat(()reserved(define) (i) integer(0+1i)operator_fat(\))       comment(; 0.0+1.0i)
operator_fat(()reserved(define) (i) operator_fat(()(sqrt) (-)integer(1)operator_fat(\))operator_fat(\))  comment(; 0.0+1.0i)

operator_fat(()(complex?) (i)operator_fat(\))          comment(; #t)
operator_fat(()(real-part) (i)operator_fat(\))         comment(; 0.0)
operator_fat(()(imag-part) (i)operator_fat(\))         comment(; 1.0)

operator_fat(()(*) integer(3+5i) integer(2-2i)operator_fat(\))         comment(; 16+4i)
operator_fat(()(sqrt) integer(3+4i)operator_fat(\))           comment(; 2+i)

comment(;; Classic identity:  -e^(pi*i\) => 1)
operator_fat(()(inexact->exact) operator_fat(()(real-part) operator_fat(()(-) operator_fat(()(exp) operator_fat(()(*) (pi) integer(0+1i)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) comment(; 1)

comment(;; @@PLEAC@@_2.16)
comment(;; You can type in literal numbers in alternate radixes:)

integer(#b01101101)     comment(; 109 in binary)
integer(#o155)          comment(; 109 in octal)
integer(#d109)          comment(; 109 in decimal)
integer(#x6d)           comment(; 109 in hexadecimal)

comment(;; number->string and string->number also take an optional radix:)

operator_fat(()reserved(define) (number) operator_fat(()(string->number) (hexadecimal) integer(16)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (number) operator_fat(()(string->number) (octal) integer(8)operator_fat(\))operator_fat(\))

comment(;; format will also output in different radixes:)

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~B ~O ~D ~X)content(\\n)delimiter(")> (num) (num) (num) (num)operator_fat(\))

comment(;; converting Unix file permissions read from stdin:)

operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(perm) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (perm)operator_fat(\))operator_fat(\))
         operator_fat(()(format) pre_constant(#t) string<delimiter(")content(The decimal value is ~D)content(\\n)delimiter(")> operator_fat(()(string->number) (perm) integer(8)operator_fat(\))operator_fat(\))
         operator_fat(()(loop) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.17)
comment(;; once again, format is our friend :\))
operator_fat(()(use-modules) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))

comment(;; the : prefix to the D directive causes commas to be output every)
comment(;; three digits.)
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~:D)content(\\n)delimiter(")> operator_fat(()(random) integer(10000000000000000)operator_fat(\))operator_fat(\))
comment(; => 2,301,267,079,619,540)

comment(;; the third prefix arg to the D directive is the separator character)
comment(;; to use instead of a comma, useful for European style numbers:)
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~,,'.:D)content(\\n)delimiter(")> operator_fat(()(random) integer(10000000000000000)operator_fat(\))operator_fat(\))
comment(; => 6.486.470.447.356.534)

comment(;; the F directive, however, does not support grouping by commas.  to)
comment(;; achieve this, we can format the integer and fractional parts)
comment(;; separately:)
operator_fat(()reserved(define) operator_fat(()(commify) (num)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(int) operator_fat(()(inexact->exact) operator_fat(()(truncate) (num)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(=) (num) (int)operator_fat(\))
      operator_fat(()(format) pre_constant(#f) string<delimiter(")content(~:D)delimiter(")> (int)operator_fat(\))
      operator_fat(()(string-append) operator_fat(()(format) pre_constant(#f) string<delimiter(")content(~:D)delimiter(")> (int)operator_fat(\))
                     operator_fat(()reserved(let) operator_fat(()operator_fat(()(str) operator_fat(()(format) pre_constant(#f) string<delimiter(")content(~F)delimiter(")> (num)operator_fat(\))operator_fat(\))operator_fat(\))
                       operator_fat(()(substring) (str) operator_fat(()reserved(or) operator_fat(()(string-index) (str) char(#\\.)operator_fat(\))
                                          operator_fat(()(string-length) (str)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.18)
comment(;; format can handle simple 's' plurals with ~p, and 'y/ies' plurals)
comment(;; with the @ prefix:)

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(It took ~D hour~P)content(\\n)delimiter(")> (hours) (hours)operator_fat(\))

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(It took ~D centur~@P)content(\\n)delimiter(")> (centuries) (centuries)operator_fat(\))

operator_fat(()reserved(define) (noun-plural)
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(suffixes) operator_fat(')operator_fat(()operator_fat(()string<delimiter(")content(ss)delimiter(")>  operator(.) string<delimiter(")content(sses)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(ph)delimiter(")>  operator(.) string<delimiter(")content(phes)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(sh)delimiter(")>  operator(.) string<delimiter(")content(shes)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(ch)delimiter(")>  operator(.) string<delimiter(")content(ches)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(z)delimiter(")>   operator(.) string<delimiter(")content(zes)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(ff)delimiter(")>  operator(.) string<delimiter(")content(ffs)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(f)delimiter(")>   operator(.) string<delimiter(")content(ves)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(ey)delimiter(")>  operator(.) string<delimiter(")content(eys)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(y)delimiter(")>   operator(.) string<delimiter(")content(ies)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(ix)delimiter(")>  operator(.) string<delimiter(")content(ices)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(s)delimiter(")>   operator(.) string<delimiter(")content(ses)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(x)delimiter(")>   operator(.) string<delimiter(")content(xes)delimiter(")>operator_fat(\))
                     operator_fat(()string<delimiter(")content(ius)delimiter(")> operator(.) string<delimiter(")content(ii)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(suffix-match)
         operator_fat(()(string-append) string<delimiter(")content(()delimiter(")> operator_fat(()(string-join) operator_fat(()(map) (car) (suffixes)operator_fat(\)) string<delimiter(")content(|)delimiter(")>operator_fat(\)) string<delimiter(")content(\)$)delimiter(")>operator_fat(\))operator_fat(\))
        operator_fat(()(suffix-rx) operator_fat(()(make-regexp) (suffix-match)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(noun)operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(m) operator_fat(()(regexp-exec) (suffix-rx) (noun)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(if) (m)
          operator_fat(()(string-append) operator_fat(()(regexp-substitute) pre_constant(#f) (m) operator_fat(')(pre)operator_fat(\))
                         operator_fat(()(cdr) operator_fat(()(assoc) operator_fat(()(match:substring) (m)operator_fat(\)) (suffixes)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(string-append) (noun) string<delimiter(")content(s)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_2.19)
error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)

comment(;; very naive factoring algorithm)
operator_fat(()reserved(define) operator_fat(()(factor) (n)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(factors) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
        operator_fat(()(limit) operator_fat(()(inexact->exact) operator_fat(()(round) operator_fat(()(sqrt) (n)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(twos) integer(0)operator_fat(\))operator_fat(\))
    comment(;; factor out 2's)
    operator_fat(()(while) operator_fat(()(even?) (n)operator_fat(\))
           operator_fat(()reserved(set!) (n) operator_fat(()(ash) (n) (-)integer(1)operator_fat(\))operator_fat(\))
           operator_fat(()reserved(set!) (twos) operator_fat(()integer(1)(+) (twos)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(>) (twos) integer(0)operator_fat(\)) operator_fat(()reserved(set!) (factors) operator_fat(()(list) operator_fat(()reserved(cons) integer(2) (twos)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    comment(;; factor out odd primes)
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) integer(3)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(r) operator_fat(()(remainder) (n) (i)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(cond) operator_fat(()operator_fat(()(=) (r) integer(0)operator_fat(\))
               operator_fat(()reserved(set!) (n) operator_fat(()(quotient) (n) (i)operator_fat(\))operator_fat(\))
               operator_fat(()reserved(let*) operator_fat(()operator_fat(()(old-val) operator_fat(()(assv) (i) (factors)operator_fat(\))operator_fat(\))
                      operator_fat(()(new-val) operator_fat(()reserved(if) (old-val) operator_fat(()integer(1)(+) operator_fat(()(cdr) (old-val)operator_fat(\))operator_fat(\)) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
                 operator_fat(()reserved(set!) (factors) operator_fat(()(assv-set!) (factors) (i) (new-val)operator_fat(\))operator_fat(\))operator_fat(\))
               operator_fat(()(loop) (i)operator_fat(\))operator_fat(\))
              operator_fat(()operator_fat(()(<) (i) (limit)operator_fat(\))
               operator_fat(()(loop) operator_fat(()(+) integer(2) (i)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    comment(;; remainder)
    operator_fat(()reserved(if) operator_fat(()(>) (n) integer(1)operator_fat(\)) operator_fat(()reserved(set!) (factors) operator_fat(()reserved(cons) operator_fat(()reserved(cons) (n) integer(1)operator_fat(\)) (factors)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(reverse!) (factors)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; pretty print a term of a factor)
operator_fat(()reserved(define) operator_fat(()(pp-term) (pair)operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(=) operator_fat(()(cdr) (pair)operator_fat(\)) integer(1)operator_fat(\))
    operator_fat(()(number->string) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
    operator_fat(()(format) pre_constant(#f) string<delimiter(")content(~A^~A)delimiter(")> operator_fat(()(car) (pair)operator_fat(\)) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; factor each number given on the command line)
operator_fat(()(for-each)
 operator_fat(()reserved(lambda) operator_fat(()(n)operator_fat(\))
   operator_fat(()reserved(let) operator_fat(()operator_fat(()(factors) operator_fat(()(factor) (n)operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A = ~A)delimiter(")> (n) operator_fat(()(pp-term) operator_fat(()(car) (factors)operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(format) pre_constant(#t) string<delimiter(")content( * ~A)delimiter(")> operator_fat(()(pp-term) (x)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(cdr) (factors)operator_fat(\))operator_fat(\))
     operator_fat(()(newline)operator_fat(\))operator_fat(\))operator_fat(\))
 operator_fat(()(map) (string->number) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.0)
comment(;; Use the builtin POSIX time functions)

comment(;; get the current time)
operator_fat(()(current-time)operator_fat(\))   comment(; number of seconds since the epoch)
operator_fat(()(gettimeofday)operator_fat(\))   comment(; pair of seconds and microseconds since the epoch)

comment(;; create a time object from an integer (e.g. returned by current-time\))
operator_fat(()(localtime) (time)operator_fat(\)) comment(; in localtime)
operator_fat(()(gmtime) (time)operator_fat(\))    comment(; in UTC)

comment(;; get/set broken down components of a time object)

operator_fat(()(tm:sec) (time)operator_fat(\))    operator_fat(()(set-tm:sec) (time) (secs)operator_fat(\))    comment(; seconds (0-59\))
operator_fat(()(tm:min) (time)operator_fat(\))    operator_fat(()(set-tm:min) (time) (mins)operator_fat(\))    comment(; minutes (0-59\))
operator_fat(()(tm:hour) (time)operator_fat(\))   operator_fat(()(set-tm:hour) (time) (hours)operator_fat(\))  comment(; hours (0-23\))
operator_fat(()(tm:mday) (time)operator_fat(\))   operator_fat(()(set-tm:mday) (time) (mday)operator_fat(\))   comment(; day of the month (1-31\))
operator_fat(()(tm:mon) (time)operator_fat(\))    operator_fat(()(set-tm:mon) (time) (month)operator_fat(\))   comment(; month (0-11\))
operator_fat(()(tm:year) (time)operator_fat(\))   operator_fat(()(set-tm:year) (time) (year)operator_fat(\))   comment(; year minus 1900 (70-\))
operator_fat(()(tm:wday) (time)operator_fat(\))   operator_fat(()(set-tm:wday) (time) (wday)operator_fat(\))   comment(; day of the week (0-6\))
                                           comment(; where Sunday is 0)
operator_fat(()(tm:yday) (time)operator_fat(\))   operator_fat(()(set-tm:yday) (time) (yday)operator_fat(\))   comment(; day of year (0-365\))
operator_fat(()(tm:isdst) (time)operator_fat(\))  operator_fat(()(set-tm:isdst) (time) (isdst)operator_fat(\)) comment(; daylight saving indicator)
                                           comment(; 0 for "no", > 0 for "yes",)
                                           comment(; < 0 for "unknown")
operator_fat(()(tm:gmtoff) (time)operator_fat(\)) operator_fat(()(set-tm:gmtoff) (time) (off)operator_fat(\))  comment(; time zone offset in seconds)
                                           comment(; west of UTC (-46800 to 43200\))
operator_fat(()(tm:zone) (time)operator_fat(\))   operator_fat(()(set-tm:zone) (time) (zone)operator_fat(\))   comment(; Time zone label (a string\),)
                                           comment(; not necessarily unique.)

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Today is day ~A of the current year.)content(\\n)delimiter(")>
        operator_fat(()(tm:yday) operator_fat(()(localtime) operator_fat(()(current-time)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; Or use SRFI-19 - Time and Date Procedures)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (now) operator_fat(()(current-date)operator_fat(\))operator_fat(\))  comment(; immutable once created)

operator_fat(()(date-nanosecond) (now)operator_fat(\))        comment(; 0-9,999,999)
operator_fat(()(date-second) (now)operator_fat(\))            comment(; 0-60 (60 represents a leap second\))
operator_fat(()(date-minute) (now)operator_fat(\))            comment(; 0-59)
operator_fat(()(date-hour) (now)operator_fat(\))              comment(; 0-23)
operator_fat(()(date-day) (now)operator_fat(\))               comment(; 0-31)
operator_fat(()(date-month) (now)operator_fat(\))             comment(; 1-12)
operator_fat(()(date-year) (now)operator_fat(\))              comment(; integer representing the year)
operator_fat(()(date-year-day) (now)operator_fat(\))          comment(; day of year (Jan 1 is 1, etc.\))
operator_fat(()(date-week-day) (now)operator_fat(\))          comment(; day of week (Sunday is 0, etc.\))
operator_fat(()(date-week-number) (now) (start)operator_fat(\)) comment(; week of year, ignoring a first partial week)
                             comment(; start is the first day of week as above)
operator_fat(()(date-zone-offset) (now)operator_fat(\))       comment(; integer number of seconds east of GMT)

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Today is day ~A of the current year.)content(\\n)delimiter(")>
        operator_fat(()(date-year-day) operator_fat(()(current-date)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.1)
comment(;; using format and POSIX time components)
operator_fat(()(use-modules) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(now) operator_fat(()(localtime) operator_fat(()(current-time)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(The current date is ~4'0D ~2'0D ~2'0D)content(\\n)delimiter(")>
          operator_fat(()(+) integer(1900) operator_fat(()(tm:year) (now)operator_fat(\))operator_fat(\)) operator_fat(()(tm:mon) (now)operator_fat(\)) operator_fat(()(tm:mday) (now)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; using format and SRFI-19 time components)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\)) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(now) operator_fat(()(current-date)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(The current date is ~4'0d-~2'0D-~2'0D)content(\\n)delimiter(")>
          operator_fat(()(date-year) (now)operator_fat(\)) operator_fat(()(date-month) (now)operator_fat(\)) operator_fat(()(date-day) (now)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; using POSIX strftime with a libc time format string)
operator_fat(()(display) operator_fat(()(strftime) string<delimiter(")content(%Y-%m-%d)content(\\n)delimiter(")> operator_fat(()(localtime) operator_fat(()(current-time)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.2)
comment(;; set the individual components of a time struct and use mktime)
operator_fat(()reserved(define) (time) operator_fat(()(localtime) operator_fat(()(current-time)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(set-tm:mday) (time) (mday)operator_fat(\))
operator_fat(()(set-tm:mon) (time) (mon)operator_fat(\))
operator_fat(()(set-tm:year) (time) (year)operator_fat(\))
operator_fat(()(car) operator_fat(()(mktime) (time)operator_fat(\))operator_fat(\))  comment(; mktime returns a (epoch-seconds . time\) pair)

comment(;; or use SRFI-19's make-date and date->time-monotonic)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))
operator_fat(()(date->time-monotonic)
 operator_fat(()(make-date) (nanosecond) (second) (minute) (hour) (day) (month) (year) (zone-offset)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.3)
comment(;; use localtime or gmtime with the accessors mentioned in the)
comment(;; introduction to this chapter)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(time) operator_fat(()(localtime) (seconds)operator_fat(\))operator_fat(\))operator_fat(\))  comment(; or gmtime)
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Dateline: ~2'0d:~2'0d:~2'0d-~4'0d/~2'0d/~2'0d)content(\\n)delimiter(")>
          operator_fat(()(tm:hour) (time)operator_fat(\)) operator_fat(()(tm:min) (time)operator_fat(\)) operator_fat(()(tm:sec) (time)operator_fat(\))
          operator_fat(()(+) integer(1900) operator_fat(()(tm:year) (time)operator_fat(\))operator_fat(\)) operator_fat(()integer(1)(+) operator_fat(()(tm:mon) (time)operator_fat(\))operator_fat(\)) operator_fat(()(tm:mday) (time)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or use SRFI-19)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(time) operator_fat(()(make-time) (time-monotonic) (nanosecond) (second)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(display) operator_fat(()(date->string) operator_fat(()(time-monotonic->date) (time)operator_fat(\)) string<delimiter(")content(~T-~1)content(\\n)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.4)
comment(;; just add or subtract epoch seconds)
operator_fat(()reserved(define) (when) operator_fat(()(+) (now) (difference)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (then) operator_fat(()(-) (now) (difference)operator_fat(\))operator_fat(\))

comment(;; if you have DMYHMS values, you can convert them to times or add)
comment(;; them as seconds:)
operator_fat(()reserved(define) (birthtime) integer(96176750)operator_fat(\))
operator_fat(()reserved(define) (interval) operator_fat(()(+) integer(5)                  comment(; 5 seconds)
                    operator_fat(()(*) integer(17) integer(60)operator_fat(\))          comment(; 17 minutes)
                    operator_fat(()(*) integer(2) integer(60) integer(60)operator_fat(\))        comment(; 2 hours)
                    operator_fat(()(*) integer(55) integer(60) integer(60) integer(24)operator_fat(\))operator_fat(\))operator_fat(\))  comment(; and 55 days)
operator_fat(()reserved(define) (then) operator_fat(()(+) (birthtime) (interval)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Then is ~A)content(\\n)delimiter(")> operator_fat(()(strftime) string<delimiter(")content(%a %b %d %T %Y)delimiter(")> operator_fat(()(localtime) (then)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.5)
comment(;; subtract the epoch seconds:)
operator_fat(()reserved(define) (bree) integer(361535725)operator_fat(\))
operator_fat(()reserved(define) (nat) integer(96201950)operator_fat(\))
operator_fat(()reserved(define) (difference) operator_fat(()(-) (bree) (nat)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(There were ~A seconds between Nat and Bree)content(\\n)delimiter(")> (difference)operator_fat(\))

comment(;; or use SRFI-19's time arithmetic procedures:)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (time1) operator_fat(()(make-time) (time-monotonic) (nano1) (sec1)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (time2) operator_fat(()(make-time) (time-monotonic) (nano2) (sec2)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (duration) operator_fat(()(time-difference) (time1) (time2)operator_fat(\))operator_fat(\))
operator_fat(()(time=?) operator_fat(()(subtract-duration) (time1) (duration)operator_fat(\)) (time2)operator_fat(\)) comment(; #t)
operator_fat(()(time=?) operator_fat(()(add-duration) (time2) (duration)operator_fat(\)) (time1)operator_fat(\))      comment(; #t)

comment(;; @@PLEAC@@_3.6)
comment(;; convert to a SRFI-19 date and use the accessors)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))
operator_fat(()(date-day) (date)operator_fat(\))
operator_fat(()(date-year-day) (date)operator_fat(\))
operator_fat(()(date-week-day) (date)operator_fat(\))
operator_fat(()(date-week-number) (date) (start-day-of-week)operator_fat(\))

comment(;; @@PLEAC@@_3.7)
comment(;; use the strptime function:)
operator_fat(()reserved(define) (time-pair) operator_fat(()(strptime) string<delimiter(")content(%Y-%m-%d)delimiter(")> string<delimiter(")content(1998-06-03)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Time is ~A)content(\\n)content(.)delimiter(")> operator_fat(()(strftime) string<delimiter(")content(%b %d, %Y)delimiter(")> operator_fat(()(car) (time-pair)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or use SRFI-19's string->date:)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (date) operator_fat(()(string->date) string<delimiter(")content(1998-06-03)delimiter(")> string<delimiter(")content(~Y-~m-~d)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Time is ~A.)content(\\n)delimiter(")> operator_fat(()(date->string) (date)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.8)
comment(;; use the already seen strftime:)
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(strftime gives: ~A)content(\\n)delimiter(")>
        operator_fat(()(strftime) string<delimiter(")content(%A %D)delimiter(")> operator_fat(()(localtime) operator_fat(()(current-time)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or SRFI-19's date->string:)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-19)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(default date->string gives: ~A)content(\\n)delimiter(")> operator_fat(()(date->string) operator_fat(()(current-date)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(date->string gives: ~A)content(\\n)delimiter(")>
        operator_fat(()(date->string) operator_fat(()(current-date)operator_fat(\)) string<delimiter(")content(~a ~b ~e ~H:~M:~S ~z ~Y)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_3.9)
comment(;; gettimeofday will return seconds and microseconds:)
operator_fat(()reserved(define) (t0) operator_fat(()(gettimeofday)operator_fat(\))operator_fat(\))
comment(;; do your work here)
operator_fat(()reserved(define) (t1) operator_fat(()(gettimeofday)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(You took ~A seconds and ~A microseconds)content(\\n)delimiter(")>
        operator_fat(()(-) operator_fat(()(car) (t1)operator_fat(\)) operator_fat(()(car) (t0)operator_fat(\))operator_fat(\)) operator_fat(()(-) operator_fat(()(cdr) (t1)operator_fat(\)) operator_fat(()(cdr) (t0)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; you can also get more detailed info about the real and processor)
comment(;; times:)
operator_fat(()reserved(define) (runtime) operator_fat(()(times)operator_fat(\))operator_fat(\))
operator_fat(()(tms:clock) (runtime)operator_fat(\))  comment(; the current real time)
operator_fat(()(tms:utime) (runtime)operator_fat(\))  comment(; the CPU time units used by the calling process)
operator_fat(()(tms:stime) (runtime)operator_fat(\))  comment(; the CPU time units used by the system on behalf)
                     comment(; of the calling process.)
operator_fat(()(tms:cutime) (runtime)operator_fat(\)) comment(; the CPU time units used by terminated child)
                     comment(; processes of the calling process, whose status)
                     comment(; has been collected (e.g., using `waitpid'\).)
operator_fat(()(tms:cstime) (runtime)operator_fat(\)) comment(; the CPU times units used by the system on)
		     comment(; behalf of terminated child processes)

comment(;; you can also use the time module to time execution:)
operator_fat(()(use-modules) operator_fat(()(ice-9) (time)operator_fat(\))operator_fat(\))
operator_fat(()(time) operator_fat(()(sleep) integer(3)operator_fat(\))operator_fat(\))
comment(;; clock utime stime cutime cstime gctime)
comment(;; 3.01  0.00  0.00   0.00   0.00   0.00)
comment(;; 0)

comment(;; @@PLEAC@@_3.10)
operator_fat(()(sleep) (i)operator_fat(\))   comment(; sleep for i seconds)
operator_fat(()(usleep) (i)operator_fat(\))  comment(; sleep for i microseconds (not available on all platforms\))

comment(;; @@PLEAC@@_4.0)
operator_fat(()reserved(define) (nested) operator_fat(')operator_fat(()string<delimiter(")content(this)delimiter(")> string<delimiter(")content(that)delimiter(")> string<delimiter(")content(the)delimiter(")> string<delimiter(")content(other)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (nested) operator_fat(')operator_fat(()string<delimiter(")content(this)delimiter(")> string<delimiter(")content(that)delimiter(")> operator_fat(()string<delimiter(")content(the)delimiter(")> string<delimiter(")content(other)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (tune) operator_fat(')operator_fat(()string<delimiter(")content(The)delimiter(")> string<delimiter(")content(Star-Spangled)delimiter(")> string<delimiter(")content(Banner)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.1)
operator_fat(()reserved(define) (a) operator_fat(')operator_fat(()string<delimiter(")content(quick)delimiter(")> string<delimiter(")content(brown)delimiter(")> string<delimiter(")content(fox)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (a) operator_fat(')operator_fat(()string<delimiter(")content(Why)delimiter(")> string<delimiter(")content(are)delimiter(")> string<delimiter(")content(you)delimiter(")> string<delimiter(")content(teasing)delimiter(")> string<delimiter(")content(me?)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (lines)
  operator_fat(()(map) (string-trim)
       operator_fat(()(string-tokenize) string<delimiter(")content(\\)content(
    The boy stood on the burning deck,
    It was as hot as glass.)delimiter(")>
			char(#\\newline)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (bigarray)
  operator_fat(()(with-input-from-file) string<delimiter(")content(mydatafile)delimiter(")>
    operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
      operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(lines) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
		 operator_fat(()(next-line) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
	operator_fat(()reserved(if) operator_fat(()(eof-object?) (next-line)operator_fat(\))
	    operator_fat(()(reverse) (lines)operator_fat(\))
	    operator_fat(()(loop) operator_fat(()reserved(cons) (next-line) (lines)operator_fat(\))
		  operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (banner) string<delimiter(")content(The Mines of Moria)delimiter(")>operator_fat(\))

operator_fat(()reserved(define) (name) string<delimiter(")content(Gandalf)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (banner)
  operator_fat(()(string-append) string<delimiter(")content(Speak, )delimiter(")> (name) string<delimiter(")content(, and enter!)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (banner)
  operator_fat(()(format) pre_constant(#f) string<delimiter(")content(Speak, ~A, and welcome!)delimiter(")> (name)operator_fat(\))operator_fat(\))

comment(;; Advanced shell-like function is provided by guile-scsh, the Guile)
comment(;; port of SCSH, the Scheme shell.  Here we roll our own using the)
comment(;; pipe primitives that come with core Guile.)
operator_fat(()(use-modules) operator_fat(()(ice-9) (popen)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(drain-output) (port)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(chars) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
             operator_fat(()(next) operator_fat(()(read-char) (port)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(eof-object?) (next)operator_fat(\))
        operator_fat(()(list->string) operator_fat(()(reverse!) (chars)operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()reserved(cons) (next) (chars)operator_fat(\))
              operator_fat(()(read-char) (port)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(qx) (pipeline)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(pipe) operator_fat(()(open-input-pipe) (pipeline)operator_fat(\))operator_fat(\))
         operator_fat(()(output) operator_fat(()(drain-output) (pipe)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(close-pipe) (pipe)operator_fat(\))
    (output)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (his-host) string<delimiter(")content(www.perl.com)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (host-info) operator_fat(()(qx) operator_fat(()(format) pre_constant(#f) string<delimiter(")content(nslookup ~A)delimiter(")> (his-host)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (perl-info) operator_fat(()(qx) operator_fat(()(format) pre_constant(#f) string<delimiter(")content(ps ~A)delimiter(")> operator_fat(()(getpid)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (shell-info) operator_fat(()(qx) string<delimiter(")content(ps $$)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (banner) operator_fat(')operator_fat(()string<delimiter(")content(Costs)delimiter(")> string<delimiter(")content(only)delimiter(")> string<delimiter(")content($4.95)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (brax)    operator_fat(()(map) (string) operator_fat(()(string->list) string<delimiter(")content((\)<>{}[])delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (rings)   operator_fat(()(string-tokenize) string<delimiter(")content(Nenya Narya Vilya)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (tags)    operator_fat(()(string-tokenize) string<delimiter(")content(LI TABLE TR TD A IMG H1 P)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (sample)
  operator_fat(()(string-tokenize) string<delimiter(")content(The vertical bar (|\) looks and behaves like a pipe.)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (ships)  operator_fat(')operator_fat(()string<delimiter(")content(Niña)delimiter(")> string<delimiter(")content(Pinta)delimiter(")> string<delimiter(")content(Santa María)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.2)
operator_fat(()reserved(define) (array) operator_fat(')operator_fat(()string<delimiter(")content(red)delimiter(")> string<delimiter(")content(yellow)delimiter(")> string<delimiter(")content(green)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(begin)
  operator_fat(()(display) string<delimiter(")content(I have )delimiter(")>operator_fat(\))
  operator_fat(()(for-each) (display) (array)operator_fat(\))
  operator_fat(()(display) string<delimiter(")content( marbles.)content(\\n)delimiter(")>operator_fat(\))operator_fat(\))
comment(;; I have redyellowgreen marbles.)

operator_fat(()reserved(begin)
  operator_fat(()(display) string<delimiter(")content(I have )delimiter(")>operator_fat(\))
  operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(colour)operator_fat(\))
	      operator_fat(()(display) (colour)operator_fat(\))
	      operator_fat(()(display) string<delimiter(")content( )delimiter(")>operator_fat(\))operator_fat(\))
	    (array)operator_fat(\))
  operator_fat(()(display) string<delimiter(")content(marbles.)content(\\n)delimiter(")>operator_fat(\))operator_fat(\))
comment(;; I have red yellow green marbles.)

comment(;; commify - insertion of commas into list output)
operator_fat(()reserved(define) operator_fat(()(commify) (strings)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(len) operator_fat(()(length) (strings)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(case) (len)
      operator_fat(()operator_fat(()integer(0)operator_fat(\)) string<delimiter(")delimiter(")>operator_fat(\))
      operator_fat(()operator_fat(()integer(1)operator_fat(\)) operator_fat(()(car) (strings)operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()integer(2)operator_fat(\)) operator_fat(()(string-append) operator_fat(()(car) (strings)operator_fat(\)) string<delimiter(")content( and )delimiter(")> operator_fat(()(cadr) (strings)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()integer(3)operator_fat(\)) operator_fat(()(string-append) operator_fat(()(car) (strings)operator_fat(\)) string<delimiter(")content(, )delimiter(")>
                          operator_fat(()(cadr) (strings)operator_fat(\)) string<delimiter(")content(, and )delimiter(")>
                          operator_fat(()(caddr) (strings)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(else)
       operator_fat(()(string-append) operator_fat(()(car) (strings)operator_fat(\)) string<delimiter(")content(, )delimiter(")>
                      operator_fat(()(commify) operator_fat(()(cdr) (strings)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (lists) operator_fat(')operator_fat(()operator_fat(()string<delimiter(")content(just one thing)delimiter(")>operator_fat(\))
                operator_fat(()string<delimiter(")content(Mutt)delimiter(")> string<delimiter(")content(Jeff)delimiter(")>operator_fat(\))
                operator_fat(()string<delimiter(")content(Peter)delimiter(")> string<delimiter(")content(Paul)delimiter(")> string<delimiter(")content(Mary)delimiter(")>operator_fat(\))
                operator_fat(()string<delimiter(")content(To our parents)delimiter(")> string<delimiter(")content(Mother Theresa)delimiter(")> string<delimiter(")content(God)delimiter(")>operator_fat(\))
                operator_fat(()string<delimiter(")content(pastrami)delimiter(")> string<delimiter(")content(ham and cheese)delimiter(")> string<delimiter(")content(peanut butter and jelly)delimiter(")> string<delimiter(")content(tuna)delimiter(")>operator_fat(\))
                operator_fat(()string<delimiter(")content(recycle tired, old phrases)delimiter(")> string<delimiter(")content(ponder big, happy thoughts)delimiter(")>operator_fat(\))
                operator_fat(()string<delimiter(")content(recycle tired, old phrases)delimiter(")>
                 string<delimiter(")content(ponder big, happy thoughts)delimiter(")>
                 string<delimiter(")content(sleep and dream peacefully)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(list)operator_fat(\))
            operator_fat(()(display) string<delimiter(")content(The list is: )delimiter(")>operator_fat(\))
            operator_fat(()(display) operator_fat(()(commify) (list)operator_fat(\))operator_fat(\))
            operator_fat(()(display) string<delimiter(")content(.)content(\\n)delimiter(")>operator_fat(\))operator_fat(\))
          (lists)operator_fat(\))

comment(;; The list is: just one thing.)
comment(;; The list is: Mutt and Jeff.)
comment(;; The list is: Peter, Paul, and Mary.)
comment(;; The list is: To our parents, Mother Theresa, and God.)
comment(;; The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.)
comment(;; The list is: recycle tired, old phrases and ponder big, happy thoughts.)
comment(;; The list is: recycle tired, old phrases, ponder big, happy thoughts, and sleep and dream peacefully.)

comment(;; @@PLEAC@@_4.3)
comment(;;-----------------------------)

comment(;; Scheme does not normally grow and shrink arrays in the way that)
comment(;; Perl can.  The more usual operations are adding and removing from)
comment(;; the head of a list using the `cons' and `cdr' procedures.)
comment(;; However ...)
operator_fat(()reserved(define) operator_fat(()(grow/shrink) (list) (new-size)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(size) operator_fat(()(length) (list)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(<) (size) (new-size)operator_fat(\))
           operator_fat(()(grow/shrink) operator_fat(()reserved(cons) string<delimiter(")delimiter(")> (list)operator_fat(\)) (new-size)operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(>) (size) (new-size)operator_fat(\))
           operator_fat(()(grow/shrink) operator_fat(()(cdr) (list)operator_fat(\)) (new-size)operator_fat(\))operator_fat(\))
          operator_fat(()(else) (list)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(element) (list) (i)operator_fat(\))
  operator_fat(()(list-ref) (list) operator_fat(()(-) operator_fat(()(length) (list)operator_fat(\)) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(set-element) (list) (i) (value)operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(>=) (i) operator_fat(()(length) (list)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (list) operator_fat(()(grow/shrink) (list) operator_fat(()(-) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(set-car!) operator_fat(()(list-cdr-ref) (list) operator_fat(()(-) operator_fat(()(length) (list)operator_fat(\)) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
  (list)operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(what-about) (list)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(len) operator_fat(()(length) (list)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(format) pre_constant(#t) string<delimiter(")content(The array now has ~A elements.)content(\\n)delimiter(")> (len)operator_fat(\))
    operator_fat(()(format) pre_constant(#t) string<delimiter(")content(The index of the last element is ~A.)content(\\n)delimiter(")> operator_fat(()(-) (len) integer(1)operator_fat(\))operator_fat(\))
    operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Element #3 is `~A'.)content(\\n)delimiter(")> operator_fat(()reserved(if) operator_fat(()(>) (len) integer(3)operator_fat(\))
                                           operator_fat(()(element) (list) integer(3)operator_fat(\))
                                           string<delimiter(")delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; In the emulation of Perl arrays implemented here, the elements are)
comment(;; in reverse order when compared to normal Scheme lists.)
operator_fat(()reserved(define) (people) operator_fat(()(reverse) operator_fat(')operator_fat(()string<delimiter(")content(Crosby)delimiter(")> string<delimiter(")content(Stills)delimiter(")> string<delimiter(")content(Nash)delimiter(")> string<delimiter(")content(Young)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(what-about) (people)operator_fat(\))
comment(;;-----------------------------)
comment(;; The array now has 4 elements.)
comment(;; The index of the last element is 3.)
comment(;; Element #3 is `Young'.)
comment(;;-----------------------------)
operator_fat(()reserved(set!) (people) operator_fat(()(grow/shrink) (people) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()(what-about) (people)operator_fat(\))
comment(;;-----------------------------)
comment(;; The array now has 3 elements.)
comment(;; The index of the last element is 2.)
comment(;; Element #3 is `'.)
comment(;;-----------------------------)
operator_fat(()reserved(set!) (people) operator_fat(()(grow/shrink) (people) integer(10001)operator_fat(\))operator_fat(\))
operator_fat(()(what-about) (people)operator_fat(\))
comment(;;-----------------------------)
comment(;; The array now has 10001 elements.)
comment(;; The index of the last element is 10000.)
comment(;; Element #3 is `'.)
comment(;;-----------------------------)

comment(;; @@PLEAC@@_4.4)
comment(; Using a 'list' i.e. chain of pairs)
operator_fat(()reserved(define) (*mylist*) operator_fat(')operator_fat(()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

comment(; Apply procedure to each member of 'mylist')
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\)) operator_fat(()(print) (item)operator_fat(\))operator_fat(\))
  (*mylist*)operator_fat(\))

comment(;; ------------)

comment(; Using a 'vector' i.e. one-dimensional array)
operator_fat(()reserved(define) (*bad-users*) operator_fat(')operator_fat(#()string<delimiter(")content(lou)delimiter(")> string<delimiter(")content(mo)delimiter(")> string<delimiter(")content(sterling)delimiter(")> string<delimiter(")content(john)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(complain) (user)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(You're a *bad user*,)delimiter(")> (user)operator_fat(\))operator_fat(\))

operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user)operator_fat(\)) operator_fat(()(complain) (user)operator_fat(\))operator_fat(\))
  (*bad-users*)operator_fat(\))

comment(;; ------------)

comment(; Could probably get away with sorting a list of strings ...)
operator_fat(()reserved(define) (*sorted-environ*)
  operator_fat(()(sort) operator_fat(()(environ)operator_fat(\)) (string<?)operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(var)operator_fat(\)) operator_fat(()(display) (var)operator_fat(\)) operator_fat(()(newline)operator_fat(\))operator_fat(\))
  (*sorted-environ*)operator_fat(\))

comment(;; ----)

comment(; ... but the intent here is to sort a hash table, so we'll use)
comment(; an 'assoc', Scheme's native dictionary type, which is really)
comment(; nothing more than a list of conses / dotted pairs [hash tables)
comment(; will be used in later examples])
operator_fat(()reserved(define) operator_fat(()(cons->env-string) (a)operator_fat(\))
  operator_fat(()(string-append) operator_fat(()(car) (a)operator_fat(\)) string<delimiter(")content(=)delimiter(")> operator_fat(()(cdr) (a)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(env-string->cons) (s)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(key-value) operator_fat(()(string-split) (s) char(#\\=)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(()(car) (key-value)operator_fat(\)) operator_fat(()(cadr) (key-value)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*sorted-environ-assoc*)
  operator_fat(()(sort)
    operator_fat(()(map)
      operator_fat(()reserved(lambda) operator_fat(()(var)operator_fat(\)) operator_fat(()(env-string->cons) (var)operator_fat(\))operator_fat(\))
      operator_fat(()(environ)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\)) operator_fat(()(string<?) operator_fat(()(car) (left)operator_fat(\)) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(var)operator_fat(\))
    operator_fat(()(print) operator_fat(()(car) (var)operator_fat(\)) string<delimiter(")content(=)delimiter(")> operator_fat(()(cdr) (var)operator_fat(\))operator_fat(\))operator_fat(\))
  (*sorted-environ-assoc*)operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*MAX-QUOTA*) integer(100)operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(get-all-users)operator_fat(\)) (...)operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(get-usage) (user)operator_fat(\)) (...)operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(complain) (user)operator_fat(\)) (...)operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(disk-usage) operator_fat(()(get-usage) (user)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(>) (disk-usage) (*MAX-QUOTA*)operator_fat(\))
        operator_fat(()(complain) (user)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(get-all-users)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user)operator_fat(\)) operator_fat(()reserved(if) operator_fat(()(string=?) (user) string<delimiter(")content(tchrist)delimiter(")>operator_fat(\)) operator_fat(()(print) (user)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(string-split) operator_fat(()(qx) string<delimiter(")content(who|cut -d' ' -f1|uniq)delimiter(")>operator_fat(\)) char(#\\newline)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(srfi) (srfi-14)operator_fat(\))operator_fat(\))

operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
  operator_fat(()(for-each)
    operator_fat(()reserved(lambda) operator_fat(()(word)operator_fat(\)) operator_fat(()(print) operator_fat(()(string-reverse) (word)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(string-tokenize) (line) (char-set:graphic)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; Updates vector in-place [accepts variable number of vectors])
comment(; See also the library function, 'array-map-in-order!' and its)
comment(; brethren)
operator_fat(()reserved(define) operator_fat(()(vector-map-in-order!) (proc) (vec) operator(.) (rest)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(all-vec) operator_fat(()reserved(cons) (vec) (rest)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(vec)operator_fat(\))
        operator_fat(()reserved(let) operator_fat(()operator_fat(()(end) operator_fat(()(vector-length) (vec)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(idx) integer(0)operator_fat(\))operator_fat(\))
            operator_fat(()reserved(cond)
              operator_fat(()operator_fat(()(=) (idx) (end)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
              operator_fat(()(else)
                operator_fat(()(vector-set!) (vec) (idx) operator_fat(()(apply) (proc) operator_fat(()(list) operator_fat(()(vector-ref) (vec) (idx)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
                operator_fat(()(loop) operator_fat(()(+) (idx) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
      (all-vec)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; A non-mutating version - illustration only, as library routines)
comment(; [SRFI-43 and built-ins] should be preferred)
operator_fat(()reserved(define) operator_fat(()(vector-map-in-order) (proc) (vec) operator(.) (rest)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(all-vec) operator_fat(()reserved(cons) (vec) (rest)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec-len) operator_fat(()(reduce) (+) integer(0) operator_fat(()(map) (vector-length) (all-vec)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec) operator_fat(()(make-vector) (new-vec-len)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec-idx) integer(0)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(all-vec) (all-vec)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(cond)
        operator_fat(()operator_fat(()(=) (new-vec-idx) (new-vec-len)operator_fat(\)) (new-vec)operator_fat(\))
        operator_fat(()(else)
          operator_fat(()(array-for-each)
            operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\))
              operator_fat(()(vector-set!) (new-vec) (new-vec-idx) operator_fat(()(apply) (proc) operator_fat(()(list) (element)operator_fat(\))operator_fat(\))operator_fat(\))
              operator_fat(()reserved(set!) (new-vec-idx) operator_fat(()(+) (new-vec-idx) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()(car) (all-vec)operator_fat(\))operator_fat(\))
          operator_fat(()(loop) operator_fat(()(cdr) (all-vec)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()(print) string<delimiter(")content(i =)delimiter(")> (item)operator_fat(\))operator_fat(\))
  (*array*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()(print) string<delimiter(")content(i =)delimiter(")> (item)operator_fat(\))operator_fat(\))
  (*array*)operator_fat(\))

comment(; Since a 'vector' is mutable, in-place updates allowed)
operator_fat(()(vector-map-in-order!)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\)) operator_fat(()(-) (item) integer(1)operator_fat(\))operator_fat(\))
  (*array*)operator_fat(\))

operator_fat(()(print) (*array*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*a*) operator_fat(')operator_fat(#()integer(0.5) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*b*) operator_fat(')operator_fat(#()integer(0) integer(1)operator_fat(\))operator_fat(\))

operator_fat(()(vector-map-in-order!)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\)) operator_fat(()(*) (item) integer(7)operator_fat(\))operator_fat(\))
  (*a*) (*b*)operator_fat(\))

operator_fat(()(print) (*a*) (*b*)operator_fat(\))

comment(;; ----------------------------)

comment(; Using 'for-each' to iterate over several container items is a)
comment(; simple matter of passing a list of those items e.g. a list of)
comment(; strings, or of arrays etc.)
comment(;)
comment(; However, complications arise when:)
comment(; * Heterogenous list of items e.g. list contains all of arrays,)
comment(;   hashes, strings, etc. Necesitates different handling based on type)
comment(; * Item needs updating. It is not possible to alter the item reference)
comment(;   and updating an item's internals is only possible if the relevant)
comment(;   mutating procedures are implemented e.g. specified string characters)
comment(;   may be altered in-place, but character deletion requires a new be)
comment(;   created [i.e. altering the item reference], so is not possible)

operator_fat(()reserved(define) (*scalar*) string<delimiter(")content(123 )delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()string<delimiter(")content( 123 )delimiter(")> string<delimiter(")content(456 )delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*hash*) operator_fat(()(list) operator_fat(()reserved(cons) string<delimiter(")content(key1)delimiter(")> string<delimiter(")content(123 )delimiter(")>operator_fat(\)) operator_fat(()reserved(cons) string<delimiter(")content(key2)delimiter(")> string<delimiter(")content( 456)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Illustrates iteration / handling of heterogenous types)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(string?) (item)operator_fat(\)) operator_fat(()(do-stuff-with-string) (item)operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(vector?) (item)operator_fat(\)) operator_fat(()(do-stuff-with-vector) (item)operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(pair?) (item)operator_fat(\)) operator_fat(()(do-stuff-with-hash) (item)operator_fat(\))operator_fat(\))
      operator_fat(()(else) operator_fat(()(print) string<delimiter(")content(unknown type)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(list) (*scalar*) (*array*) (*hash*)operator_fat(\))operator_fat(\))

comment(; So, for item-replacement-based updating you need to use explicit)
comment(; iteration e.g. 'do' loop, or recursion [as is done in the code for)
comment(; 'vector-map-in-order!'] - examples in next section. Or, you could)
comment(; create a new 'for-each' type control structure using Scheme's)
comment(; macro facility [example not shown])

comment(;; @@PLEAC@@_4.5)
operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; Whilst a 'vector' is mutable, 'array-for-each' passes only a copy)
comment(; of each cell, thus there is no way to perform updates)
operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    (...) reserved(do) (some) (non-array-mutating) (task) (with) operator_fat(')(item)operator_fat(')(...)operator_fat(\))
  (*array*)operator_fat(\))

comment(;; ------------)

comment(; For mutating operations, use one of the mutating 'array-map-...' routines)
comment(; or the custom, 'vector-map-in-order!')
operator_fat(()(vector-map-in-order!)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    (...) reserved(do) (some) (array-mutating) (task) (with) operator_fat(')(item)operator_fat(')(...)operator_fat(\))
  (*array*)operator_fat(\))

comment(;; ------------)

comment(; Alternatively, use 'do' to iterate over the array and directly update )
operator_fat(()reserved(let) operator_fat(()operator_fat(()(vector-length) operator_fat(()(vector-length) (*array*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()(+) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(=) (i) (vector-length)operator_fat(\))operator_fat(\))
    (...) reserved(do) (some) (array-mutating) (task) (with) (current) (array) (element) (...)operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; Alternatively, use a 'named let' to iterate over array and directly update )
operator_fat(()reserved(let) operator_fat(()operator_fat(()(vector-length) operator_fat(()(vector-length) (*array*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) integer(0)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(=) (i) (vector-length)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
      operator_fat(()(else)
        (...) reserved(do) (some) (array-mutating) (task) (with) (current) (array) (element) (...)
        operator_fat(()(loop) operator_fat(()(+) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*fruits*) operator_fat(')operator_fat(#()string<delimiter(")content(Apple)delimiter(")> string<delimiter(")content(Blackberry)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(fruit)operator_fat(\))
    operator_fat(()(print) (fruit) string<delimiter(")content(tastes good in a pie.)delimiter(")>operator_fat(\))operator_fat(\))
  (*fruits*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(let) operator_fat(()operator_fat(()(vector-length) operator_fat(()(vector-length) (*fruits*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()(+) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(=) (i) (vector-length)operator_fat(\))operator_fat(\))
    operator_fat(()(print) operator_fat(()(vector-ref) (*fruits*) (i)operator_fat(\)) string<delimiter(")content(tastes good in a pie.)delimiter(")>operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*rogue-cats*) operator_fat(')operator_fat(()string<delimiter(")content(Blacky)delimiter(")> string<delimiter(")content(Ginger)delimiter(")> string<delimiter(")content(Puss)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*name-list*) operator_fat(()(acons) operator_fat(')(felines) (*rogue-cats*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(cat)operator_fat(\))
    operator_fat(()(print) (cat) string<delimiter(")content(purrs hypnotically..)delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()(cdr) operator_fat(()(assoc) operator_fat(')(felines) (*name-list*)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(felines) operator_fat(()(cdr) operator_fat(()(assoc) operator_fat(')(felines) (*name-list*)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond)
    operator_fat(()operator_fat(()(null?) (felines)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
    operator_fat(()(else)
      operator_fat(()(print) operator_fat(()(car) (felines)operator_fat(\)) string<delimiter(")content(purrs hypnotically..)delimiter(")>operator_fat(\))
      operator_fat(()(loop) operator_fat(()(cdr) (felines)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.6)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

comment(; Simplest [read: least code] means of removing duplicates is to use )
comment(; SRFI-1's 'delete-duplicates' routine)

operator_fat(()reserved(define) (*non-uniq-num-list*) operator_fat(')operator_fat(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*uniq*) operator_fat(()(delete-duplicates) (*my-non-uniq-num-list*)operator_fat(\))

comment(;; ------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

comment(; Another simple alternative is to use SRFI-1's 'lset-union' routine. In)
comment(; general, the 'lset-...' routines:)
comment(; - convenient, but not fast; probably best avoided for 'large' sets)
comment(; - operate on standard lists, so simple matter of type-converting arrays and such)
comment(; - care needs to be taken in choosing the needed equality function)

operator_fat(()reserved(define) (*non-uniq-string-list*) operator_fat(')operator_fat(()string<delimiter(")content(abc)delimiter(")> string<delimiter(")content(def)delimiter(")> string<delimiter(")content(ghi)delimiter(")> string<delimiter(")content(abc)delimiter(")> string<delimiter(")content(def)delimiter(")> string<delimiter(")content(ghi)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*uniq*) operator_fat(()(lset-union) (string=?) (*non-uniq-string-list*) (*non-uniq-string-list*)operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*non-uniq-sym-list*) operator_fat(')operator_fat(()operator_fat(')(a) operator_fat(')(b) operator_fat(')(c) operator_fat(')(a) operator_fat(')(b) operator_fat(')(c)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*uniq*) operator_fat(()(lset-union) (equal?) (*my-non-uniq-sym-list*) (*my-non-uniq-sym-list*)operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*non-uniq-num-list*) operator_fat(')operator_fat(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*uniq*) operator_fat(()(lset-union) (=) (*my-non-uniq-num-list*) (*my-non-uniq-num-list*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(;; Perl Cookbook-based examples - illustrative only, *not* recommended approaches)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*list*) operator_fat(')operator_fat(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(7) integer(8) integer(1) integer(8) integer(2) integer(1) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*seen*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(; Use hash to filter out unique items)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(assoc-ref) (*seen*) (item)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*seen*) operator_fat(()(assoc-set!) (*seen*) (item) pre_constant(#t)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*list*)operator_fat(\))

comment(; Generate list of unique items)
operator_fat(()reserved(define) (*uniq*)
  operator_fat(()(fold-right)
    operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
    operator_fat(')operator_fat(()operator_fat(\))
    (*seen*)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*list*) operator_fat(')operator_fat(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(7) integer(8) integer(1) integer(8) integer(2) integer(1) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*seen*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(; Build list of unique items by checking set membership)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(member) (item) (*seen*)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*seen*) operator_fat(()reserved(cons) (item) (*seen*)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*list*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*users*)
  operator_fat(()(sort)
    operator_fat(()(string-split) operator_fat(()(qx) string<delimiter(")content(who|cut -d' ' -f1)delimiter(")>operator_fat(\)) char(#\\newline)operator_fat(\))
    (string<?)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*seen*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(; Build list of unique users by checking set membership)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(member) (user) (*seen*)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*seen*) operator_fat(()reserved(cons) (item) (*seen*)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*list*)operator_fat(\))

comment(;; @@PLEAC@@_4.7)
comment(; All problems in this section involve, at core, set difference)
comment(; operations. Thus, the most compact and straightforward approach is)
comment(; to utilise SRFI-1's 'lset-difference' routine)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*a*) operator_fat(')operator_fat(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*b*) operator_fat(')operator_fat(()integer(2) integer(3) integer(5) integer(7) integer(9)operator_fat(\))operator_fat(\))

comment(; *difference* contains elements in *a* but not in *b*: 1 6 8)
operator_fat(()reserved(define) (*difference*) operator_fat(()(lset-difference) (=) (*a*) (*b*)operator_fat(\))operator_fat(\))

comment(; *difference* contains elements in *b* but not in *a*: 2 9)
operator_fat(()reserved(set!) (*difference*) operator_fat(()(lset-difference) (=) (*b*) (*a*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(;; Perl Cookbook-based example - illustrative only, *not* recommended approaches)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*a*) operator_fat(')operator_fat(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*b*) operator_fat(')operator_fat(()integer(2) integer(3) integer(5) integer(7) integer(9)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*a-only*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(; Build list of items in *a* but not in *b*)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(member) (item) (*b*)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*a-only*) operator_fat(()reserved(cons) (item) (*a-only*)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*a*)operator_fat(\))

comment(;; @@PLEAC@@_4.8)
comment(; The SRFI-1 'lset-xxx' routines are appropriate here)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*a*) operator_fat(')operator_fat(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*b*) operator_fat(')operator_fat(()integer(2) integer(3) integer(5) integer(7) integer(9)operator_fat(\))operator_fat(\))

comment(; Combined elements of *a* and *b* sans duplicates: 1 2 3 5 6 7 8 9)
operator_fat(()reserved(define) (*union*) operator_fat(()(lset-union) (=) (*a*) (*b*)operator_fat(\))operator_fat(\))

comment(; Elements common to both *a* and *b*: 3 5 7)
operator_fat(()reserved(define) (*intersection*) operator_fat(()(lset-intersection) (=) (*a*) (*b*)operator_fat(\))operator_fat(\))

comment(; Elements in *a* but not in *b*: 1 6 8)
operator_fat(()reserved(define) (*difference*) operator_fat(()(lset-difference) (=) (*a*) (*b*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(;; Perl Cookbook-based example - illustrative only, *not* recommended approaches)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*a*) operator_fat(')operator_fat(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*b*) operator_fat(')operator_fat(()integer(2) integer(3) integer(5) integer(7) integer(9)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*union*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*isect*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*diff*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; Union and intersection)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\)) operator_fat(()reserved(set!) (*union*) operator_fat(()(assoc-set!) (*union*) (item) pre_constant(#t)operator_fat(\))operator_fat(\))operator_fat(\))
  (*a*)operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(assoc-ref) (*union*) (item)operator_fat(\))
      operator_fat(()reserved(set!) (*isect*) operator_fat(()(assoc-set!) (*isect*) (item) pre_constant(#t)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(set!) (*union*) operator_fat(()(assoc-set!) (*union*) (item) pre_constant(#t)operator_fat(\))operator_fat(\))operator_fat(\))
  (*b*)operator_fat(\))

comment(; Difference *a* and *b*)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(item)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(assoc-ref) (*isect*) (item)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*diff*) operator_fat(()(assoc-set!) (*diff*) (item) pre_constant(#t)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*a*)operator_fat(\))

operator_fat(()reserved(set!) (*union*)
  operator_fat(()(fold)
    operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
    operator_fat(')operator_fat(()operator_fat(\))
    (*union*)operator_fat(\))operator_fat(\))

operator_fat(()reserved(set!) (*isect*)
  operator_fat(()(fold)
    operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
    operator_fat(')operator_fat(()operator_fat(\))
    (*isect*)operator_fat(\))operator_fat(\))

operator_fat(()reserved(set!) (*diff*)
  operator_fat(()(fold)
    operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
    operator_fat(')operator_fat(()operator_fat(\))
    (*diff*)operator_fat(\))operator_fat(\))

operator_fat(()(print) string<delimiter(")content(Union count:       )delimiter(")> operator_fat(()(length) (*union*)operator_fat(\))operator_fat(\))
operator_fat(()(print) string<delimiter(")content(Intersection count:)delimiter(")> operator_fat(()(length) (*isect*)operator_fat(\))operator_fat(\))
operator_fat(()(print) string<delimiter(")content(Difference count:  )delimiter(")> operator_fat(()(length) (*diff*)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.9)
comment(; Arrays, specifically vectors in the current context, are fixed-size)
comment(; entities; joining several such together requires copying of their)
comment(; contents into a new, appropriately-sized, array. This task may be)
comment(; performed:)

comment(; * Directly: loop through existing arrays copying elements into a)
comment(;   newly-created array)

operator_fat(()reserved(define) operator_fat(()(vector-join) (vec) operator(.) (rest)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(all-vec) operator_fat(()reserved(cons) (vec) (rest)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec-len) operator_fat(()(reduce) (+) integer(0) operator_fat(()(map) (vector-length) (all-vec)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec) operator_fat(()(make-vector) (new-vec-len)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec-idx) integer(0)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(all-vec) (all-vec)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(cond)
        operator_fat(()operator_fat(()(=) (new-vec-idx) (new-vec-len)operator_fat(\)) (new-vec)operator_fat(\))
        operator_fat(()(else)
          operator_fat(()(array-for-each)
            operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\))
              operator_fat(()(vector-set!) (new-vec) (new-vec-idx) (element)operator_fat(\))
              operator_fat(()reserved(set!) (new-vec-idx) operator_fat(()(+) (new-vec-idx) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()(car) (all-vec)operator_fat(\))operator_fat(\))
          operator_fat(()(loop) operator_fat(()(cdr) (all-vec)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*array1*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*array2*) operator_fat(')operator_fat(#()integer(4) integer(5) integer(6)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*newarray*)
  operator_fat(()(vector-join) (*array1*) (*array2*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; * Indirectly; convert arrays to lists, append the lists, convert)
comment(;   resulting list back into an array)

operator_fat(()reserved(define) (*array1*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*array2*) operator_fat(')operator_fat(#()integer(4) integer(5) integer(6)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*newarray*)
  operator_fat(()(list->vector) operator_fat(()(append) operator_fat(()(vector->list) (*array1*)operator_fat(\)) operator_fat(()(vector->list) (*array2*)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(; Of course if random access is not required, it is probably best to simply)
comment(; use lists since a wealth of list manipulation routines are available)

comment(;; ----------------------------)

comment(; While Perl offers an all-purpose 'splice' routine, a cleaner approach is)
comment(; to separate out such functionality; here three routines are implemented)
comment(; together offering an equivalent to 'splice'. The routines are:)
comment(; * vector-replace! [use with 'vector-copy' to avoid changing original])
comment(;   e.g. (vector-replace! vec ...\))
comment(;        (set! new-vec (vector-replace! (vector-copy vec\) ...\)\))
comment(; * vector-delete)
comment(; * vector-insert)

operator_fat(()reserved(define) operator_fat(()(vector-replace!) (vec) (pos) (item) operator(.) (rest)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(all-items) operator_fat(()reserved(cons) (item) (rest)operator_fat(\))operator_fat(\))
         operator_fat(()(pos) operator_fat(()reserved(if) operator_fat(()(<) (pos) integer(0)operator_fat(\)) operator_fat(()(+) operator_fat(()(vector-length) (vec)operator_fat(\)) (pos)operator_fat(\)) (pos)operator_fat(\))operator_fat(\))
         operator_fat(()(in-bounds)
           operator_fat(()(not) operator_fat(()(>) operator_fat(()(+) (pos) operator_fat(()(length) (all-items)operator_fat(\))operator_fat(\)) operator_fat(()(vector-length) (vec)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) (in-bounds)
      operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) (pos)operator_fat(\)) operator_fat(()(all-items) (all-items)operator_fat(\))operator_fat(\))
        operator_fat(()reserved(cond)
          operator_fat(()operator_fat(()(null?) (all-items)operator_fat(\)) (vec)operator_fat(\))
          operator_fat(()(else)
            operator_fat(()(vector-set!) (vec) (i) operator_fat(()(car) (all-items)operator_fat(\))operator_fat(\))
            operator_fat(()(loop) operator_fat(()(+) (i) integer(1)operator_fat(\)) operator_fat(()(cdr) (all-items)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))
    comment(;else)
      (vec)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(vector-delete) (vec) (pos) (len)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(new-vec-len) operator_fat(()(-) operator_fat(()(vector-length) (vec)operator_fat(\)) (len)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec) pre_constant(#f)operator_fat(\))
         operator_fat(()(pos) operator_fat(()reserved(if) operator_fat(()(<) (pos) integer(0)operator_fat(\)) operator_fat(()(+) operator_fat(()(vector-length) (vec)operator_fat(\)) (pos)operator_fat(\)) (pos)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(<) (new-vec-len) integer(0)operator_fat(\)) (vec)operator_fat(\))
      operator_fat(()(else)
        operator_fat(()reserved(set!) (new-vec) operator_fat(()(make-vector) (new-vec-len)operator_fat(\))operator_fat(\))
        operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(vec-idx) integer(0)operator_fat(\)) operator_fat(()(new-vec-idx) integer(0)operator_fat(\))operator_fat(\))
          operator_fat(()reserved(cond)
            operator_fat(()operator_fat(()(=) (new-vec-idx) (new-vec-len)operator_fat(\)) (new-vec)operator_fat(\))
            operator_fat(()(else)
              operator_fat(()reserved(if) operator_fat(()(=) (vec-idx) (pos)operator_fat(\)) operator_fat(()reserved(set!) (vec-idx) operator_fat(()(+) (vec-idx) (len)operator_fat(\))operator_fat(\))operator_fat(\))
              operator_fat(()(vector-set!) (new-vec) (new-vec-idx) operator_fat(()(vector-ref) (vec) (vec-idx)operator_fat(\))operator_fat(\))
              operator_fat(()(loop) operator_fat(()(+) (vec-idx) integer(1)operator_fat(\)) operator_fat(()(+) (new-vec-idx) integer(1)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(; This routine would probably benefit from having 'cmd' implemented as a keyword)
comment(; argument. However, 'cmd' implemented as a positional to keep example simple)
operator_fat(()reserved(define) operator_fat(()(vector-insert) (vec) (pos) (cmd) (item) operator(.) (rest)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(all-item-vec) operator_fat(()(list->array) integer(1) operator_fat(()reserved(cons) (item) (rest)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(all-item-vec-len) operator_fat(()(vector-length) (all-item-vec)operator_fat(\))operator_fat(\))
         operator_fat(()(vec-len) operator_fat(()(vector-length) (vec)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec) operator_fat(()(make-vector) operator_fat(()(+) (vec-len) (all-item-vec-len)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(pos) operator_fat(()reserved(if) operator_fat(()(<) (pos) integer(0)operator_fat(\)) operator_fat(()(+) operator_fat(()(vector-length) (vec)operator_fat(\)) (pos)operator_fat(\)) (pos)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(eq?) (cmd) operator_fat(')(after)operator_fat(\)) operator_fat(()reserved(set!) (pos) operator_fat(()(+) (pos) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(vector-move-left!) (vec) integer(0) (pos) (new-vec) integer(0)operator_fat(\))
    operator_fat(()(vector-move-left!) (all-item-vec) integer(0) (all-item-vec-len) (new-vec) (pos)operator_fat(\))
    operator_fat(()(vector-move-left!) (vec) (pos) (vec-len) (new-vec) operator_fat(()(+) (pos) (all-item-vec-len)operator_fat(\))operator_fat(\))
    (new-vec)operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*members*) operator_fat(')operator_fat(#()string<delimiter(")content(Time)delimiter(")> string<delimiter(")content(Flies)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*initiates*) operator_fat(')operator_fat(#()string<delimiter(")content(An)delimiter(")> string<delimiter(")content(Arrow)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(set!) (*members*) operator_fat(()(vector-join) (*members*) (*initiates*)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(set!) (*members*) operator_fat(()(vector-insert) (*members*) integer(1) operator_fat(')(after) string<delimiter(")content(Like)delimiter(")> (*initiates*)operator_fat(\))operator_fat(\))
operator_fat(()(print) (*members*)operator_fat(\))

operator_fat(()reserved(set!) (*members*) operator_fat(()(vector-replace) (*members*) integer(0) string<delimiter(")content(Fruit)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*members*) operator_fat(()(vector-replace) (*members*) (-)integer(2) string<delimiter(")content(A)delimiter(")> string<delimiter(")content(Banana)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()(print) (*members*)operator_fat(\))

comment(; was: '#("Time" "Flies" "An" "Arrow"\))
comment(; now: '#("Fruit" "Flies" "Like" "A" "Banana"\))

comment(;; @@PLEAC@@_4.10)
comment(; As for appending arrays, there is the choice of iterating through)
comment(; the array:)
operator_fat(()reserved(define) operator_fat(()(vector-reverse!) (vec)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) integer(0)operator_fat(\)) operator_fat(()(j) operator_fat(()(-) operator_fat(()(vector-length) (vec)operator_fat(\)) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(>=) (i) (j)operator_fat(\)) (vec)operator_fat(\))
      operator_fat(()(else)
        operator_fat(()(vector-ref-swap!) (vec) (i) (j)operator_fat(\))
        operator_fat(()(loop) operator_fat(()(+) (i) integer(1)operator_fat(\)) operator_fat(()(-) (j) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

operator_fat(()(vector-reverse!) (*array*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) operator_fat(()(-) operator_fat(()(vector-length) (*array*)operator_fat(\)) integer(1)operator_fat(\)) operator_fat(()(-) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(<) (i) integer(0)operator_fat(\))operator_fat(\))
  (...) reserved(do) (something) (with) (*array*) (...)operator_fat(\))

comment(;; ----------------------------)

comment(; or of converting to / from a list, performing any manipulation using)
comment(; the list routines)

operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*newarray*)
  operator_fat(()(list->vector) operator_fat(()(reverse) operator_fat(()(sort) operator_fat(()(vector->list) (*array*)operator_fat(\)) (<)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.11)
operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3) integer(4) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; Remove first 3 elements)
operator_fat(()reserved(define) (*front*) operator_fat(()(vector-delete) (*array*) integer(0) integer(3)operator_fat(\))operator_fat(\))

comment(; Remove last 3 elements)
operator_fat(()reserved(define) (*end*) operator_fat(()(vector-delete) (*array*) (-)integer(1) integer(3)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; Another helper routine)
operator_fat(()reserved(define) operator_fat(()(vector-slice) (vec) (pos) (len)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(vec-len) operator_fat(()(vector-length) (vec)operator_fat(\))operator_fat(\))
         operator_fat(()(pos) operator_fat(()reserved(if) operator_fat(()(<) (pos) integer(0)operator_fat(\)) operator_fat(()(+) (vec-len) (pos)operator_fat(\)) (pos)operator_fat(\))operator_fat(\))
         operator_fat(()(in-bounds)
           operator_fat(()(not) operator_fat(()(>) operator_fat(()(+) (pos) (len)operator_fat(\)) (vec-len)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) (in-bounds)
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(new-vec) operator_fat(()(make-vector) (len)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(vec-idx) (pos)operator_fat(\)) operator_fat(()(new-vec-idx) integer(0)operator_fat(\))operator_fat(\))
          operator_fat(()reserved(cond)
            operator_fat(()operator_fat(()(=) (new-vec-idx) (len)operator_fat(\)) (new-vec)operator_fat(\))
            operator_fat(()(else)
              operator_fat(()(vector-set!) (new-vec) (new-vec-idx) operator_fat(()(vector-ref) (vec) (vec-idx)operator_fat(\))operator_fat(\))
              operator_fat(()(loop) operator_fat(()(+) (vec-idx) integer(1)operator_fat(\)) operator_fat(()(+) (new-vec-idx) integer(1)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
    comment(;else)
      (vec)operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Both the following use, 'values', to return two values; this approach)
comment(; is quite contrived and is taken to mimic the Perl examples, not)
comment(; because it is a recommended one [returning a single list would probably)
comment(; be more sensible])
operator_fat(()reserved(define) operator_fat(()(shift2) (vec)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(vec) operator_fat(()(vector-slice) (vec) integer(0) integer(2)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(values) operator_fat(()(vector-ref) (vec) integer(0)operator_fat(\)) operator_fat(()(vector-ref) (vec) integer(1)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(pop2) (vec)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(vec) operator_fat(()(vector-slice) (vec) (-)integer(1) integer(2)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(values) operator_fat(()(vector-ref) (vec) integer(0)operator_fat(\)) operator_fat(()(vector-ref) (vec) integer(1)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*friends*) operator_fat(')operator_fat(#()operator_fat(')(Peter) operator_fat(')(Paul) operator_fat(')(Mary) operator_fat(')(Jim) operator_fat(')(Tim)operator_fat(\))operator_fat(\))

operator_fat(()(let-values) operator_fat(() operator_fat(()operator_fat(()(this) (that)operator_fat(\)) operator_fat(()(shift2) (*friends*)operator_fat(\))operator_fat(\)) operator_fat(\))
  operator_fat(()(print) (this) string<delimiter(")content(:)delimiter(")> (that)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*beverages*) operator_fat(')operator_fat(#()operator_fat(')(Dew) operator_fat(')(Jolt) operator_fat(')(Cola) operator_fat(')(Sprite) operator_fat(')(Fresca)operator_fat(\))operator_fat(\))

operator_fat(()(let-values) operator_fat(() operator_fat(()operator_fat(()(d1) (d2)operator_fat(\)) operator_fat(()(pop2) (*beverages*)operator_fat(\))operator_fat(\)) operator_fat(\))
  operator_fat(()(print) (d1) string<delimiter(")content(:)delimiter(")> (d2)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.12)
comment(; SRFI-1 [list manipulation] routines are ideal for the types of task)
comment(; in this and the next section, in particular, 'for-each' and 'find',)
comment(; 'list-index', and many others for more specialist functions. The same)
comment(; applies to vectors with the SRFI-43 routines, 'vector-index' and)
comment(; 'vector-skip', though the approach taken in this chapter has been to)
comment(; implement functionally similar vector manipulation routines to more)
comment(; closely mimic the Perl examples)

comment(; Return #f, or first index for which 'pred' returns true)
operator_fat(()reserved(define) operator_fat(()(vector-first-idx) (pred) (vec)operator_fat(\)) 
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(vec-len) operator_fat(()(vector-length) (vec)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(idx) integer(0)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(cond)
        operator_fat(()operator_fat(()(=) (idx) (vec-len)operator_fat(\)) pre_constant(#f)operator_fat(\))
        operator_fat(()(else)
          operator_fat(()reserved(if) operator_fat(()(pred) operator_fat(()(vector-ref) (vec) (idx)operator_fat(\))operator_fat(\))
            (idx)
          comment(;else)
            operator_fat(()(loop) operator_fat(()(+) (idx) integer(1)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Return #f, or first index for which 'pred' returns true)
operator_fat(()reserved(define) operator_fat(()(list-first-idx) (pred) (list)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(idx) integer(0)operator_fat(\)) operator_fat(()(list) (list)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(null?) (list)operator_fat(\)) pre_constant(#f)operator_fat(\))
      operator_fat(()(else)
        operator_fat(()reserved(if) operator_fat(()(pred) operator_fat(()(car) (list)operator_fat(\))operator_fat(\))
          (idx)
        comment(;else)
          operator_fat(()(loop) operator_fat(()(+) (idx) integer(1)operator_fat(\)) operator_fat(()(cdr) (list)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*array*) operator_fat(')operator_fat(#()integer(1) integer(2) integer(3) integer(4) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))

operator_fat(()(print)
  operator_fat(()(vector-first-idx)
    operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(=) (x) integer(9)operator_fat(\))operator_fat(\))
    (*array*)operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*list*) operator_fat(')operator_fat(()integer(1) integer(2) integer(3) integer(4) integer(5) integer(6) integer(7) integer(8)operator_fat(\))operator_fat(\))

operator_fat(()(print)
  operator_fat(()(list-first-idx)
    operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(=) (x) integer(4)operator_fat(\))operator_fat(\))
    (*list*)operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()(print)
  operator_fat(()(list-index)
    operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(=) (x) integer(4)operator_fat(\))operator_fat(\))
    (*list*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; The Perl 'highest paid engineer' example isn't really a 'first match')
comment(; type of problem - the routines shown earlier really aren't suited to)
comment(; this. Better suited, instead, are the SRFI-1 routines like 'fold',)
comment(; 'fold-right' and 'reduce', even old standbys like 'filter' and 'for-each')

operator_fat(()reserved(define) (+)(null-salary-rec+)
  operator_fat(()(list) operator_fat(')operator_fat(()operator_fat(\)) integer(0) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*salaries*)
  operator_fat(()(list)
    operator_fat(()(list) operator_fat(')(engineer) integer(43000) operator_fat(')(Bob)operator_fat(\))
    operator_fat(()(list) operator_fat(')(programmer) integer(48000) operator_fat(')(Andy)operator_fat(\))
    operator_fat(()(list) operator_fat(')(engineer) integer(35000) operator_fat(')(Champ)operator_fat(\)) 
    operator_fat(()(list) operator_fat(')(engineer) integer(49000) operator_fat(')(Bubbles)operator_fat(\))
    operator_fat(()(list) operator_fat(')(programmer) integer(47000) operator_fat(')(Twig)operator_fat(\))
    operator_fat(()(list) operator_fat(')(engineer) integer(34000) operator_fat(')(Axel)operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*highest-paid-engineer*)
  operator_fat(()(reduce)
    operator_fat(()reserved(lambda) operator_fat(()(salary-rec) (acc)operator_fat(\))
      operator_fat(()reserved(if)
        operator_fat(()reserved(and)
          operator_fat(()(eq?) operator_fat(()(car) (salary-rec)operator_fat(\)) operator_fat(')(engineer)operator_fat(\))
          operator_fat(()(>) operator_fat(()(cadr) (salary-rec)operator_fat(\)) operator_fat(()(cadr) (acc)operator_fat(\))operator_fat(\))operator_fat(\))
        (salary-rec)
      comment(;else)
        (acc)operator_fat(\))operator_fat(\))
    (+)(null-salary-rec+)
    (*salaries*)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*highest-paid-engineer*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*highest-paid-engineer*)
  operator_fat(()(fold-right)
    operator_fat(()reserved(lambda) operator_fat(()(salary-rec) (acc)operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(>) operator_fat(()(cadr) (salary-rec)operator_fat(\)) operator_fat(()(cadr) (acc)operator_fat(\))operator_fat(\))
        (salary-rec)
      comment(;else)
        (acc)operator_fat(\))operator_fat(\))
    (+)(null-salary-rec+)
    operator_fat(()(filter)
      operator_fat(()reserved(lambda) operator_fat(()(salary-rec)operator_fat(\))
        operator_fat(()(eq?) operator_fat(()(car) (salary-rec)operator_fat(\)) operator_fat(')(engineer)operator_fat(\))operator_fat(\))
      (*salaries*)operator_fat(\))operator_fat(\)) operator_fat(\))

operator_fat(()(print) (*highest-paid-engineer*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*highest-paid-engineer*) (+)(null-salary-rec+)operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(salary-rec)operator_fat(\))
    operator_fat(()reserved(if)
      operator_fat(()reserved(and)
        operator_fat(()(eq?) operator_fat(()(car) (salary-rec)operator_fat(\)) operator_fat(')(engineer)operator_fat(\))
        operator_fat(()(>) operator_fat(()(cadr) (salary-rec)operator_fat(\)) operator_fat(()(cadr) (*highest-paid-engineer*)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*highest-paid-engineer*) (salary-rec)operator_fat(\))operator_fat(\))operator_fat(\))
  (*salaries*)operator_fat(\))

operator_fat(()(print) (*highest-paid-engineer*)operator_fat(\))

comment(;; @@PLEAC@@_4.13)
comment(; All tasks in this section consist of either generating a collection,)
comment(; or filtering a larger collection, of elements matching some criteria;)
comment(; obvious candidates are the 'filter' and 'array-filter' routines, though)
comment(; others like 'for-each' can also be applied)

operator_fat(()reserved(define) (*list-matching*) operator_fat(()(filter) (PRED) (LIST)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*vector-matching*) operator_fat(()(array-filter) (PRED) (ARRAY)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*nums*) operator_fat(')operator_fat(()integer(1e7) integer(3e7) integer(2e7) integer(4e7) integer(1e7) integer(3e7) integer(2e7) integer(4e7)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*bigs*) 
  operator_fat(()(filter)
    operator_fat(()reserved(lambda) operator_fat(()(num)operator_fat(\)) operator_fat(()(>) (num) integer(1000000)operator_fat(\))operator_fat(\))
    (*nums*)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*users*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(u1) operator(.) integer(2e7)operator_fat(\))
    operator_fat(')operator_fat(()(u2) operator(.) integer(1e7)operator_fat(\))
    operator_fat(')operator_fat(()(u3) operator(.) integer(4e7)operator_fat(\))
    operator_fat(')operator_fat(()(u4) operator(.) integer(3e7)operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*pigs*)
  operator_fat(()(fold-right)
    operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
    operator_fat(')operator_fat(()operator_fat(\))
    operator_fat(()(filter)
      operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\)) operator_fat(()(>) operator_fat(()(cdr) (pair)operator_fat(\)) integer(1e7)operator_fat(\))operator_fat(\))
      (*users*)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(print) (*pigs*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*salaries*)
  operator_fat(()(list)
    operator_fat(()(list) operator_fat(')(engineer) integer(43000) operator_fat(')(Bob)operator_fat(\))
    operator_fat(()(list) operator_fat(')(programmer) integer(48000) operator_fat(')(Andy)operator_fat(\))
    operator_fat(()(list) operator_fat(')(engineer) integer(35000) operator_fat(')(Champ)operator_fat(\)) 
    operator_fat(()(list) operator_fat(')(engineer) integer(49000) operator_fat(')(Bubbles)operator_fat(\))
    operator_fat(()(list) operator_fat(')(programmer) integer(47000) operator_fat(')(Twig)operator_fat(\))
    operator_fat(()(list) operator_fat(')(engineer) integer(34000) operator_fat(')(Axel)operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*engineers*)
  operator_fat(()(filter)
    operator_fat(()reserved(lambda) operator_fat(()(salary-rec)operator_fat(\))
      operator_fat(()(eq?) operator_fat(()(car) (salary-rec)operator_fat(\)) operator_fat(')(engineer)operator_fat(\))operator_fat(\))
    (*salaries*)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*engineers*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*applicants*)
  operator_fat(()(list)
    operator_fat(()(list) operator_fat(')(a1) integer(26000) operator_fat(')(Bob)operator_fat(\))
    operator_fat(()(list) operator_fat(')(a2) integer(28000) operator_fat(')(Andy)operator_fat(\))
    operator_fat(()(list) operator_fat(')(a3) integer(24000) operator_fat(')(Candy)operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*secondary-assistance*)
  operator_fat(()(filter)
    operator_fat(()reserved(lambda) operator_fat(()(salary-rec)operator_fat(\))
      operator_fat(()reserved(and)
        operator_fat(()(>) operator_fat(()(cadr) (salary-rec)operator_fat(\)) integer(26000)operator_fat(\))
        operator_fat(()(<) operator_fat(()(cadr) (salary-rec)operator_fat(\)) integer(30000)operator_fat(\))operator_fat(\))operator_fat(\))
    (*applicants*)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*secondary-assistance*)operator_fat(\))

comment(;; @@PLEAC@@_4.14)
comment(; Sorting numeric data in Scheme is very straightforward ...)

operator_fat(()reserved(define) (*unsorted*) operator_fat(')operator_fat(()integer(5) integer(8) integer(1) integer(7) integer(4) integer(2) integer(3) integer(6)operator_fat(\))operator_fat(\)) 

comment(;; ------------)

comment(; Ascending sort - use '<' as comparator)
operator_fat(()reserved(define) (*sorted*) 
  operator_fat(()(sort)
    (*unsorted*)
    (<)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*sorted*)operator_fat(\))

comment(;; ------------)

comment(; Descending sort - use '>' as comparator)
operator_fat(()reserved(define) (*sorted*) 
  operator_fat(()(sort)
    (*unsorted*)
    (>)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*sorted*)operator_fat(\))

comment(;; @@PLEAC@@_4.15)
comment(; A customised lambda may be passed as comparator to 'sort', so)
comment(; sorting on one or more 'fields' is quite straightforward)

operator_fat(()reserved(define) (*unordered*) operator_fat(')operator_fat(() (...) operator_fat(\))operator_fat(\))

comment(; COMPARE is some comparator suited for the element type being)
comment(; sorted)
operator_fat(()reserved(define) (*ordered*)
  operator_fat(()(sort)
    (*unordered*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(COMPARE) (left) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*unordered*)
  operator_fat(()(list)
    operator_fat(()reserved(cons) operator_fat(')(s) integer(34)operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(')(e) integer(12)operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(')(c) integer(45)operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(')(q) integer(11)operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(')(g) integer(24)operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*pre-computed*)
  operator_fat(()(map)
    comment(; Here element is returned unaltered, but it would normally be)
    comment(; transformed in som way)
    operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\)) (element)operator_fat(\))
    (*unordered*)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*ordered-pre-computed*)
  operator_fat(()(sort)
    (*pre-computed*)
    comment(; Sort on the first field [assume it is the 'key'] )
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Extract the second field [assume it is the 'value'])
operator_fat(()reserved(define) (*ordered*)
  operator_fat(()(map) 
    operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\)) operator_fat(()(cdr) (element)operator_fat(\))operator_fat(\))
    (*ordered-pre-computed*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*employees*)
  operator_fat(()(list)
    operator_fat(()(list) operator_fat(')(Bob) integer(43000) integer(123) integer(42)operator_fat(\))
    operator_fat(()(list) operator_fat(')(Andy) integer(48000) integer(124) integer(35)operator_fat(\))
    operator_fat(()(list) operator_fat(')(Champ) integer(35000) integer(125) integer(37)operator_fat(\)) 
    operator_fat(()(list) operator_fat(')(Bubbles) integer(49000) integer(126) integer(34)operator_fat(\))
    operator_fat(()(list) operator_fat(')(Twig) integer(47000) integer(127) integer(36)operator_fat(\))
    operator_fat(()(list) operator_fat(')(Axel) integer(34000) integer(128) integer(31)operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*ordered*)
  operator_fat(()(sort)
    (*employees*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(employee)operator_fat(\))
    operator_fat(()(print) operator_fat(()(car) (employee)operator_fat(\)) string<delimiter(")content(earns $)delimiter(")> operator_fat(()(cadr) (employee)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(sort)
    (*employees*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*bonus*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()integer(125) operator(.) integer(1000)operator_fat(\))
    operator_fat(')operator_fat(()integer(127) operator(.) integer(1500)operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(employee)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(bonus) operator_fat(()(assoc-ref) (*bonus*) operator_fat(()(caddr) (employee)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(not) (bonus)operator_fat(\))
        operator_fat(')operator_fat(()operator_fat(\))
      comment(;else)
        operator_fat(()(print) operator_fat(()(car) (employee)operator_fat(\)) string<delimiter(")content(earned bonus)delimiter(")> (bonus)operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(sort)
    (*employees*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(ice-9) (rdelim)operator_fat(\)) operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*filename*) string<delimiter(")content(/etc/passwd)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (*users*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(port) operator_fat(()(open-input-file) (*filename*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line&terminator) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(eof-object?) operator_fat(()(cdr) (line&terminator)operator_fat(\))operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
      operator_fat(()(else)
        operator_fat(()reserved(set!) (*users*)
          operator_fat(()(assoc-set!)
            (*users*)
            operator_fat(()(car) operator_fat(()(string-split) operator_fat(()(car) (line&terminator)operator_fat(\)) char(#\\:)operator_fat(\))operator_fat(\))
            pre_constant(#t)operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\)) 
  operator_fat(()(close-input-port) (port)operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user)operator_fat(\)) operator_fat(()(print) operator_fat(()(car) (user)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(sort)
    (*users*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(car) (left)operator_fat(\))
        operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.16)
comment(; Use SRFI-1's 'circular-list' routine to build a circular list)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*processes*) operator_fat(()(circular-list) integer(1) integer(2) integer(3) integer(4) integer(5)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(processes) (*processes*)operator_fat(\))operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(Handling process)delimiter(")> operator_fat(()(car) (processes)operator_fat(\))operator_fat(\))
  operator_fat(()(sleep) integer(1)operator_fat(\))
  operator_fat(()(loop) operator_fat(()(cdr) (processes)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_4.17)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

comment(; Implements Fischer-Yates shuffle algorithm)
operator_fat(()reserved(define) operator_fat(()(vector-shuffle!) (vec)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(vector-length) operator_fat(()(vector-length) (vec)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) (vector-length)operator_fat(\)) operator_fat(()(j) operator_fat(()(+) integer(1) operator_fat(()(random) (vector-length)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(cond)
        operator_fat(()operator_fat(()(=) (i) integer(1)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(not) operator_fat(()(=) (i) (j)operator_fat(\))operator_fat(\))
          operator_fat(()(vector-ref-swap!) (vec) operator_fat(()(-) (i) integer(1)operator_fat(\)) operator_fat(()(-) (j) integer(1)operator_fat(\))operator_fat(\))
          operator_fat(()(loop) operator_fat(()(-) (i) integer(1)operator_fat(\)) operator_fat(()(+) integer(1) operator_fat(()(random) operator_fat(()(-) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(else)
          operator_fat(()(loop) operator_fat(()(-) (i) integer(1)operator_fat(\)) operator_fat(()(+) integer(1) operator_fat(()(random) operator_fat(()(-) (i) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(vector-ref-swap!) (vec) (idx1) (idx2)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(tmp) operator_fat(()(vector-ref) (vec) (idx1)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(vector-set!) (vec) (idx1) operator_fat(()(vector-ref) (vec) (idx2)operator_fat(\))operator_fat(\))
    operator_fat(()(vector-set!) (vec) (idx2) (tmp)operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Generate vector of values 1 .. 10)
operator_fat(()reserved(define) (*irange*) operator_fat(()(list->vector) operator_fat(()(iota) integer(10) integer(1) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Shuffle array values)
operator_fat(()(vector-shuffle!) (*irange*)operator_fat(\))

comment(;; @@PLEAC@@_4.18)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_4.19)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_5.0)
comment(;; ---------------------------------------------------------------------)
comment(;; Scheme offers two dictionary types:)
comment(;;)
comment(;; * Association list [list of pairs e.g. '((k1 . v1\) (k2 . v2\) ...\)])
comment(;; * Hash table [vector of pairs plus hash algorithm])
comment(;;)
comment(;; Implementation differences aside, they are remarkably similar in that)
comment(;; the functions operating on them are similar named, and offer the same)
comment(;; interface. Examples:)
comment(;;)
comment(;; * Retrieve an item: (assoc-ref hash key\) (hash-ref hash key\))
comment(;; * Update an item:   (assoc-set! hash key value\) (hash-set! hash key value\) )
comment(;;)
comment(;; Hash tables would tend to be used where performance was critical e.g.)
comment(;; near constant-time lookups, or where entry updates are frequent, whilst)
comment(;; association lists would be used where table-level traversals and )
comment(;; manipulations require maximum flexibility)
comment(;;)
comment(;; Many of the sections include examples using both association lists and)
comment(;; hash tables. However, where only one of these is shown, implementing)
comment(;; the other is usually a trivial exercise. Finally, any helper functions)
comment(;; will be included in the Appendix)
comment(;; ---------------------------------------------------------------------)

comment(; Association lists)
operator_fat(()reserved(define) (*age*)
  operator_fat(()(list)
    operator_fat(()reserved(cons) operator_fat(')(Nat) integer(24)operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(')(Jules) integer(25)operator_fat(\))
    operator_fat(()reserved(cons) operator_fat(')(Josh) integer(17)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or, perhaps more compactly:)
operator_fat(()reserved(define) (*age*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Nat) operator(.) integer(24)operator_fat(\))
    operator_fat(')operator_fat(()(Jules) operator(.) integer(25)operator_fat(\))
    operator_fat(')operator_fat(()(Josh) operator(.) integer(17)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; Guile built-in association list support)
operator_fat(()reserved(define) (*age*) operator_fat(()(acons) operator_fat(')(Nat) integer(24) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*age*) operator_fat(()(acons) operator_fat(')(Jules) integer(25) (*age*)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*age*) operator_fat(()(acons) operator_fat(')(Josh) integer(17) (*age*)operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; SRFI-1 association list support)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*age*) operator_fat(()(alist-cons) operator_fat(')(Nat) integer(24) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*age*) operator_fat(()(alist-cons) operator_fat(')(Jules) integer(25) (*age*)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*age*) operator_fat(()(alist-cons) operator_fat(')(Josh) integer(17) (*age*)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*food-colour*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Banana) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; Hash tables. Guile offers an implementation, and it is also )
comment(; possible to use SRFI-69 hash tables; only the former will be)
comment(; illustrated here)

operator_fat(()reserved(define) (*age*) operator_fat(()(make-hash-table) integer(20)operator_fat(\))operator_fat(\))
comment(; or)
operator_fat(()reserved(define) (*age*) operator_fat(()(make-vector) integer(20) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(hash-set!) (*age*) operator_fat(')(Nat) integer(24)operator_fat(\))
operator_fat(()(hash-set!) (*age*) operator_fat(')(Jules) integer(25)operator_fat(\))
operator_fat(()(hash-set!) (*age*) operator_fat(')(Josh) integer(17)operator_fat(\))

operator_fat(()(hash-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(key) (value)operator_fat(\)) operator_fat(()(print) (key)operator_fat(\))operator_fat(\))
  (*age*)operator_fat(\))

comment(; or, if vector used as hash table, can also use:)

operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(null?) (pair)operator_fat(\))operator_fat(\)) operator_fat(()(print) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*age*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*food-colour*) operator_fat(()(make-hash-table) integer(20)operator_fat(\))operator_fat(\))

operator_fat(()(hash-set!) (*food-colour*) operator_fat(')(Apple) string<delimiter(")content(red)delimiter(")>operator_fat(\))
operator_fat(()(hash-set!) (*food-colour*) operator_fat(')(Banana) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
operator_fat(()(hash-set!) (*food-colour*) operator_fat(')(Lemon) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
operator_fat(()(hash-set!) (*food-colour*) operator_fat(')(Carrot) string<delimiter(")content(orange)delimiter(")>operator_fat(\))

comment(;; @@PLEAC@@_5.1)
operator_fat(()reserved(set!) (*hash*) operator_fat(()(acons) (key) (value) (*hash*)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(set!) (*food-colour*) operator_fat(()(acons) operator_fat(')(Raspberry) string<delimiter(")content(pink)delimiter(")> (*food-colour*)operator_fat(\))operator_fat(\))

operator_fat(()(print) string<delimiter(")content(Known foods:)delimiter(")>operator_fat(\))
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\)) operator_fat(()(print) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
  (*food-colour*)operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(hash-set!) (*hash*) (key) (value)operator_fat(\))

comment(;; ------------)

operator_fat(()(hash-set!) (*food-colour*) operator_fat(')(Raspberry) string<delimiter(")content(pink)delimiter(")>operator_fat(\))

operator_fat(()(print) string<delimiter(")content(Known foods:)delimiter(")>operator_fat(\))
operator_fat(()(hash-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(key) (value)operator_fat(\)) operator_fat(()(print) (key)operator_fat(\))operator_fat(\))
  (*food-colour*)operator_fat(\))

comment(;; @@PLEAC@@_5.2)
comment(; 'assoc' returns the pair, (key . value\))
operator_fat(()reserved(if) operator_fat(()(assoc) (key) (hash)operator_fat(\))
  (...) (found) (...)
comment(;else)
  (...) (not) (found) (...)

comment(; 'assoc-ref' returns the value only)
operator_fat(()reserved(if) operator_fat(()(assoc-ref) (hash) (key)operator_fat(\))
  (...) (found) (...)
comment(;else)
  (...) (not) (found) (...)

comment(;; ------------)

comment(; *food-colour* association list from an earlier section)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(name)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(pair) operator_fat(()(assoc) (name) (*food-colour*)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) (pair)
        operator_fat(()(print) operator_fat(()(symbol->string) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\)) string<delimiter(")content(is a food)delimiter(")>operator_fat(\))
      comment(;else)
        operator_fat(()(print) operator_fat(()(symbol->string) (name)operator_fat(\)) string<delimiter(")content(is a drink)delimiter(")>operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(list) operator_fat(')(Banana) operator_fat(')(Martini)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; 'hash-get-handle' returns the pair, (key . value\))
operator_fat(()reserved(if) operator_fat(()(hash-get-handle) (hash) (key)operator_fat(\))
  (...) (found) (...)
comment(;else)
  (...) (not) (found) (...)

comment(; 'hash-ref' returns the value only)
operator_fat(()reserved(if) operator_fat(()(hash-ref) (hash) (key)operator_fat(\))
  (...) (found) (...)
comment(;else)
  (...) (not) (found) (...)

comment(;; ------------)

comment(; *food-colour* hash table from an earlier section)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(name)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(value) operator_fat(()(hash-ref) (*food-colour*) (name)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) (value)
        operator_fat(()(print) operator_fat(()(symbol->string) (name)operator_fat(\)) string<delimiter(")content(is a food)delimiter(")>operator_fat(\))
      comment(;else)
        operator_fat(()(print) operator_fat(()(symbol->string) (name)operator_fat(\)) string<delimiter(")content(is a drink)delimiter(")>operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(list) operator_fat(')(Banana) operator_fat(')(Martini)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*age*) operator_fat(()(make-hash-table) integer(20)operator_fat(\))operator_fat(\))

operator_fat(()(hash-set!) (*age*) operator_fat(')(Toddler) integer(3)operator_fat(\))
operator_fat(()(hash-set!) (*age*) operator_fat(')(Unborn) integer(0)operator_fat(\))
operator_fat(()(hash-set!) (*age*) operator_fat(')(Phantasm) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(thing)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(value) operator_fat(()(hash-ref) (*age*) (thing)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(display) (thing)operator_fat(\))
      operator_fat(()reserved(if) (value) operator_fat(()(display) string<delimiter(")content( Exists)delimiter(")>operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()reserved(and) (value) operator_fat(()(not) operator_fat(()(string-null?) (value)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(()(display) string<delimiter(")content( Defined)delimiter(")>operator_fat(\))operator_fat(\))
      comment(; Testing for non-zero as true is not applicable, so testing)
      comment(; for non-equality with zero )
      operator_fat(()reserved(if) operator_fat(()reserved(and) (value) operator_fat(()(not) operator_fat(()(eq?) (value) integer(0)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(()(display) string<delimiter(")content( True)delimiter(")>operator_fat(\))operator_fat(\))
      operator_fat(()(print) string<delimiter(")delimiter(")>operator_fat(\)) operator_fat(\))operator_fat(\))
  operator_fat(()(list) operator_fat(')(Toddler) operator_fat(')(Unborn) operator_fat(')(Phantasm) operator_fat(')(Relic)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.3)
operator_fat(()(assoc-remove!) (hash) (key)operator_fat(\))

comment(;; ------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

comment(; *food-colour* association list from an earlier section)

operator_fat(()reserved(define) operator_fat(()(print-foods)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(foods)
          operator_fat(()(fold-right)
            operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
            operator_fat(')operator_fat(()operator_fat(\))
            (*food-colour*)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(display) string<delimiter(")content(Keys: )delimiter(")>operator_fat(\)) operator_fat(()(print) (foods)operator_fat(\))
    operator_fat(()(print) string<delimiter(")content(Values:)delimiter(")>operator_fat(\))
    operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(food)operator_fat(\))
        operator_fat(()reserved(let) operator_fat(()operator_fat(()(colour) operator_fat(()(assoc-ref) (*food-colour*) (food)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(cond)
            operator_fat(()operator_fat(()(string-null?) (colour)operator_fat(\)) operator_fat(()(display) string<delimiter(")content((undef\) )delimiter(")>operator_fat(\))operator_fat(\))
            operator_fat(()(else) operator_fat(()(display) operator_fat(()(string-append) (colour) string<delimiter(")content( )delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
      (foods)operator_fat(\))operator_fat(\))
    operator_fat(()(newline)operator_fat(\))operator_fat(\))

operator_fat(()(print) string<delimiter(")content(Initially:)delimiter(")>operator_fat(\))
operator_fat(()(print-foods)operator_fat(\))

operator_fat(()(print) string<delimiter(")content(\\n)content(With Banana undef)delimiter(")>operator_fat(\))
operator_fat(()(assoc-set!) (*food-colour*) operator_fat(')(Banana) string<delimiter(")delimiter(")>operator_fat(\))
operator_fat(()(print-foods)operator_fat(\))

operator_fat(()(print) string<delimiter(")content(\\n)content(With Banana deleted)delimiter(")>operator_fat(\))
operator_fat(()(assoc-remove!) (*food-colour*) operator_fat(')(Banana)operator_fat(\))
operator_fat(()(print-foods)operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(hash-remove!) (hash) (key)operator_fat(\))

comment(;; ------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\))operator_fat(\))

comment(; *food-colour* hash table from an earlier section)

operator_fat(()reserved(define) operator_fat(()(print-foods)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(foods)
          operator_fat(()(hash-fold)
            operator_fat(()reserved(lambda) operator_fat(()(key) (value) (accum)operator_fat(\)) operator_fat(()reserved(cons) (key) (accum)operator_fat(\))operator_fat(\))
            operator_fat(')operator_fat(()operator_fat(\))
            (*food-colour*)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(display) string<delimiter(")content(Keys: )delimiter(")>operator_fat(\)) operator_fat(()(print) operator_fat(()(reverse) (foods)operator_fat(\))operator_fat(\))
    operator_fat(()(print) string<delimiter(")content(Values:)delimiter(")>operator_fat(\))
    operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(food)operator_fat(\))
        operator_fat(()reserved(let) operator_fat(()operator_fat(()(colour) operator_fat(()(hash-ref) (*food-colour*) (food)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(cond)
            operator_fat(()operator_fat(()(string-null?) (colour)operator_fat(\)) operator_fat(()(display) string<delimiter(")content((undef\) )delimiter(")>operator_fat(\))operator_fat(\))
            operator_fat(()(else) operator_fat(()(display) operator_fat(()(string-append) (colour) string<delimiter(")content( )delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
      (foods)operator_fat(\))operator_fat(\))
    operator_fat(()(newline)operator_fat(\))operator_fat(\))

operator_fat(()(print) string<delimiter(")content(Initially:)delimiter(")>operator_fat(\))
operator_fat(()(print-foods)operator_fat(\))

operator_fat(()(print) string<delimiter(")content(\\n)content(With Banana undef)delimiter(")>operator_fat(\))
operator_fat(()(hash-set!) (*food-colour*) operator_fat(')(Banana) string<delimiter(")delimiter(")>operator_fat(\))
operator_fat(()(print-foods)operator_fat(\))

operator_fat(()(print) string<delimiter(")content(\\n)content(With Banana deleted)delimiter(")>operator_fat(\))
operator_fat(()(hash-remove!) (*food-colour*) operator_fat(')(Banana)operator_fat(\))
operator_fat(()(print-foods)operator_fat(\))

comment(;; @@PLEAC@@_5.4)
comment(; Since an association list is nothing more than a list of pairs, it)
comment(; may be traversed using 'for-each')
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(key) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(value) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      (...) reserved(do) (something) (with) (key) (/) (value) (...)operator_fat(\))operator_fat(\))
  (hash)operator_fat(\))

comment(;; ----------------------------)

comment(; A 'for-each'-like function is available for hash table traversal)
operator_fat(()(hash-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(key) (value)operator_fat(\))
    (...) reserved(do) (something) (with) (key) (/) (value) (...)operator_fat(\))
  (hash)operator_fat(\))

comment(; If the hash table is directly implemented as a vector, then it is)
comment(; also possible to traverse it using, 'array-for-each', though a )
comment(; check for empty slots is needed )
operator_fat(()(array-for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(null?) (pair)operator_fat(\))operator_fat(\)) (...) reserved(do) (something) (with) (key) (/) (value) (...)operator_fat(\))operator_fat(\))
  (hash)operator_fat(\))

comment(;; ----------------------------)

comment(; *food-colour* association list from an earlier section)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(food) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(colour) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(print) operator_fat(()(symbol->string) (food)operator_fat(\)) string<delimiter(")content(is)delimiter(")> (colour)operator_fat(\)) operator_fat(\))operator_fat(\))
  (*food-colour*)operator_fat(\))

comment(;; ------------)

comment(; *food-colour* association list from an earlier section)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(food)operator_fat(\))
    operator_fat(()(print) operator_fat(()(symbol->string) (food)operator_fat(\)) string<delimiter(")content(is)delimiter(")> operator_fat(()(assoc-ref) (*food-colour*) (food)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(sort)
    operator_fat(()(fold-right)
      operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
      operator_fat(')operator_fat(()operator_fat(\))
      (*food-colour*)operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?) operator_fat(()(symbol->string) (left)operator_fat(\)) operator_fat(()(symbol->string) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(ice-9) (rdelim)operator_fat(\)) operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*filename*) string<delimiter(")content(from.txt)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (*from*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(port) operator_fat(()(open-input-file) (*filename*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line&terminator) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(eof-object?) operator_fat(()(cdr) (line&terminator)operator_fat(\))operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
      operator_fat(()(else)
        operator_fat(()reserved(let*) operator_fat(()operator_fat(()(key) operator_fat(()(string->symbol)
                      operator_fat(()(match:substring)
                        operator_fat(()(string-match)
                          string<delimiter(")content(^From: (.*\))delimiter(")> operator_fat(()(car) (line&terminator)operator_fat(\))operator_fat(\))
                        integer(1)operator_fat(\)) operator_fat(\))operator_fat(\))
               operator_fat(()(value) operator_fat(()(assoc-ref) (*from*) (key)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(if) operator_fat(()(not) (value)operator_fat(\)) operator_fat(()reserved(set!) (value) integer(0)operator_fat(\))operator_fat(\))
          operator_fat(()reserved(set!) (*from*) operator_fat(()(assoc-set!) (*from*) (key) operator_fat(()(+) integer(1) (value)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\)) 
  operator_fat(()(close-input-port) (port)operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(person)operator_fat(\))
    operator_fat(()(print) operator_fat(()(symbol->string) (person)operator_fat(\)) string<delimiter(")content(:)delimiter(")> operator_fat(()(number->string) operator_fat(()(assoc-ref) (*from*) (person)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(sort)
    operator_fat(()(fold-right)
      operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
      operator_fat(')operator_fat(()operator_fat(\))
      (*from*)operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?) operator_fat(()(symbol->string) (left)operator_fat(\)) operator_fat(()(symbol->string) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.5)
comment(; All approaches shown in the previous section apply here also, so)
comment(; there is little to be gained by repeating those examples [i.e. the)
comment(; use of 'for-each' and similar]. It is always possible, of course,)
comment(; to directly recurse over an association list:)

comment(; *food-colour* association list from an earlier section)

operator_fat(()reserved(define) (*sorted-food-colour*)
  operator_fat(()(sort)
    (*food-colour*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(hash) (*sorted-food-colour*)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond)
    operator_fat(()operator_fat(()(null?) (hash)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
    operator_fat(()(else)  
      operator_fat(()(print)
        operator_fat(()(symbol->string) operator_fat(()(car) operator_fat(()(car) (hash)operator_fat(\))operator_fat(\))operator_fat(\)) string<delimiter(")content(=>)delimiter(")> operator_fat(()(cdr) operator_fat(()(car) (hash)operator_fat(\))operator_fat(\)) operator_fat(\))
      operator_fat(()(loop) operator_fat(()(cdr) (hash)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.6)
comment(; AFAIK, Scheme doesn't offer a facility similar to Perl's 'Tie::IxHash'.)
comment(; Therefore, use an association list if retrieval [from a dictionary)
comment(; type container] in insertion order is required.)

operator_fat(()reserved(define) (*food-colour*) operator_fat(()(acons) operator_fat(')(Banana) string<delimiter(")content(Yellow)delimiter(")> operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*food-colour*) operator_fat(()(acons) operator_fat(')(Apple) string<delimiter(")content(Green)delimiter(")> (*food-colour*)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (*food-colour*) operator_fat(()(acons) operator_fat(')(Lemon) string<delimiter(")content(yellow)delimiter(")> (*food-colour*)operator_fat(\))operator_fat(\))

operator_fat(()(print) string<delimiter(")content(In insertion order, the foods are:)delimiter(")>operator_fat(\))
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(food) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(colour) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(print) string<delimiter(")content(  )delimiter(")> operator_fat(()(symbol->string) (food)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))
  (*food-colour*)operator_fat(\))

operator_fat(()(print) string<delimiter(")content(Still in insertion order, the food's colours are:)delimiter(")>operator_fat(\))
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(food) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(colour) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(print) operator_fat(()(symbol->string) (food)operator_fat(\)) string<delimiter(")content(is coloured)delimiter(")> (colour)operator_fat(\)) operator_fat(\))operator_fat(\))
  (*food-colour*)operator_fat(\))

comment(;; ----------------------------)

comment(; Of course, insertion order is lost if the association list is sorted,)
comment(; or elements removed, so if maintaining insertion order is vital, it)
comment(; might pay to associate data with a timestamp [e.g. create a timestamped)
comment(; record / structure], and manipulate those entities [no example given])

comment(;; @@PLEAC@@_5.7)
operator_fat(()reserved(define) (*ttys*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user-tty-pair)operator_fat(\))
    operator_fat(()reserved(let*) operator_fat(()operator_fat(()(user-tty-pair) operator_fat(()(string-split) (user-tty-pair) char(#\\space)operator_fat(\))operator_fat(\))
           operator_fat(()(user) operator_fat(()(string->symbol) operator_fat(()(car) (user-tty-pair)operator_fat(\))operator_fat(\))operator_fat(\))
           operator_fat(()(newtty) operator_fat(()(cadr) (user-tty-pair)operator_fat(\))operator_fat(\))
           operator_fat(()(current-ttys) operator_fat(()(assoc-ref) (*ttys*) (user)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*ttys*)
        operator_fat(()(assoc-set!) (*ttys*) (user)
          operator_fat(()reserved(if) operator_fat(()(not) (current-ttys)operator_fat(\))
            (newtty)
            operator_fat(()(string-append) (current-ttys) string<delimiter(")content( )delimiter(")> (newtty)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(string-split) operator_fat(()(qx) string<delimiter(")content(who|cut -d' ' -f1,2)delimiter(")>operator_fat(\)) char(#\\newline)operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(user-ttys)operator_fat(\))
    operator_fat(()(print) operator_fat(()(symbol->string) operator_fat(()(car) (user-ttys)operator_fat(\))operator_fat(\)) string<delimiter(")content(:)delimiter(")> operator_fat(()(cdr) (user-ttys)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(sort)
    (*ttys*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))

comment(;; ----------------------------)

operator_fat(()(use-modules) operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(multi-hash-delete) (hash) (key) (value)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(value-found) operator_fat(()(assoc-ref) (hash) (key)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) (value-found)
      operator_fat(()(assoc-ref) (hash) (key)
        operator_fat(()(regexp-substitute/global)
          pre_constant(#f) operator_fat(()(string-match) (value) (value-found)operator_fat(\)) operator_fat(')(pre) string<delimiter(")delimiter(")> operator_fat(')(post) string<delimiter(")delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.8)
comment(; Alternate implementatons of a hash inversion function; both assume)
comment(; key is a symbol, value is a string)

operator_fat(()reserved(define) operator_fat(()(assoc-invert) (assoc)operator_fat(\))
  operator_fat(()(map)
    operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
      operator_fat(()reserved(cons)
        operator_fat(()(string->symbol) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    (assoc)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) operator_fat(()(assoc-invert) (assoc)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(assoc) (assoc)operator_fat(\)) operator_fat(()(new-assoc) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(null?) (assoc)operator_fat(\)) (new-assoc)operator_fat(\))
      operator_fat(()(else) 
        operator_fat(()(loop) operator_fat(()(cdr) (assoc)operator_fat(\))
              operator_fat(()(acons)
                operator_fat(()(string->symbol) operator_fat(()(cdar) (assoc)operator_fat(\))operator_fat(\))
                operator_fat(()(symbol->string) operator_fat(()(caar) (assoc)operator_fat(\))operator_fat(\)) (new-assoc)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*surname*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Mickey) operator(.) string<delimiter(")content(Mantle)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Babe) operator(.) string<delimiter(")content(Ruth)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*first-name*) operator_fat(()(assoc-invert) (*surname*)operator_fat(\))operator_fat(\))

operator_fat(()(print) operator_fat(()(assoc-ref) (*first-name*) operator_fat(')(Mantle)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; foodfind)

operator_fat(()reserved(define) (*given*) operator_fat(()(string->symbol) operator_fat(()(cadr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*colour*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*food*) operator_fat(()(assoc-invert) (*colour*)operator_fat(\))operator_fat(\))

operator_fat(()reserved(if) operator_fat(()(assoc-ref) (*colour*) (*given*)operator_fat(\))
  operator_fat(()(print)
    operator_fat(()(symbol->string) (*given*)operator_fat(\)) 
    string<delimiter(")content(is a food with colour)delimiter(")>
    operator_fat(()(assoc-ref) (*colour*) (*given*)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(if) operator_fat(()(assoc-ref) (*food*) (*given*)operator_fat(\))
  operator_fat(()(print)
    operator_fat(()(assoc-ref) (*food*) (*given*)operator_fat(\))
    string<delimiter(")content(is a food with colour)delimiter(")>
    operator_fat(()(symbol->string) (*given*)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.9)
comment(; *food-colour* association list from an earlier section)

comment(; Use 'sort' to sort the entire hash, on key or on value, ascending or)
comment(; descending order)
operator_fat(()reserved(define) (*sorted-on-key:food-colour*)
  operator_fat(()(sort)
    (*food-colour*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) operator_fat(()(car) (left)operator_fat(\))operator_fat(\))
        operator_fat(()(symbol->string) operator_fat(()(car) (right)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*sorted-on-value:food-colour*)
  operator_fat(()(sort)
    (*food-colour*)
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(cdr) (left)operator_fat(\))
        operator_fat(()(cdr) (right)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(food) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(colour) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(print)
        operator_fat(()(symbol->string) (food)operator_fat(\))
        string<delimiter(")content(is)delimiter(")>
        (colour)operator_fat(\))operator_fat(\))operator_fat(\))
  (*sorted-on-key:food-colour*)operator_fat(\))

comment(;; ----------------------------)

comment(; Alternatively, generate a list of keys or values, sort as required,)
comment(; and use list to guide the hash traversal)

operator_fat(()reserved(define) (*sorted-food-colour-keys*)
  operator_fat(()(sort)
    operator_fat(()(fold-right)
      operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(car) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
      operator_fat(')operator_fat(()operator_fat(\))
      (*food-colour*)operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?)
        operator_fat(()(symbol->string) (left)operator_fat(\))
        operator_fat(()(symbol->string) (right)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*sorted-food-colour-values*)
  operator_fat(()(sort)
    operator_fat(()(fold-right)
      operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()reserved(cons) operator_fat(()(cdr) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
      operator_fat(')operator_fat(()operator_fat(\))
      (*food-colour*)operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(left) (right)operator_fat(\))
      operator_fat(()(string<?) (left) (right)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(food)operator_fat(\))
    operator_fat(()(print) operator_fat(()(symbol->string) (food)operator_fat(\)) string<delimiter(")content(is)delimiter(")> operator_fat(()(assoc-ref) (*food-colour*) (food)operator_fat(\))operator_fat(\))operator_fat(\))
  (*sorted-food-colour-keys*)operator_fat(\))

comment(;; @@PLEAC@@_5.10)
comment(; If merging is defined as the combining of the contents of two or more)
comment(; hashes, then it is simply a matter of copying the contents of each)
comment(; into a new hash)

comment(; Association lists can simply be appended together)
operator_fat(()reserved(define) (*food-colour*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Banana) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*drink-colour*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Galliano) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Mai) (Tai) operator(.) string<delimiter(")content(blue)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*ingested-colour*) operator_fat(()(append) (*food-colour*) (*drink-colour*)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; Hash tables built from vectors can be copied element by element into)
comment(; a new vector, or spliced together using 'vector-join' [see Chapter 4])

operator_fat(()reserved(define) (*food-colour*) operator_fat(()(make-vector) integer(20) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
comment(; ...)
operator_fat(()reserved(define) (*drink-colour*) operator_fat(()(make-vector) integer(20) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
comment(; ...)

operator_fat(()reserved(define) (*ingested-colour*)
  operator_fat(()(vector-join) (*food-colour*) (*drink-colour*)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.11)
operator_fat(()reserved(define) (*common*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*this-not-that*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*dict1*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*dict2*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; Find items common to '*dict1*' and '*dict2*')
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(key) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(value) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(assoc-ref) (*dict2*) (key)operator_fat(\))
        operator_fat(()reserved(set!) (*common*) operator_fat(()reserved(cons) (key) (*common*)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))
  (*dict1*)operator_fat(\))

comment(;; ------------)

comment(; Find items in '*dict1*' but not '*dict2*')
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(key) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(value) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(assoc-ref) (*dict2*) (key)operator_fat(\))operator_fat(\))
        operator_fat(()reserved(set!) (*this-not-that*) operator_fat(()reserved(cons) (key) (*this-not-that*)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))
  (*dict1*)operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*non-citrus*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*citrus-colour*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Orange) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lime) operator(.) string<delimiter(")content(green)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*food-colour*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Banana) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(key) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(value) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(assoc-ref) (*citrus-colour*) (key)operator_fat(\))operator_fat(\))
        operator_fat(()reserved(set!) (*non-citrus*) operator_fat(()reserved(cons) (key) (*non-citrus*)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))
  (*food-colour*)operator_fat(\))

comment(;; @@PLEAC@@_5.12)
comment(; All objects [including functions] are first class entities, so there)
comment(; is no problem / special treatment needed to use any object, including)
comment(; those classed as 'references' [e.g. file handles or ports] as keys)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*ports*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(filename)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(port) operator_fat(()(open-input-file) (filename)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*ports*) operator_fat(()(assoc-set!) (*ports*) (port) (filename)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))
  operator_fat(')operator_fat(()string<delimiter(")content(/etc/termcap)delimiter(")> string<delimiter(")content(/vmlinux)delimiter(")> string<delimiter(")content(/bin/cat)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()(print)
  operator_fat(()(string-append) string<delimiter(")content(open files: )delimiter(")>
    operator_fat(()(string-drop)
      operator_fat(()(fold-right)
        operator_fat(()reserved(lambda) operator_fat(()(pair) (accum)operator_fat(\)) operator_fat(()(string-append) string<delimiter(")content(, )delimiter(")> operator_fat(()(cdr) (pair)operator_fat(\)) (accum)operator_fat(\))operator_fat(\))
        string<delimiter(")delimiter(")>
        (*ports*)operator_fat(\))
      integer(2)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(port) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
          operator_fat(()(filename) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(seek) (port) integer(0) (SEEK_END)operator_fat(\))
      operator_fat(()(print) (filename) string<delimiter(")content(is)delimiter(")> operator_fat(()(number->string) operator_fat(()(ftell) (port)operator_fat(\))operator_fat(\)) string<delimiter(")content(bytes long.)delimiter(")>operator_fat(\))
      operator_fat(()(close-input-port) (port)operator_fat(\)) operator_fat(\))operator_fat(\))
  (*ports*)operator_fat(\))

comment(;; @@PLEAC@@_5.13)
comment(; An association list takes on the size of the number of elements with)
comment(; which it is initialised, so presizing is implicit)

operator_fat(()reserved(define) (*hash*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))         comment(; zero elements)

comment(;; ------------)

operator_fat(()reserved(define) (*hash*)              comment(; three elements)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; A size [i.e. number of entries] must be specified when a hash table)
comment(; is created, so presizing is implicit)

operator_fat(()reserved(define) (*hash*) operator_fat(()(make-hash-table) integer(100)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*hash*) operator_fat(()(make-vector) integer(100) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.14)
operator_fat(()reserved(define) (*array*)
  operator_fat(()(list) operator_fat(')(a) operator_fat(')(b) operator_fat(')(c) operator_fat(')(d) operator_fat(')(d) operator_fat(')(a) operator_fat(')(a) operator_fat(')(c) operator_fat(')(d) operator_fat(')(d) operator_fat(')(e)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*count*) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(value) operator_fat(()(assoc-ref) (*count*) (element)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(not) (value)operator_fat(\)) operator_fat(()reserved(set!) (value) integer(0)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (*count*) operator_fat(()(assoc-set!) (*count*) (element) operator_fat(()(+) integer(1) (value)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*array*)operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) (*count*) operator_fat(()(make-hash-table) integer(20)operator_fat(\))operator_fat(\))

operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(value) operator_fat(()(hash-ref) (*count*) (element)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(if) operator_fat(()(not) (value)operator_fat(\)) operator_fat(()reserved(set!) (value) integer(0)operator_fat(\))operator_fat(\))
      operator_fat(()(hash-set!) (*count*) (element) operator_fat(()(+) integer(1) (value)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*array*)operator_fat(\))

comment(;; @@PLEAC@@_5.15)
operator_fat(()reserved(define) (*father*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()(Cain) operator(.) (Adam)operator_fat(\))
    operator_fat(')operator_fat(()(Abel) operator(.) (Adam)operator_fat(\))
    operator_fat(')operator_fat(()(Seth) operator(.) (Adam)operator_fat(\))
    operator_fat(')operator_fat(()(Enoch) operator(.) (Cain)operator_fat(\))
    operator_fat(')operator_fat(()(Irad) operator(.) (Enoch)operator_fat(\))
    operator_fat(')operator_fat(()(Mehujael) operator(.) (Irad)operator_fat(\))
    operator_fat(')operator_fat(()(Methusael) operator(.) (Mehujael)operator_fat(\))
    operator_fat(')operator_fat(()(Lamech) operator(.) (Methusael)operator_fat(\))
    operator_fat(')operator_fat(()(Jabal) operator(.) (Lamech)operator_fat(\))
    operator_fat(')operator_fat(()(Jubal) operator(.) (Lamech)operator_fat(\))
    operator_fat(')operator_fat(()(Tubalcain) operator(.) (Lamech)operator_fat(\))
    operator_fat(')operator_fat(()(Enos) operator(.) (Seth)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(ice-9) (rdelim)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(port) operator_fat(()(open-input-file) (*filename*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line&terminator) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(eof-object?) operator_fat(()(cdr) (line&terminator)operator_fat(\))operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
      operator_fat(()(else)
        operator_fat(()reserved(let) operator_fat(()operator_fat(()(person) operator_fat(()(string->symbol) operator_fat(()(car) (line&terminator)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(father) operator_fat(()(assoc-ref) (*father*) (person)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()reserved(if) (father)
            operator_fat(()reserved(begin)
              operator_fat(()(print) (father)operator_fat(\))
              operator_fat(()(loop) operator_fat(()(assoc-ref) (*father*) (father)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(close-input-port) (port)operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(ice-9) (rdelim)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(assoc-invert-N:M) (assoc)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(new-assoc) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(pair)operator_fat(\))
        operator_fat(()reserved(let*) operator_fat(()operator_fat(()(old-key) operator_fat(()(car) (pair)operator_fat(\))operator_fat(\))
               operator_fat(()(new-key) operator_fat(()(cdr) (pair)operator_fat(\))operator_fat(\))
               operator_fat(()(new-key-found) operator_fat(()(assoc-ref) (new-assoc) (new-key)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(if) operator_fat(()(not) (new-key-found)operator_fat(\))
            operator_fat(()reserved(set!) (new-assoc) operator_fat(()(acons) (new-key) operator_fat(()(list) (old-key)operator_fat(\)) (new-assoc)operator_fat(\))operator_fat(\)) 
          comment(;else)
            operator_fat(()reserved(set!) (new-assoc) operator_fat(()(assoc-set!) (new-assoc) (new-key) operator_fat(()reserved(cons) (old-key) (new-key-found)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))
      (assoc)operator_fat(\))
  (new-assoc)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*children*) operator_fat(()(assoc-invert-N:M) (*father*)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(port) operator_fat(()(open-input-file) (*filename*)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line&terminator) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(eof-object?) operator_fat(()(cdr) (line&terminator)operator_fat(\))operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
      operator_fat(()(else)
        operator_fat(()reserved(let*) operator_fat(()operator_fat(()(person) operator_fat(()(string->symbol) operator_fat(()(car) (line&terminator)operator_fat(\))operator_fat(\))operator_fat(\))
               operator_fat(()(children-found) operator_fat(()(assoc-ref) (*children*) (person)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(print) operator_fat(()(symbol->string) (person)operator_fat(\)) string<delimiter(")content(begat:)delimiter(")>operator_fat(\))
          operator_fat(()reserved(if) operator_fat(()(not) (children-found)operator_fat(\))
            operator_fat(()(print) string<delimiter(")content(nobody)delimiter(")>operator_fat(\))
          comment(;else)
            operator_fat(()(for-each)
              operator_fat(()reserved(lambda) operator_fat(()(child)operator_fat(\)) operator_fat(()(print) operator_fat(()(symbol->string) (child)operator_fat(\)) string<delimiter(")content(,)delimiter(")>operator_fat(\))operator_fat(\))
              (children-found)operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()(read-line) (port) operator_fat(')(split)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(close-input-port) (port)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_5.16)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_7.0)
comment(;; use (open-input-file filename\) or (open filename O_RDONLY\))

operator_fat(()reserved(define) (input) operator_fat(()(open-input-file) string<delimiter(")content(/usr/local/widgets/data)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (input) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
         operator_fat(()reserved(if) operator_fat(()(string-match) string<delimiter(")content(blue)delimiter(")> (line)operator_fat(\))
           operator_fat(()(display) (line)operator_fat(\))operator_fat(\))
         operator_fat(()(loop) operator_fat(()(read-line) (input) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(close) (input)operator_fat(\))

comment(;; Many I/O functions default to the logical STDIN/OUT)

comment(;; You can also explicitly get the standard ports with)
comment(;; [set-]current-{input,output,error}-port.)

comment(;; format takes a port as the first argument.  If #t is given, format)
comment(;; writes to stdout, if #f is given, format returns a string.)

operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))     comment(; reads from stdin)
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
         operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(string-match) string<delimiter(")content([0-9])delimiter(")> (line)operator_fat(\))operator_fat(\))
           comment(;; writes to stderr)
           operator_fat(()(display) string<delimiter(")content(No digit found.)content(\\n)delimiter(")> operator_fat(()(current-error-port)operator_fat(\))operator_fat(\))
           comment(;; writes to stdout)
           operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Read: ~A)content(\\n)delimiter(")> (line)operator_fat(\))operator_fat(\))
         operator_fat(()(loop) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; use open-output-file)

operator_fat(()reserved(define) (logfile) operator_fat(()(open-output-file) string<delimiter(")content(/tmp/log)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; increasingly specific ways of closing ports (it's safe to close a)
comment(;; closed port\))

operator_fat(()(close) (logfile)operator_fat(\))                comment(; #t)
operator_fat(()(close-port) (logfile)operator_fat(\))           comment(; #f (already closed\))
operator_fat(()(close-output-port) (logfile)operator_fat(\))    comment(; unspecified)

comment(;; you can rebind standard ports with set-current-<foo>-port:)

operator_fat(()reserved(let) operator_fat(()operator_fat(()(old-out) operator_fat(()(current-output-port)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(set-current-output-port) (logfile)operator_fat(\))
  operator_fat(()(display) string<delimiter(")content(Countdown initiated ...)content(\\n)delimiter(")>operator_fat(\))
  operator_fat(()(set-current-output-port) (old-out)operator_fat(\))
  operator_fat(()(display) string<delimiter(")content(You have 30 seconds to reach minimum safety distance.)content(\\n)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; or)

operator_fat(()(with-output-to-file) (logfile)
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(display) string<delimiter(")content(Countdown initiated ...)content(\\n)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(display) string<delimiter(")content(You have 30 seconds to reach minimum safety distance.)content(\\n)delimiter(")>operator_fat(\))


comment(;; @@PLEAC@@_7.1)
operator_fat(()reserved(define) (source) operator_fat(()(open-input-file) (path)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (sink) operator_fat(()(open-output-file) (path)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (source) operator_fat(()(open) (path) (O_RDONLY)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (sink) operator_fat(()(open) (path) (O_WRONLY)operator_fat(\))operator_fat(\))

comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open-input-file) (path)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (port) operator_fat(()(open-file) (path) string<delimiter(")content(r)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) (O_RDONLY)operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open-output-file) (path)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (port) operator_fat(()(open-file) (path) string<delimiter(")content(w)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) operator_fat(()(logior) (O_WRONLY) (O_TRUNC) (O_CREAT)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) operator_fat(()(logior) (O_WRONLY) (O_EXCL) (O_CREAT)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open-file) (path) string<delimiter(")content(a)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) operator_fat(()(logior) (O_WRONLY) (O_APPEND) (O_CREAT)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) operator_fat(()(logior) (O_WRONLY) (O_APPEND)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) (O_RDWR)operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open-file) (path) string<delimiter(")content(r+)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) operator_fat(()(logior) (O_RDWR) (O_CREAT)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;;-----------------------------)
operator_fat(()reserved(define) (port) operator_fat(()(open) (path) operator_fat(()(logior) (O_RDWR) (O_EXCL) (O_CREAT)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;;-----------------------------)

comment(;; @@PLEAC@@_7.2)
comment(;; Nothing different needs to be done with Guile)

comment(;; @@PLEAC@@_7.3)
operator_fat(()reserved(define) (expand-user)
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(rx) operator_fat(()(make-regexp) string<delimiter(")content(^)content(\\\\)content(~([^/]+\)?)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(filename)operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(m) operator_fat(()(regexp-exec) (rx) (filename)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(if) (m)
          operator_fat(()(string-append)
           operator_fat(()reserved(if) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))
             operator_fat(()(passwd:dir) operator_fat(()(getpwnam) operator_fat(()(match:substring) (m) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))
             operator_fat(()reserved(or) operator_fat(()(getenv) string<delimiter(")content(HOME)delimiter(")>operator_fat(\)) operator_fat(()(getenv) string<delimiter(")content(LOGDIR)delimiter(")>operator_fat(\))
                 operator_fat(()(passwd:dir) operator_fat(()(getpwuid) operator_fat(()(cuserid)operator_fat(\))operator_fat(\))operator_fat(\)) string<delimiter(")delimiter(")>operator_fat(\))operator_fat(\))
           operator_fat(()(substring) (filename) operator_fat(()(match:end) (m)operator_fat(\))operator_fat(\))operator_fat(\))
          (filename)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.4)
operator_fat(()reserved(define) (port) operator_fat(()(open-file) (filename) (mode)operator_fat(\))operator_fat(\))  comment(; raise an exception on error)

comment(;; use catch to trap errors)
operator_fat(()(catch) operator_fat(')(system-error) comment(; the type of error thrown)
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()reserved(set!) (port) operator_fat(()(open-file) (filename) (mode)operator_fat(\))operator_fat(\))operator_fat(\)) comment(; thunk to try)
  operator_fat(()reserved(lambda) operator_fat(()(key) operator(.) (args)operator_fat(\))  comment(; exception handler)
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(fmt) operator_fat(()(cadr) (args)operator_fat(\))operator_fat(\))
          operator_fat(()(msg&path) operator_fat(()(caddr) (args)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(format) operator_fat(()(current-error-port)operator_fat(\)) (fmt) operator_fat(()(car) (msg&path)operator_fat(\)) operator_fat(()(cadr) (msg&path)operator_fat(\))operator_fat(\))
      operator_fat(()(newline)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.5)
comment(;; use the POSIX tmpnam)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(name) operator_fat(()(tmpnam)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(call-with-output-file) (name)
    operator_fat(()reserved(lambda) operator_fat(()(port)operator_fat(\))
      comment(;; ... output to port)
      operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; better to test and be sure you have exclusive access to the file)
comment(;; (temp file name will be available as (port-filename port\)\))
operator_fat(()reserved(define) operator_fat(()(open-temp-file)operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(name) operator_fat(()(tmpnam)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(catch) operator_fat(')(system-error)
      operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(open) (name) operator_fat(()(logior) (O_RDWR) (O_CREAT) (O_EXCL)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(lambda) operator_fat(()(key) operator(.) (args)operator_fat(\)) operator_fat(()(loop) operator_fat(()(tmpnam)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or let mkstemp! do the work for you:)
operator_fat(()reserved(define) (port) operator_fat(()(mkstemp!) (template-string-ending-in-XXXXXX)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let*) operator_fat(()operator_fat(()(tmpl) string<delimiter(")content(/tmp/programXXXXXX)delimiter(")>operator_fat(\))
       operator_fat(()(port) operator_fat(()(mkstemp!) (tmpl)operator_fat(\))operator_fat(\))operator_fat(\))
  comment(;; tmpl now contains the name of the temp file,)
  comment(;; e.g. "/tmp/programhVoEzw")
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(=) (i) integer(10)operator_fat(\))operator_fat(\))
    operator_fat(()(format) (port) string<delimiter(")content(~A)content(\\n)delimiter(")> (i)operator_fat(\))operator_fat(\))
  operator_fat(()(seek) (port) integer(0) (SEEK_SET)operator_fat(\))
  operator_fat(()(display) string<delimiter(")content(Tmp file has:)content(\\n)delimiter(")>operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (port) operator_fat(')(concat)operator_fat(\)) operator_fat(()(read-line) (port) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()(display) (line)operator_fat(\))operator_fat(\))
  operator_fat(()(close) (port)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.6)
comment(;; string ports are ideal for this)

operator_fat(()reserved(define) (DATA) string<delimiter(")content(
your data goes here
)delimiter(")>operator_fat(\))

operator_fat(()(call-with-input-string)
 (DATA)
 operator_fat(()reserved(lambda) operator_fat(()(port)operator_fat(\))
   comment(;; ... process input from port)
   operator_fat(\))operator_fat(\))

comment(;; or)

operator_fat(()(with-input-from-string) (DATA)
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
    comment(;; ... stdin now comes from DATA)
    operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.7)
comment(;; to process lines of current-input-port:)
operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
  comment(;; ... do something with line)
  operator_fat(\))

comment(;; a general filter template:)

operator_fat(()reserved(define) operator_fat(()(body)operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()(display) (line)operator_fat(\))
    operator_fat(()(newline)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  comment(;; ... handle options here)
  operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\))
    operator_fat(()(body)operator_fat(\))     comment(; no args, just call body on stdin)
    operator_fat(()(for-each)  comment(; otherwise, call body with stdin set to each arg in turn)
     operator_fat(()reserved(lambda) operator_fat(()(file)operator_fat(\))
       operator_fat(()(catch) operator_fat(')(system-error)
         operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
           operator_fat(()(with-input-from-file) (file)
             (body)operator_fat(\))operator_fat(\))
         operator_fat(()reserved(lambda) operator_fat(()(key) operator(.) (args)operator_fat(\))
           operator_fat(()(format) operator_fat(()(current-error-port)operator_fat(\)) operator_fat(()(cadr) (args)operator_fat(\)) operator_fat(()(caaddr) (args)operator_fat(\))
                   operator_fat(()(car) operator_fat(()(cdaddr) (args)operator_fat(\))operator_fat(\))operator_fat(\))
           operator_fat(()(newline) operator_fat(()(current-error-port)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
     (args)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; example: count-chunks:)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-1)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(ice-9) (format)operator_fat(\)) operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\))

comment(;; also use directory-files from 9.5 and globbing functions from 9.6)

comment(;; can use (ice-9 getopt-long\) described in chapter 15, or process)
comment(;; options by hand)
operator_fat(()reserved(define) (opt-append) integer(0)operator_fat(\))
operator_fat(()reserved(define) (opt-ignore-ints) integer(0)operator_fat(\))
operator_fat(()reserved(define) (opt-nostdout) integer(0)operator_fat(\))
operator_fat(()reserved(define) (opt-unbuffer) integer(0)operator_fat(\))

operator_fat(()reserved(define) (args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(do) operator_fat(()operator_fat(()(opts) (args) operator_fat(()(cdr) (opts)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()reserved(or) operator_fat(()(null?) (opts)operator_fat(\)) operator_fat(()(not) operator_fat(()(eq?) operator_fat(()(string-ref) operator_fat(()(car) (opts)operator_fat(\)) integer(0)operator_fat(\)) char(#\\-)operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()reserved(set!) (args) (opts)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(opt) operator_fat(()(car) (opts)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(string=?) (opt) string<delimiter(")content(-a)delimiter(")>operator_fat(\)) operator_fat(()reserved(set!) (opt-append) operator_fat(()integer(1)(+) (opt-append)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(string=?) (opt) string<delimiter(")content(-i)delimiter(")>operator_fat(\)) operator_fat(()reserved(set!) (opt-ignore-ints) operator_fat(()integer(1)(+) (opt-ignore-ints)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(string=?) (opt) string<delimiter(")content(-n)delimiter(")>operator_fat(\)) operator_fat(()reserved(set!) (opt-nostdout) operator_fat(()integer(1)(+) (opt-nostdout)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(string=?) (opt) string<delimiter(")content(-u)delimiter(")>operator_fat(\)) operator_fat(()reserved(set!) (opt-unbuffer) operator_fat(()integer(1)(+) (opt-unbuffer)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(else) operator_fat(()(throw) operator_fat(')(usage-error) string<delimiter(")content(Unexpected argument: ~A)delimiter(")> (opt)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; default to all C source files)
operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\)) operator_fat(()reserved(set!) (args) operator_fat(()(glob) string<delimiter(")content(*.[Cch])delimiter(")> string<delimiter(")content(.)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(find-login)operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(string-match) string<delimiter(")content(login)delimiter(")> (line)operator_fat(\))
           operator_fat(()(display) (line)operator_fat(\))
           operator_fat(()(newline)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(lowercase)operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()(display) operator_fat(()(string-downcase) (line)operator_fat(\))operator_fat(\))
    operator_fat(()(newline)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(count-chunks)operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))
       operator_fat(()(chunks) integer(0)operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()reserved(or) operator_fat(()(eof-object?) (line)operator_fat(\))
           operator_fat(()(string=?) (line) string<delimiter(")content(__DATA__)delimiter(")>operator_fat(\)) operator_fat(()(string=?) (line) string<delimiter(")content(__END__)delimiter(")>operator_fat(\))operator_fat(\))
       operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Found ~A chunks)content(\\n)delimiter(")> (chunks)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(tokens)
           operator_fat(()(string-tokenize) operator_fat(()(string-take) (line) operator_fat(()reserved(or) operator_fat(()(string-index) (line) char(#\\#)operator_fat(\))
                                                  operator_fat(()(string-length) (line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(set!) (chunks) operator_fat(()(+) (chunks) operator_fat(()(length) (tokens)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\))
  operator_fat(()(count-chunks)operator_fat(\))     comment(; or find-login, lowercase, etc.)
  operator_fat(()(for-each)
   operator_fat(()reserved(lambda) operator_fat(()(file)operator_fat(\))
     operator_fat(()(catch) operator_fat(')(system-error)
       operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
         operator_fat(()(with-input-from-file) (file)
           (count-chunks)operator_fat(\))operator_fat(\))
       operator_fat(()reserved(lambda) operator_fat(()(key) operator(.) (args)operator_fat(\))
         operator_fat(()(format) operator_fat(()(current-error-port)operator_fat(\)) operator_fat(()(cadr) (args)operator_fat(\)) operator_fat(()(caaddr) (args)operator_fat(\))
                 operator_fat(()(car) operator_fat(()(cdaddr) (args)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(newline) operator_fat(()(current-error-port)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
   (args)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.8)
comment(;; write changes to a temporary file then rename it)
operator_fat(()(with-input-from-file) (old)
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
    operator_fat(()(with-output-to-file) (new)
      operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
        operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
          comment(;; change line, then...)
          operator_fat(()(write-line) (line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(rename-file) (old) operator_fat(()(string-append) (old) string<delimiter(")content(.orig)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()(rename-file) (new) (old)operator_fat(\))

comment(;; @@PLEAC@@_7.9)
comment(;; no -i switch)

comment(;; @@PLEAC@@_7.10)
comment(;; open the file in read/write mode, slurp up the contents, modify it,)
comment(;; then write it back out:)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(p) operator_fat(()(open-file) (file) string<delimiter(")content(r+)delimiter(")>operator_fat(\))operator_fat(\))
      operator_fat(()(lines) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
  comment(;; read in lines)
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\)) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(set!) (lines) operator_fat(()reserved(cons) (line) (lines)operator_fat(\))operator_fat(\))operator_fat(\))
  comment(;; modify (reverse lines\))
  operator_fat(()(seek) (p) integer(0) (SEEK_SET)operator_fat(\))
  comment(;; write out lines)
  operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(write-line) (x) (p)operator_fat(\))operator_fat(\)) (lines)operator_fat(\))
  comment(;; truncate the file)
  operator_fat(()(truncate-file) (p)operator_fat(\))
  operator_fat(()(close) (p)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(p) operator_fat(()(open-file) string<delimiter(")content(foo)delimiter(")> string<delimiter(")content(r+)delimiter(")>operator_fat(\))operator_fat(\))
      operator_fat(()(lines) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
      operator_fat(()(date) operator_fat(()(date->string) operator_fat(()(current-date)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\)) operator_fat(()(read-line) (p) operator_fat(')(concat)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(set!) (lines) operator_fat(()reserved(cons) (line) (lines)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(seek) (p) integer(0) (SEEK_SET)operator_fat(\))
  operator_fat(()(for-each)
   operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\))
     operator_fat(()(regexp-substitute/global) (p) string<delimiter(")content(DATE)delimiter(")> (x) operator_fat(')(pre) (date) operator_fat(')(post)operator_fat(\))operator_fat(\))
   operator_fat(()(reverse) (lines)operator_fat(\))operator_fat(\))
  operator_fat(()(truncate-file) (p)operator_fat(\))
  operator_fat(()(close) (p)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.11)
operator_fat(()reserved(define) (p) operator_fat(()(open-file) (path) string<delimiter(")content(r+)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()(flock) (p) (LOCK_EX)operator_fat(\))
comment(;; update the file, then...)
operator_fat(()(close) (p)operator_fat(\))

comment(;; to increment a number in a file)
operator_fat(()reserved(define) (p) operator_fat(()(open) string<delimiter(")content(numfile)delimiter(")> operator_fat(()(logior) (O_RDWR) (O_CREAT)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(flock) (p) (LOCK_EX)operator_fat(\))
comment(;; Now we have acquired the lock, it's safe for I/O)
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(obj) operator_fat(()(read) (p)operator_fat(\))operator_fat(\))
       operator_fat(()(num) operator_fat(()reserved(if) operator_fat(()(eof-object?) (obj)operator_fat(\)) integer(0) (obj)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(seek) (p) integer(0) (SEEK_SET)operator_fat(\))
  operator_fat(()(truncate-file) (p)operator_fat(\))
  operator_fat(()(write) operator_fat(()integer(1)(+) (num)operator_fat(\)) (p)operator_fat(\))
  operator_fat(()(newline) (p)operator_fat(\))operator_fat(\))
operator_fat(()(close) (p)operator_fat(\))

comment(;; @@PLEAC@@_7.12)
comment(;; use force-output)
operator_fat(()(force-output) (p)operator_fat(\))

comment(;; flush all open ports)
operator_fat(()(flush-all-ports)operator_fat(\))

comment(;; @@PLEAC@@_7.13)
comment(;; use select)
operator_fat(()(select) (inputs) (outputs) (exceptions) (seconds)operator_fat(\))
operator_fat(()(select) operator_fat(()(list) (p1) (p2) (p3)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

operator_fat(()reserved(let*) operator_fat(()operator_fat(()(nfound) operator_fat(()(select) operator_fat(()(list) (inport)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
       operator_fat(()(inputs) operator_fat(()(car) (nfound)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(null?) (inputs)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (inport)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(format) pre_constant(#t) string<delimiter(")content(I read ~A)content(\\n)delimiter(")> (line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or use char-ready? if you only need a single character)
operator_fat(()reserved(if) operator_fat(()(char-ready?) (p)operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(I read ~A)content(\\n)delimiter(")> operator_fat(()(read-char) (p)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.14)
comment(;; use the O_NONBLOCK option with open)
operator_fat(()reserved(define) (modem) operator_fat(()(open) string<delimiter(")content(/dev/cua0)delimiter(")> operator_fat(()(logior) (O_RDWR) (O_NONBLOCK)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or use fcntl if you already have a port)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(flags) operator_fat(()(fcntl) (p) (F_GETFD)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(fcntl) (p) (F_SETFD) operator_fat(()(logior) (flags) (O_NONBLOCK)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.15)
comment(;; use stat)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(buf) operator_fat(()(make-string) operator_fat(()(stat:size) operator_fat(()(stat) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(read-string!/partial) (buf) (input)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.16)
comment(;; not needed - ports are first class objects)

comment(;; @@PLEAC@@_7.18)
comment(;; use for-each on the list of ports:)
operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\)) operator_fat(()(display) (stuff-to-print) (p)operator_fat(\))operator_fat(\)) (port-list)operator_fat(\))

comment(;; or, if you don't want to keep track of the port list and know you)
comment(;; want to print to all open output ports, you can use port-for-each:)
operator_fat(()(port-for-each) operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\)) operator_fat(()reserved(if) operator_fat(()(output-port?) (p)operator_fat(\)) operator_fat(()(display) (stuff) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_7.19)
comment(;; use fdopen:)
operator_fat(()reserved(define) (p) operator_fat(()(fdopen) (num) (mode)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (p) operator_fat(()(fdopen) integer(3) string<delimiter(")content(r)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (p) operator_fat(()(fdopen) operator_fat(()(string->number) operator_fat(()(getenv) string<delimiter(")content(MHCONTEXTFD)delimiter(")>operator_fat(\))operator_fat(\)) string<delimiter(")content(r)delimiter(")>operator_fat(\))operator_fat(\))
comment(;; after processing)
operator_fat(()(close) (p)operator_fat(\))

comment(;; @@PLEAC@@_7.20)
comment(;; ports are first class objects and can be aliased and passed around)
comment(;; like any other non-immediate variables:)
operator_fat(()reserved(define) (alias) (original)operator_fat(\))
operator_fat(()reserved(define) (old-in) operator_fat(()(current-input-port)operator_fat(\))operator_fat(\))

comment(;; or you can open two separate ports on the same file:)
operator_fat(()reserved(define) (p1) operator_fat(()(open-input-file) (path)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (p2) operator_fat(()(open-input-file) (path)operator_fat(\))operator_fat(\))

comment(;; or use fdopen:)
operator_fat(()reserved(define) (copy-of-p) operator_fat(()(fdopen) operator_fat(()(fileno) (p)operator_fat(\)) (mode)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (old-out) operator_fat(()(current-output-port)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (old-err) operator_fat(()(current-error-port)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (new-out) operator_fat(()(open-output-file) string<delimiter(")content(/tmp/program.out)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()(set-current-output-port) (new-out)operator_fat(\))
operator_fat(()(set-current-error-port) (new-out)operator_fat(\))

operator_fat(()(system) (joe-random-program)operator_fat(\))

operator_fat(()(close) (new-out)operator_fat(\))

operator_fat(()(set-current-output-port) (old-out)operator_fat(\))
operator_fat(()(set-current-error-port) (old-out)operator_fat(\))

comment(;; @@PLEAC@@_8.0)
comment(;; open the file and loop through the port with read-line:)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(p) operator_fat(()(open-input-file) (file)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\)) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
    operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A)content(\\n)delimiter(")> operator_fat(()(string-length) (line)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(close) (p)operator_fat(\))operator_fat(\))

comment(;; you can use with-input-from-file to temporarily rebind stdin:)
operator_fat(()(with-input-from-file) (file)
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
    operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
      operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A)content(\\n)delimiter(")> operator_fat(()(string-length) (line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or define a utility procedure to do this)
operator_fat(()reserved(define) operator_fat(()(for-each-line) (proc) (file)operator_fat(\))
  operator_fat(()(with-input-from-file) (file)
    operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
      operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
        operator_fat(()(proc) (line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(for-each-line) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A)content(\\n)delimiter(")> operator_fat(()(string-length) (line)operator_fat(\))operator_fat(\))operator_fat(\)) (file)operator_fat(\))

comment(;; read in the file as a list of lines)
operator_fat(()reserved(define) operator_fat(()(read-lines) (file)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(ls) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(with-input-from-file) (file)
      operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
        operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\)) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
          operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) (line) (ls)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(reverse) (ls)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; read in the file as a single string)
operator_fat(()reserved(define) operator_fat(()(file-contents) (file)operator_fat(\))
  operator_fat(()(call-with-input-file) (file)
    operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\))
      operator_fat(()reserved(let*) operator_fat(()operator_fat(()(size) operator_fat(()(stat:size) operator_fat(()(stat) (p)operator_fat(\))operator_fat(\))operator_fat(\))
             operator_fat(()(buf) operator_fat(()(make-string) (size)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()(read-string!/partial) (buf) (p)operator_fat(\))
        (buf)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; use display to print human readable output)
operator_fat(()(display) operator_fat(')operator_fat(()string<delimiter(")content(One)delimiter(")> string<delimiter(")content(two)delimiter(")> string<delimiter(")content(three)delimiter(")>operator_fat(\)) (port)operator_fat(\))  comment(; (One two three\))
operator_fat(()(display) string<delimiter(")content(Baa baa black sheep.)content(\\n)delimiter(")>operator_fat(\))     comment(; Sent to default output port)

comment(;; use write to print machine readable output)
operator_fat(()(write) operator_fat(')operator_fat(()string<delimiter(")content(One)delimiter(")> string<delimiter(")content(two)delimiter(")> string<delimiter(")content(three)delimiter(")>operator_fat(\)) (port)operator_fat(\))    comment(; ("One" "two" "three"\))

comment(;; use (ice-9 rw\) to read/write fixed-length blocks of data:)
operator_fat(()(use-modules) operator_fat(()(ice-9) (rw)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(buffer) operator_fat(()(make-string) integer(4096)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(read-string!/partial) (buffer) (port) integer(4096)operator_fat(\))operator_fat(\))

comment(;; truncate-file)
operator_fat(()(truncate-file) (port) (length)operator_fat(\))  comment(; truncate to length)
operator_fat(()(truncate-file) (port)operator_fat(\))         comment(; truncate to current pos)

comment(;; ftell)
operator_fat(()reserved(define) (pos) operator_fat(()(ftell) (port)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(I'm ~A bytes from the start of DATAFILE.)content(\\n)delimiter(")> (pos)operator_fat(\))

comment(;; seek)
operator_fat(()(seek) (log-port) integer(0) (SEEK_END)operator_fat(\))      comment(; seek to end)
operator_fat(()(seek) (data-port) (pos) (SEEK_SET)operator_fat(\))   comment(; seek to pos)
operator_fat(()(seek) (out-port) (-)integer(20) (SEEK_CUR)operator_fat(\))    comment(; seek back 20 bytes)

comment(;; block read/write)
operator_fat(()(use-modules) operator_fat(()(ice-9) (rw)operator_fat(\))operator_fat(\))
operator_fat(()(write-string/partial) (mystring) (data-port) operator_fat(()(string-length) (mystring)operator_fat(\))operator_fat(\))
operator_fat(()(read-string!/partial) (block) integer(256) integer(5)operator_fat(\))

comment(;; @@PLEAC@@_8.1)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(rx) operator_fat(()(make-regexp) string<delimiter(")content((.*\))content(\\\\)content(\\\\)content($)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\)) comment(; or "(.*\)\\\\\\\\\\\\s*$")
  operator_fat(()(with-input-from-file) (file)
    operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
      operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
          operator_fat(()reserved(let) operator_fat(()operator_fat(()(m) operator_fat(()(regexp-exec) (rx) (line)operator_fat(\))operator_fat(\))
                operator_fat(()(next) operator_fat(()(read-line)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()reserved(cond) operator_fat(()operator_fat(()reserved(and) (m) operator_fat(()(not) operator_fat(()(eof-object?) (next)operator_fat(\))operator_fat(\))operator_fat(\))
                   operator_fat(()(loop) operator_fat(()(string-append) operator_fat(()(match:substring) (m) integer(1)operator_fat(\)) (next)operator_fat(\))operator_fat(\))operator_fat(\))
                  operator_fat(()(else)
                   comment(;; else process line here, then recurse)
                   operator_fat(()(loop) (next)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.2)
operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\)) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))
     operator_fat(()(i) integer(0) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\)) (i)operator_fat(\))operator_fat(\))

comment(;; fastest way if your terminator is a single newline)
operator_fat(()(use-modules) operator_fat(()(ice-9) (rw)operator_fat(\)) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(buf) operator_fat(()(make-string) operator_fat(()(expt) integer(2) integer(16)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(count) integer(0)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(do) operator_fat(()operator_fat(()(len) operator_fat(()(read-string!/partial) (buf) (p)operator_fat(\)) operator_fat(()(read-string!/partial) (buf) (p)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()operator_fat(()(not) (len)operator_fat(\)) (count)operator_fat(\))
    operator_fat(()reserved(set!) (count) operator_fat(()(+) (count) operator_fat(()(string-count) (buf) char(#\\newline) integer(0) (len)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or use port-line)
operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(eof-object?) (line)operator_fat(\)) operator_fat(()(port-line) (p)operator_fat(\)) operator_fat(()(loop) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.3)
comment(;; default behaviour of string-tokenize is to split on whitespace:)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) (eof-object?) (line)operator_fat(\))
         operator_fat(()(for-each) (some-function-of-word) operator_fat(()(string-tokenize) (line)operator_fat(\))operator_fat(\))
         operator_fat(()(loop) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(table) operator_fat(()(make-hash-table) integer(31)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
           operator_fat(()(for-each)
            operator_fat(()reserved(lambda) operator_fat(()(w)operator_fat(\)) operator_fat(()(hash-set!) (table) (w) operator_fat(()integer(1)(+) operator_fat(()(hash-ref) (table) (w) integer(0)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()(string-tokenize) (line)operator_fat(\))operator_fat(\))
           operator_fat(()(loop) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(hash-fold) operator_fat(()reserved(lambda) operator_fat(()(k) (v) (p)operator_fat(\)) operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~5D ~A)content(\\n)delimiter(")> (v) (k)operator_fat(\))operator_fat(\)) pre_constant(#f) (table)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.4)
comment(;; build up the list the reverse it or fold over it:)
operator_fat(()reserved(define) (lines) operator_fat(()(read-lines) (file)operator_fat(\))operator_fat(\))
operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(word)operator_fat(\)) (do-something-with-word)operator_fat(\)) operator_fat(()(reverse) (lines)operator_fat(\))operator_fat(\))
operator_fat(()(fold) operator_fat(()reserved(lambda) operator_fat(()(word) (acc)operator_fat(\)) (do-something-with-word)operator_fat(\)) pre_constant(#f) (lines)operator_fat(\))

comment(;; @@PLEAC@@_8.5)
comment(;; save the current position and reseek to it)
operator_fat(()reserved(define) operator_fat(()(tail) (file)operator_fat(\))
  operator_fat(()(call-with-input-file) (file)
    operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\))
      operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(cond) operator_fat(()operator_fat(()(eof-object?) (line)operator_fat(\))
               operator_fat(()(sleep) (sometime)operator_fat(\))
               operator_fat(()reserved(let) operator_fat(()operator_fat(()(pos) operator_fat(()(ftell) (p)operator_fat(\))operator_fat(\))operator_fat(\))
                 operator_fat(()(seek) (p) integer(0) (SEEK_SET)operator_fat(\))
                 operator_fat(()(seek) (p) (pos) (SEEK_SET)operator_fat(\))operator_fat(\))operator_fat(\))
              operator_fat(()(else)
               comment(;; process line)
               operator_fat(\))operator_fat(\))
        operator_fat(()(loop) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.6)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(rand-line) pre_constant(#f)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(eof-object?) (line)operator_fat(\))operator_fat(\))
           operator_fat(()reserved(if) operator_fat(()(=) integer(0) operator_fat(()(random) operator_fat(()(port-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
             operator_fat(()reserved(set!) (rand-line) (line)operator_fat(\))operator_fat(\))
           operator_fat(()(loop) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  comment(;; rand-line is the random line)
  operator_fat(\))

comment(;; @@PLEAC@@_8.7)
operator_fat(()reserved(define) operator_fat(()(shuffle) (list)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(v) operator_fat(()(list->vector) (list)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) operator_fat(()integer(1)(-) operator_fat(()(vector-length) (v)operator_fat(\))operator_fat(\)) operator_fat(()integer(1)(-) (i)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(<) (i) integer(0)operator_fat(\)) operator_fat(()(vector->list) (v)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(j) operator_fat(()(random) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(=) (i) (j)operator_fat(\))operator_fat(\))
               operator_fat(()reserved(let) operator_fat(()operator_fat(()(temp) operator_fat(()(vector-ref) (v) (i)operator_fat(\))operator_fat(\))operator_fat(\))
                 operator_fat(()(vector-set!) (v) (i) operator_fat(()(vector-ref) (v) (j)operator_fat(\))operator_fat(\))
                 operator_fat(()(vector-set!) (v) (j) (temp)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (rand-lines) operator_fat(()(shuffle) operator_fat(()(read-lines) (file)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.8)
comment(;; looking for line number desired-line-number)
operator_fat(()reserved(do) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\)) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(=) operator_fat(()operator_fat(()(port-line) (p)operator_fat(\)) (desired-line-number)operator_fat(\)) (line)operator_fat(\))operator_fat(\))operator_fat(\))
comment(;; or read into a list)
operator_fat(()reserved(define) (lines) operator_fat(()(read-lines) (file)operator_fat(\))operator_fat(\))
operator_fat(()(list-ref) (lines) (desired-line-number)operator_fat(\))

comment(;; @@INCOMPLETE@@)
comment(; (define (build-index data-file index-file\))
comment(;   \))

comment(; (define (line-with-index data-file index-file line-number\))
comment(;   \))

comment(;; @@PLEAC@@_8.9)
comment(;; use string-tokenize with an appropriate character set)
operator_fat(()(use-modules) operator_fat(()(srfi) (srfi-13)operator_fat(\)) operator_fat(()(srfi) (srfi-14)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (fields) operator_fat(()(string-tokenize) (line) operator_fat(()(string->charset) string<delimiter(")content(+-)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (fields) operator_fat(()(string-tokenize) (line) operator_fat(()(string->charset) string<delimiter(")content(:)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (fields) operator_fat(()(string-tokenize) (line)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.10)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(p) operator_fat(()(open-file) (file) string<delimiter(")content(r+)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(pos) integer(0)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(line) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(cond) operator_fat(()operator_fat(()(eof-object?) operator_fat(()(peek-char) (p)operator_fat(\))operator_fat(\))
             operator_fat(()(seek) (p) integer(0) (SEEK_SET)operator_fat(\))
             operator_fat(()(truncate-file) (p) (pos)operator_fat(\))
             operator_fat(()(close) (p)operator_fat(\))operator_fat(\))
            operator_fat(()(else)
             operator_fat(()reserved(set!) (pos) operator_fat(()(ftell) (p)operator_fat(\))operator_fat(\))
             operator_fat(()(loop) operator_fat(()(read-line) (p)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_8.11)
comment(;; no equivalent - don't know how Guile under windows handles this)

comment(;; @@PLEAC@@_8.12)
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(address) operator_fat(()(*) (recsize) (recno)operator_fat(\))operator_fat(\))
       operator_fat(()(buf) operator_fat(()(make-string) (recsize)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(seek) (p) (address) (SEEK_SET)operator_fat(\))
  operator_fat(()(read-string!/partial) (buf) (p)operator_fat(\))
  (buf)operator_fat(\))

comment(;; @@PLEAC@@_8.13)
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(address) operator_fat(()(*) (recsize) (recno)operator_fat(\))operator_fat(\))
       operator_fat(()(buf) operator_fat(()(make-string) (recsize)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(seek) (p) (address) (SEEK_SET)operator_fat(\))
  operator_fat(()(read-string!/partial) (buf) (p)operator_fat(\))
  comment(;; modify buf, then write back with)
  operator_fat(()(seek) (p) (address) (SEEK_SET)operator_fat(\))
  operator_fat(()(write-string/partial) (buf) (p)operator_fat(\))
  operator_fat(()(close) (p)operator_fat(\))operator_fat(\))

comment(;; @@INCOMPLETE@@)
comment(;; weekearly)

comment(;; @@PLEAC@@_8.14)
operator_fat(()(seek) (p) (addr) (SEEK_SET)operator_fat(\))
operator_fat(()reserved(define) (str) operator_fat(()(read-delimited) operator_fat(()(make-string) integer(1) char(#\\n)(ul)operator_fat(\)) (p)operator_fat(\))operator_fat(\))

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; bgets -- get a string from an address in a binary file)
operator_fat(()(use-modules) operator_fat(()(ice-9) (format)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (file) operator_fat(()(car) (args)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (addrs) operator_fat(()(map) (string->number) operator_fat(()(cdr) (args)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (delims) operator_fat(()(make-string) integer(1) char(#\\n)(ul)operator_fat(\))operator_fat(\))

operator_fat(()(call-with-input-file) (file)
  operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\))
    operator_fat(()(for-each)
     operator_fat(()reserved(lambda) operator_fat(()(addr)operator_fat(\))
       operator_fat(()(seek) (p) (addr) (SEEK_SET)operator_fat(\))
       operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~X ~O ~D ~S)content(\\n)delimiter(")> (addr) (addr) (addr)
               operator_fat(()(read-delimited) (delims) (p)operator_fat(\))operator_fat(\))operator_fat(\))
     (addrs)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@INCOMPLETE@@)
comment(;; strings)

comment(;; @@PLEAC@@_9.0)
operator_fat(()reserved(define) (entry) operator_fat(()(stat) string<delimiter(")content(/usr/bin/vi)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (entry) operator_fat(()(stat) string<delimiter(")content(/usr/bin)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (entry) operator_fat(()(stat) (port)operator_fat(\))operator_fat(\))

operator_fat(()(use-modules) operator_fat(()(ice-9) (posix)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (inode) operator_fat(()(stat) string<delimiter(")content(/usr/bin/vi)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (ctime) operator_fat(()(stat:ctime) (inode)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (size) operator_fat(()(stat:size) (inode)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (F) operator_fat(()(open-input-file) (filename)operator_fat(\))operator_fat(\))
comment(;; no equivalent - what defines -T?)
comment(; unless (-s F && -T _\) {)
comment(;     die "$filename doesn't have text in it.\\n";)
comment(; })

operator_fat(()reserved(define) (dir) operator_fat(()(opendir) string<delimiter(")content(/usr/bin)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(do) operator_fat(()operator_fat(()(filename) operator_fat(()(readdir) (dir)operator_fat(\)) operator_fat(()(readdir) (dir)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(eof-object?) (filename)operator_fat(\))operator_fat(\))
  operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Inside /usr/bin is something called ~A)content(\\n)delimiter(")> (filename)operator_fat(\))operator_fat(\))
operator_fat(()(closedir) (dir)operator_fat(\))

comment(;; @@PLEAC@@_9.1)
operator_fat(()reserved(define) (inode) operator_fat(()(stat) (filename)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (readtime) operator_fat(()(stat:atime) (inode)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (writetime) operator_fat(()(stat:mtime) (inode)operator_fat(\))operator_fat(\))

operator_fat(()(utime) (newreadtime) (newwritetime) (filename)operator_fat(\))

operator_fat(()reserved(define) (seconds-per-day) operator_fat(()(*) integer(60) integer(60) integer(24)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (inode) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (atime) operator_fat(()(stat:atime) (inode)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (mtime) operator_fat(()(stat:mtime) (inode)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (atime) operator_fat(()(-) (atime) operator_fat(()(*) integer(7) (seconds-per-day)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) (mtime) operator_fat(()(-) (mtime) operator_fat(()(*) integer(7) (seconds-per-day)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(utime) (file) (atime) (mtime)operator_fat(\))

comment(;; mtime is optional)
operator_fat(()(utime) (file) operator_fat(()(current-time)operator_fat(\))operator_fat(\))
operator_fat(()(utime) (file) operator_fat(()(stat:atime) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\)) operator_fat(()(current-time)operator_fat(\))operator_fat(\))

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; uvi - vi a file without changing its access times)

operator_fat(()reserved(define) (file) operator_fat(()(cadr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (inode) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (atime) operator_fat(()(stat:atime) (inode)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (mtime) operator_fat(()(stat:mtime) (inode)operator_fat(\))operator_fat(\))
operator_fat(()(system) operator_fat(()(string-append) operator_fat(()reserved(or) operator_fat(()(getenv) string<delimiter(")content(EDITOR)delimiter(")>operator_fat(\))  string<delimiter(")content(vi)delimiter(")>operator_fat(\)) string<delimiter(")content( )delimiter(")> (file)operator_fat(\))operator_fat(\))
operator_fat(()(utime) (file) (atime) (mtime)operator_fat(\))

comment(;; @@PLEAC@@_9.2)
operator_fat(()(delete-file) (file)operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(count) integer(0)operator_fat(\))operator_fat(\))
  operator_fat(()(for-each)
   operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\))
     operator_fat(()(catch) pre_constant(#t)
       operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(delete-file) (x)operator_fat(\)) operator_fat(()reserved(set!) (count) operator_fat(()integer(1)(+) (count)operator_fat(\))operator_fat(\))operator_fat(\))
       operator_fat(()reserved(lambda) operator_fat(()(err) operator(.) (args)operator_fat(\)) pre_constant(#f)operator_fat(\))operator_fat(\))operator_fat(\))
   (file-list)operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(=) (count) operator_fat(()(length) (file-list)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(format) operator_fat(()(current-error-port)operator_fat(\)) string<delimiter(")content(could only delete ~A of ~A files)delimiter(")>
            (count) operator_fat(()(length) (file-list)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_9.3)
comment(;; use builtin copy-file)
operator_fat(()(copy-file) (oldfile) (newfile)operator_fat(\))
operator_fat(()(rename-file) (oldfile) (newfile)operator_fat(\))

comment(;; or do it by hand (clumsy, error-prone\))
operator_fat(()(use-modules) operator_fat(()(ice-9) (rw)operator_fat(\)) operator_fat(()(ice-9) (posix)operator_fat(\))operator_fat(\))
operator_fat(()(with-input-from-file) (oldfile)
  operator_fat(()reserved(lambda) operator_fat(()operator_fat(\))
    operator_fat(()(call-with-output-file) (newfile)
      operator_fat(()reserved(lambda) operator_fat(()(p)operator_fat(\))
        operator_fat(()reserved(let*) operator_fat(()operator_fat(()(inode) operator_fat(()(stat) (oldfile)operator_fat(\))operator_fat(\))
               operator_fat(()(blksize) operator_fat(()reserved(if) (inode) operator_fat(()(stat:size) (inode)operator_fat(\)) integer(16384)operator_fat(\))operator_fat(\))
               operator_fat(()(buf) operator_fat(()(make-string) (blksize)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(len) operator_fat(()(read-string!/partial) (buf)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()reserved(cond) operator_fat(()operator_fat(()reserved(and) (len) operator_fat(()(>) (len) integer(0)operator_fat(\))operator_fat(\))
                   operator_fat(()(write-string/partial) (buf) (p) integer(0) (len)operator_fat(\))
                   operator_fat(()(loop) operator_fat(()(read-string!/partial) (buf)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or call out to the system (non-portable, insecure\))
operator_fat(()(system) operator_fat(()(string-append) string<delimiter(")content(cp )delimiter(")> (oldfile) string<delimiter(")content( )delimiter(")> (newfile)operator_fat(\))operator_fat(\))    comment(; unix)
operator_fat(()(system) operator_fat(()(string-append) string<delimiter(")content(copy )delimiter(")> (oldfile) string<delimiter(")content( )delimiter(")> (newfile)operator_fat(\))operator_fat(\))  comment(; dos, vms)

comment(;; @@PLEAC@@_9.4)
comment(;; use a hash lookup of inodes)
operator_fat(()(use-modules) operator_fat(()(ice-9) (posix)operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(seen) operator_fat(()(make-hash-table) integer(31)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(for-each)
   operator_fat(()reserved(lambda) operator_fat(()(file)operator_fat(\))
     operator_fat(()reserved(let*) operator_fat(()operator_fat(()(stats) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\))
            operator_fat(()(key) operator_fat(()reserved(cons) operator_fat(()(stat:dev) (stats)operator_fat(\)) operator_fat(()(stat:ino) (stats)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()(val) operator_fat(()(hash-ref) (seen) (key) integer(0)operator_fat(\))operator_fat(\))operator_fat(\))
       operator_fat(()reserved(cond) operator_fat(()operator_fat(()(=) (val) integer(0)operator_fat(\))
              comment(;; do something with new file)
              operator_fat(\))operator_fat(\))
       operator_fat(()(hash-set!) (seen) (key) operator_fat(()integer(1)(+) (val)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
   (file-names)operator_fat(\))operator_fat(\))

operator_fat(()reserved(let) operator_fat(()operator_fat(()(seen) operator_fat(()(make-hash-table) integer(31)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(for-each)
   operator_fat(()reserved(lambda) operator_fat(()(file)operator_fat(\))
     operator_fat(()reserved(let*) operator_fat(()operator_fat(()(stats) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\))
            operator_fat(()(key) operator_fat(()reserved(cons) operator_fat(()(stat:dev) (stats)operator_fat(\)) operator_fat(()(stat:ino) (stats)operator_fat(\))operator_fat(\))operator_fat(\))
            operator_fat(()(val) operator_fat(()(hash-ref) (seen) (key) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
       operator_fat(()(hash-set!) (seen) (key) operator_fat(()reserved(cons) (file) (val)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
   (file-names)operator_fat(\))
  operator_fat(()(hash-fold)
   operator_fat(()reserved(lambda) operator_fat(()(key) (value) (prior)operator_fat(\))
     comment(;; process key == (dev . inode\), value == list of filenames)
     operator_fat(\))
   operator_fat(')operator_fat(()operator_fat(\)) (seen)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_9.5)
comment(;; use opendir, readdir, closedir)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(p) operator_fat(()(opendir) (dir)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(file) operator_fat(()(readdir) (p)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(eof-object?) (file)operator_fat(\))
      operator_fat(()(close) (p)operator_fat(\))
      comment(;; do something with file)
      operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; or define a utility function for this)
operator_fat(()reserved(define) operator_fat(()(directory-files) (dir)operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(access?) (dir) (R_OK)operator_fat(\))operator_fat(\))
    operator_fat(')operator_fat(()operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(p) operator_fat(()(opendir) (dir)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()reserved(do) operator_fat(()operator_fat(()(file) operator_fat(()(readdir) (p)operator_fat(\)) operator_fat(()(readdir) (p)operator_fat(\))operator_fat(\))
           operator_fat(()(ls) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()(eof-object?) (file)operator_fat(\)) operator_fat(()(closedir) (p)operator_fat(\)) operator_fat(()(reverse!) (ls)operator_fat(\))operator_fat(\))
        operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) (file) (ls)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; to skip . and ..)
operator_fat(()(cddr) operator_fat(()(directory-files) (dir)operator_fat(\))operator_fat(\))

comment(;; probably better to implement full Emacs style directory-files)
operator_fat(()(use-modules) operator_fat(()(ice-9) (posix)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (plain-files)
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(rx) operator_fat(()(make-regexp) string<delimiter(")content(^)content(\\\\)content(.)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(lambda) operator_fat(()(dir)operator_fat(\))
      operator_fat(()(sort) operator_fat(()(filter) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(eq?) operator_fat(')(regular) operator_fat(()(stat:type) operator_fat(()(stat) (x)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
                    operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(string-append) (dir) string<delimiter(")content(/)delimiter(")> (x)operator_fat(\))operator_fat(\))
                         operator_fat(()(remove) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(regexp-exec) (rx) (x)operator_fat(\))operator_fat(\))
                                 operator_fat(()(cddr) operator_fat(()(directory-files) (dir)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
            (string<)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_9.6)
operator_fat(()reserved(define) operator_fat(()(glob->regexp) (pat)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(len) operator_fat(()(string-length) (pat)operator_fat(\))operator_fat(\))
        operator_fat(()(ls) operator_fat(')operator_fat(()string<delimiter(")content(^)delimiter(")>operator_fat(\))operator_fat(\))
        operator_fat(()(in-brace?) pre_constant(#f)operator_fat(\))operator_fat(\))
    operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(0) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(=) (i) (len)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(char) operator_fat(()(string-ref) (pat) (i)operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(case) (char)
          operator_fat(()operator_fat(()char(#\\*)operator_fat(\)) operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) string<delimiter(")content([^.]*)delimiter(")> (ls)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()char(#\\?)operator_fat(\)) operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) string<delimiter(")content([^.])delimiter(")> (ls)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()char(#\\[)operator_fat(\)) operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) string<delimiter(")content([)delimiter(")> (ls)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()char(#\\])operator_fat(\)) operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) string<delimiter(")content(])delimiter(")> (ls)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()operator_fat(()char(#\\\\)operator_fat(\))
           operator_fat(()reserved(set!) (i) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))
           operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) operator_fat(()(make-string) integer(1) operator_fat(()(string-ref) (pat) (i)operator_fat(\))operator_fat(\)) (ls)operator_fat(\))operator_fat(\))
           operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) string<delimiter(")content(\\\\)delimiter(")> (ls)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(else)
           operator_fat(()reserved(set!) (ls) operator_fat(()reserved(cons) operator_fat(()(regexp-quote) operator_fat(()(make-string) integer(1) (char)operator_fat(\))operator_fat(\)) (ls)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(string-concatenate) operator_fat(()(reverse) operator_fat(()reserved(cons) string<delimiter(")content($)delimiter(")> (ls)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(glob) (pat) (dir)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(rx) operator_fat(()(make-regexp) operator_fat(()(glob->regexp) (pat)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(filter) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(regexp-exec) (rx) (x)operator_fat(\))operator_fat(\)) operator_fat(()(directory-files) (dir)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (files) operator_fat(()(glob) string<delimiter(")content(*.c)delimiter(")> string<delimiter(")content(.)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (files) operator_fat(()(glob) string<delimiter(")content(*.[ch])delimiter(")> string<delimiter(")content(.)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; Not sure if the Schwartzian Transform would really be more)
comment(;; efficient here... perhaps with a much larger directory where very)
comment(;; few files matched.)
operator_fat(()reserved(define) (dirs) operator_fat(()(filter)
              operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(eq?) operator_fat(')(directory) operator_fat(()(stat:type) operator_fat(()(stat) (x)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
              operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(string-append) (dir) string<delimiter(")content(/)delimiter(")> (x)operator_fat(\))operator_fat(\))
                   operator_fat(()(sort) operator_fat(()(filter) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(string-match) string<delimiter(")content(^[0-9]+$)delimiter(")> (x)operator_fat(\))operator_fat(\))
                                 operator_fat(()(directory-files) (dir)operator_fat(\))operator_fat(\))
                         operator_fat(()reserved(lambda) operator_fat(()(a) (b)operator_fat(\))
                           operator_fat(()(<) operator_fat(()(string->number) (a)operator_fat(\)) operator_fat(()(string->number) (b)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_9.7)
operator_fat(()reserved(define) operator_fat(()(find) (proc) operator(.) (dirs)operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(pair?) (dirs)operator_fat(\))
         operator_fat(()(for-each) (proc) operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(string-append) operator_fat(()(car) (dirs)operator_fat(\)) string<delimiter(")content(/)delimiter(")> (x)operator_fat(\))operator_fat(\))
                             operator_fat(()(directory-files) operator_fat(()(car) (dirs)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(apply) (find) (proc) operator_fat(()(cdr) (dirs)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(find) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A~A)content(\\n)delimiter(")> (x)
                          operator_fat(()reserved(if) operator_fat(()(equal?) operator_fat(()(stat:type) operator_fat(()(stat) (x)operator_fat(\))operator_fat(\)) operator_fat(')(directory)operator_fat(\))
                            string<delimiter(")content(/)delimiter(")> string<delimiter(")delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\)) string<delimiter(")content(.)delimiter(")>operator_fat(\))

operator_fat(()reserved(define) (saved-size) (-)integer(1)operator_fat(\))
operator_fat(()reserved(define) (saved-name) string<delimiter(")delimiter(")>operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(biggest) (file)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(stats) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(if) operator_fat(()(eq?) operator_fat(()(stat:type) (stats)operator_fat(\)) operator_fat(')(regular)operator_fat(\))
      operator_fat(()reserved(let) operator_fat(()operator_fat(()(size) operator_fat(()(stat:size) operator_fat(()(stat) (file)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
        operator_fat(()reserved(cond) operator_fat(()operator_fat(()(>) (size) (saved-size)operator_fat(\))
               operator_fat(()reserved(set!) (saved-size) (size)operator_fat(\))
               operator_fat(()reserved(set!) (saved-name) (file)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(apply) (find) (biggest) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Biggest file ~A in ~A is ~A bytes long.)content(\\n)delimiter(")>
        (saved-name) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\)) (saved-size)operator_fat(\))

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; fdirs - find all directories)
operator_fat(()reserved(define) operator_fat(()(print-dirs) (f)operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(eq?) operator_fat(()(stat:type) operator_fat(()(stat) (f)operator_fat(\))operator_fat(\)) operator_fat(')(directory)operator_fat(\))
    operator_fat(()(write-line) (f)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(apply) (find) (print-dirs) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_9.8)
error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; rmtree - remove whole directory trees like rm -f)
operator_fat(()reserved(define) operator_fat(()(finddepth) (proc) operator(.) (dirs)operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(pair?) (dirs)operator_fat(\))
         operator_fat(()(apply) (finddepth) (proc) operator_fat(()(cdr) (dirs)operator_fat(\))operator_fat(\))
         operator_fat(()(for-each) (proc) operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(x)operator_fat(\)) operator_fat(()(string-append) operator_fat(()(car) (dirs)operator_fat(\)) string<delimiter(")content(/)delimiter(")> (x)operator_fat(\))operator_fat(\))
                             operator_fat(()(directory-files) operator_fat(()(car) (dirs)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(zap) (f)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(rm) operator_fat(()reserved(if) operator_fat(()(eq?) operator_fat(()(stat:type) operator_fat(()(stat) (f)operator_fat(\))operator_fat(\)) operator_fat(')(directory)operator_fat(\)) (rmdir) (delete-file)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(format) pre_constant(#t) string<delimiter(")content(deleting ~A)content(\\n)delimiter(")> (f)operator_fat(\))
    operator_fat(()(catch) pre_constant(#t)
      operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(rm) (f)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(lambda) (args) operator_fat(()(format) pre_constant(#t) string<delimiter(")content(couldn't delete ~A)content(\\n)delimiter(")> (f)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(let) operator_fat(()operator_fat(()(args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\))
    operator_fat(()(error) string<delimiter(")content(usage: rmtree dir ..)content(\\n)delimiter(")>operator_fat(\))
    operator_fat(()(apply) (finddepth) (zap) (args)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_9.9)
operator_fat(()(for-each)
 operator_fat(()reserved(lambda) operator_fat(()(file)operator_fat(\))
   operator_fat(()reserved(let) operator_fat(()operator_fat(()(newname) operator_fat(()(function-of) (file)operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()(catch) pre_constant(#t)
       operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(rename-file) (file) (newname)operator_fat(\))operator_fat(\))
       operator_fat(()reserved(lambda) (args) operator_fat(()(format) operator_fat(()(current-error-port)operator_fat(\))
                            string<delimiter(")content(couldn't rename ~A to ~A)content(\\n)delimiter(")> (file) (newname)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
 (names)operator_fat(\))

error(#)(!/usr/local/bin/guile) (-)(s)
(!)error(#)
comment(;; rename - Guile's filename fixer)
operator_fat(()(use-modules) operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\)) comment(; not needed, but often useful here)
operator_fat(()reserved(define) (args) operator_fat(()(cdr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\)) operator_fat(()(error) string<delimiter(")content(usage: rename expr [files])content(\\n)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (proc) operator_fat(()(eval-string) operator_fat(()(car) (args)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(for-each)
 operator_fat(()reserved(lambda) operator_fat(()(old)operator_fat(\))
   operator_fat(()reserved(let) operator_fat(()operator_fat(()(new) operator_fat(()(proc) (old)operator_fat(\))operator_fat(\))operator_fat(\))
     operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(string=?) (old) (new)operator_fat(\))operator_fat(\))
       operator_fat(()(catch) pre_constant(#t)
         operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(rename-file) (old) (new)operator_fat(\))operator_fat(\))
         operator_fat(()reserved(lambda) (args) operator_fat(()(format) operator_fat(()(current-error-port)operator_fat(\))
                              string<delimiter(")content(couldn't rename ~A to ~A)content(\\n)delimiter(")> (old) (new)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
 operator_fat(()(cdr) (args)operator_fat(\))operator_fat(\))

comment(;; command-line examples:)
comment(;; rename '(lambda (x\) (regexp-substitute/global #f "\\\\.orig\\$" x (quote pre\)\)\)' *.orig)
comment(;; rename string-downcase *)
comment(;; rename '(lambda (x\) (if (string-match "^Make" x\) x (string-downcase x\)\)\)' *)
comment(;; rename '(lambda (x\) (string-append x ".bad"\)\)' *.pl)
comment(;; rename '(lambda (x\) (format #t "~a: "\) (read-line\)\)' *)

comment(;; @@PLEAC@@_9.10)
operator_fat(()reserved(define) (base) operator_fat(()(basename) (path)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (base) operator_fat(()(dirname) (path) (ext)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (dir) operator_fat(()(dirname) (path)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (path) string<delimiter(")content(/usr/lib/libc.a)delimiter(")>operator_fat(\))
operator_fat(()reserved(define) (file) operator_fat(()(basename) (path)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (dir) operator_fat(()(dirname) (path)operator_fat(\))operator_fat(\))

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(dir is ~A, file is ~A)content(\\n)delimiter(")> (dir) (file)operator_fat(\))

operator_fat(()(basename) (path) string<delimiter(")content(.a)delimiter(")>operator_fat(\)) comment(; libc)

operator_fat(()(use-modules) operator_fat(()(ice-9) (regex)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(file-parse) (path) operator(.) (args)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(ext) operator_fat(()reserved(if) operator_fat(()(null?) (args)operator_fat(\)) string<delimiter(")content(\\\\)content(..*)delimiter(")> operator_fat(()(car) (args)operator_fat(\))operator_fat(\))operator_fat(\))
         operator_fat(()(rx1) operator_fat(()(string-append) string<delimiter(")content(^((.*\)/\)?(.*\)?()delimiter(")> (ext) string<delimiter(")content(\)$)delimiter(")>operator_fat(\))operator_fat(\))
         operator_fat(()(rx2) operator_fat(()(string-append) string<delimiter(")content(^((.*\)/\)?(.*\)?(\)$)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(m) operator_fat(()reserved(or) operator_fat(()(string-match) (rx1) (path)operator_fat(\)) operator_fat(()(string-match) (rx2) (path)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(list) operator_fat(()(match:substring) (m) integer(2)operator_fat(\)) operator_fat(()(match:substring) (m) integer(3)operator_fat(\))
            operator_fat(()(match:substring) (m) integer(4)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(extension) (path) operator(.) (args)operator_fat(\))
  operator_fat(()(caddr) operator_fat(()(apply) (file-parse) (path) (args)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.0)
comment(; Note: Some of the examples will show code blocks in this style:)
comment(;)
comment(;  (define)
comment(;    ... code here ...)
comment(;  \))
comment(;)
comment(; This is not generally considered good style, and is not recommended;)
comment(; it is only used here to more clearly highlight block scope )

comment(; By convention a 'global variable' i.e. a variable that is defined at)
comment(; the top-level, and as such, visible within any scope, is named with)
comment(; beginning and ending asterisks [and one to be used as a constant)
comment(; with beginning and ending plus signs])

operator_fat(()reserved(define) (*greeted*) integer(0)operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(hello)operator_fat(\))
  operator_fat(()reserved(set!) (*greeted*) operator_fat(()(+) (*greeted*) integer(1)operator_fat(\))operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(hi there!, this procedure has been called)delimiter(")> (*greeted*) string<delimiter(")content(times)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(how-many-greetings)operator_fat(\)) (*greeted*)operator_fat(\))

comment(;; ------------)

operator_fat(()(hello)operator_fat(\))

operator_fat(()reserved(define) (*greetings*) operator_fat(()(how-many-greetings)operator_fat(\))operator_fat(\))

operator_fat(()(print) string<delimiter(")content(bye there!, there have been)delimiter(")> (*greetings*) string<delimiter(")content(greetings so far)delimiter(")>operator_fat(\))

comment(;; @@PLEAC@@_10.1)
comment(; Subroutine parameters are named [whether directly, or indirectly in)
comment(; the case of variable arguments - see next example]; this is the only)
comment(; means of access [This contrasts with languages like Perl and REXX which)
comment(; allow access to arguments via array subscripting, and function calls,)
comment(; respectively])
operator_fat(()reserved(define) operator_fat(()(hypotenuse) (side1) (side2)operator_fat(\))
  operator_fat(()(sqrt) operator_fat(()(sum) operator_fat(()(*) (side1) (side1)operator_fat(\)) operator_fat(()(*) (side2) (side2)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*diag*) operator_fat(()(hypotenuse) integer(3) integer(4)operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; 'other-sides' is the name of a list of containing any additional)
comment(; parameters. Note that a name is still used to access values)
operator_fat(()reserved(define) operator_fat(()(hypotenuse) (side1) operator(.) (other-sides)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(all-sides) operator_fat(()reserved(cons) (side1) (other-sides)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(for-each)
      operator_fat(()reserved(lambda) operator_fat(()(side)operator_fat(\)) (...)operator_fat(\))
      (all-sides)operator_fat(\))
  (...)operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*diag*) operator_fat(()(hypotenuse) integer(3) integer(4)operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; Possible to pack parameters into a single structure [e.g. list or)
comment(; array], and access values contained therein)
operator_fat(()reserved(define) operator_fat(()(hypotenuse) (sides)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(side1) operator_fat(()(car) (sides)operator_fat(\))operator_fat(\)) operator_fat(()(side2) operator_fat(()(caar) (sides)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(sqrt) operator_fat(()(sum) operator_fat(()(*) (side1) (side1)operator_fat(\)) operator_fat(()(*) (side2) (side2)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*args*) operator_fat(')operator_fat(()integer(3) integer(4)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*diag*) operator_fat(()(hypotenuse) (*args*)operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; Parameters passed by reference, however, whether original object is)
comment(; modified depends on choice of functions used to manipulate them)
comment(; [most functions create copies and return these; mutating versions of)
comment(; same functions may also exist [see next example] )
operator_fat(()reserved(define) (*nums*) operator_fat(()(vector) integer(1.4) integer(3.5) integer(6.7)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(int-all) (vec)operator_fat(\))
  operator_fat(()(vector-map-in-order)
    operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\)) operator_fat(()(inexact->exact) operator_fat(()(round) (element)operator_fat(\))operator_fat(\))operator_fat(\))
    (vec)operator_fat(\))operator_fat(\))

comment(; Copy created)
operator_fat(()reserved(define) (*ints*) operator_fat(()(int-all) (*nums*)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*nums*)operator_fat(\))
operator_fat(()(print) (*ints*)operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*nums*) operator_fat(()(vector) integer(1.4) integer(3.5) integer(6.7)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(trunc-all) (vec)operator_fat(\))
  operator_fat(()(array-map-in-order!)
    operator_fat(()reserved(lambda) operator_fat(()(element)operator_fat(\)) operator_fat(()(inexact->exact) operator_fat(()(round) (element)operator_fat(\))operator_fat(\))operator_fat(\))
    (vec)operator_fat(\))operator_fat(\))

comment(; Original modified)
operator_fat(()(trunc-all) (*nums*)operator_fat(\))

comment(;; @@PLEAC@@_10.2)
comment(; Scheme is lexically-scoped; variables defined within a block are)
comment(; visible only within that block. Whilst nested / subordinate blocks)
comment(; have access to those variables, neither the caller, nor any called)
comment(; procedures have direct access to those same variables)

operator_fat(()reserved(define) operator_fat(()(some-func) (parm1) (parm2) (parm3)operator_fat(\))
  (...) (paramaters) (visible) (here) (...)

  operator_fat(()reserved(let) operator_fat(()operator_fat(()(var1) (...)operator_fat(\)) operator_fat(()(var2) (...)operator_fat(\)) operator_fat(()(var3) (...)operator_fat(\)) (...)operator_fat(\))
    (...) (parameters) (also) (visible) (here)error(,) (but) (variables)error(,) operator_fat(')(var1)operator_fat(') (etc)
        (only) (visible) (within) (this) (block) (...)
  operator_fat(\))
  (...) (paramaters) (also) (visible) (here)error(,) (but) (still) (within) (procedure) (body) (...)
operator_fat(\))

comment(;; ------------)

comment(; Top-level definitions - accessable globally )
operator_fat(()reserved(define) (*name*) operator_fat(()(caar) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*age*) operator_fat(()(cadr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*start*) operator_fat(()(fetch-time)operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; Lexical binding - accessable only within this block)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(name) operator_fat(()(caar) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(age) operator_fat(()(cadr) operator_fat(()(command-line)operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(start) operator_fat(()(fetch-time)operator_fat(\))operator_fat(\))operator_fat(\))
   (...) (variables) (only) (visible) (here) (...)
operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) (*pair*) operator_fat(')operator_fat(()integer(1) operator(.) integer(2)operator_fat(\))operator_fat(\))

comment(; 'a' and 'b' need to be dereferenced and separately defined [Also,)
comment(; since globally defined, should really be named, '*a*', '*b*', etc])
operator_fat(()reserved(define) (a) operator_fat(()(car) (*pair*)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (b) operator_fat(()(cdr) (*pair*)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (c) operator_fat(()(fetch-time)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(run-check)operator_fat(\))
  (...) reserved(do) (something) (with) operator_fat(')(a)operator_fat(')error(,) operator_fat(')(b)operator_fat(')error(,) reserved(and) operator_fat(')(c)operator_fat(') (...)
operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(check-x) (x) (y)operator_fat(\))
  operator_fat(()reserved(if) operator_fat(()(run-check)operator_fat(\))
    operator_fat(()(print) string<delimiter(")content(got)delimiter(")> (x)operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Calling 'check-x'; 'run-check' has access to 'a', 'b', and 'c')
operator_fat(()(check-x) (...)operator_fat(\))

comment(;; ----)

comment(; If defined within a block, variables 'a', 'b', and 'c' are no longer)
comment(; accessable anywhere except that scope. Therefore, 'run-check' as)
comment(; defined above can no longer access these variables [in fact, the code)
comment(; will fail because variables 'a', 'b', and 'c' do not exist when)
comment(; 'run-check' is defined])
operator_fat(()reserved(let) operator_fat(()operator_fat(()(a) operator_fat(()(car) (*pair*)operator_fat(\))operator_fat(\))
      operator_fat(()(b) operator_fat(()(cdr) (*pair*)operator_fat(\))operator_fat(\))
      operator_fat(()(c) operator_fat(()(fetch-time)operator_fat(\))operator_fat(\))operator_fat(\))
   (...)
   operator_fat(()(check-x) (...)operator_fat(\))  
   (...)
operator_fat(\))

comment(;; ----)

comment(; The procedures, 'run-check' and 'check-x' are defined within the)
comment(; same block as variables, 'a', 'b', and 'c', so have direct access to)
comment(; them)
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(a) operator_fat(()(car) (*pair*)operator_fat(\))operator_fat(\))
       operator_fat(()(b) operator_fat(()(cdr) (*pair*)operator_fat(\))operator_fat(\))
       operator_fat(()(c) operator_fat(()(fetch-time)operator_fat(\))operator_fat(\))

       operator_fat(()(run-check)
         operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) (...) reserved(do) (something) (with) operator_fat(')(a)operator_fat(')error(,) operator_fat(')(b)operator_fat(')error(,) reserved(and) operator_fat(')(c)operator_fat(') (...)operator_fat(\))operator_fat(\))

       operator_fat(()(check-x)
         operator_fat(()reserved(lambda) operator_fat(()(x) (y)operator_fat(\))
           operator_fat(()reserved(if) operator_fat(()(run-check)operator_fat(\))
             operator_fat(()(print) string<delimiter(")content(got)delimiter(")> (x)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))
   (...)
   operator_fat(()(check-x) (...)operator_fat(\))  
   (...)
operator_fat(\))

comment(;; @@PLEAC@@_10.3)
comment(; Ordinarily, a variable must be initialised when it is defined,)
comment(; whether at the top-level: )
operator_fat(()reserved(define) (*variable*) integer(1)operator_fat(\))

comment(; ... or within a 'let' binding)
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(variable) integer(1)operator_fat(\))
       operator_fat(()(mysub)
         operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) (...) (accessing) operator_fat(')(variable)operator_fat(') (...)operator_fat(\))operator_fat(\))operator_fat(\))
  (...) reserved(do) (stuff) (...)
operator_fat(\))

comment(; However, since Scheme allows syntactic extensions via 'macros' [of)
comment(; which there are two varieties: hygenic and LISP-based], it is)
comment(; possible to create new forms which alter this behaviour. For example,)
comment(; in this tutorial: http://home.comcast.net/~prunesquallor/macro.txt)
comment(; there is a macro implementation equivalent to 'let, 'called,)
comment(; 'bind-values', which allows variables to be defined without initial)
comment(; values; an example follows:)

comment(; Initialisation values for 'a' and 'b' not specified)
operator_fat(()(bind-values) operator_fat(()operator_fat(()(a)operator_fat(\)) (b) operator_fat(()(c) operator_fat(()(+) (*global*) integer(5)operator_fat(\))operator_fat(\))operator_fat(\))
  (...) reserved(do) (stuff) (...)
operator_fat(\))

comment(; In Scheme many things are possible, but not all those things are)
comment(; offered as standard features :\) !)

comment(;; ------------)

operator_fat(()reserved(let*) operator_fat(()operator_fat(()(counter) integer(42)operator_fat(\))
       operator_fat(()(next-counter)
         operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()reserved(set!) (counter) operator_fat(()(+) (counter) integer(1)operator_fat(\))operator_fat(\)) (counter)operator_fat(\))operator_fat(\))
       operator_fat(()(prev-counter)
         operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()reserved(set!) (counter) operator_fat(()(-) (counter) integer(1)operator_fat(\))operator_fat(\)) (counter)operator_fat(\))operator_fat(\))operator_fat(\))

  (...) reserved(do) (stuff) (with) operator_fat(')(next-counter)operator_fat(') reserved(and) operator_fat(')(prev-counter)operator_fat(') (...)
operator_fat(\))

comment(;; ----)

comment(; A more complete, and practical, variation of the above code:)

comment(; 'counter' constructor)
operator_fat(()reserved(define) operator_fat(()(make-counter) (start)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(counter) integer(42)operator_fat(\))
         operator_fat(()(next-counter)
           operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()reserved(set!) (counter) operator_fat(()(+) (counter) integer(1)operator_fat(\))operator_fat(\)) (counter)operator_fat(\))operator_fat(\))
         operator_fat(()(prev-counter)
           operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()reserved(set!) (counter) operator_fat(()(-) (counter) integer(1)operator_fat(\))operator_fat(\)) (counter)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()reserved(lambda) operator_fat(()(op)operator_fat(\))
    operator_fat(()reserved(cond)
      operator_fat(()operator_fat(()(eq?) (op) operator_fat(')(prev)operator_fat(\)) (prev-counter)operator_fat(\))
      operator_fat(()operator_fat(()(eq?) (op) operator_fat(')(next)operator_fat(\)) (next-counter)operator_fat(\))
      operator_fat(()(else) operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(display) string<delimiter(")content(error:counter)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Interface functions to 'counter' functionality)
operator_fat(()reserved(define) operator_fat(()(prev-counter) (counter)operator_fat(\)) operator_fat(()(apply) operator_fat(()(counter) operator_fat(')(prev)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(next-counter) (counter)operator_fat(\)) operator_fat(()(apply) operator_fat(()(counter) operator_fat(')(next)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Create a 'counter')
operator_fat(()reserved(define) (*counter*) operator_fat(()(make-counter) integer(42)operator_fat(\))operator_fat(\))

comment(; Use the 'counter' ...)
operator_fat(()(print) operator_fat(()(prev-counter) (*counter*)operator_fat(\))operator_fat(\))
operator_fat(()(print) operator_fat(()(prev-counter) (*counter*)operator_fat(\))operator_fat(\))
operator_fat(()(print) operator_fat(()(next-counter) (*counter*)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.4)
comment(; Scheme interpreters generally provide a rich collection of procedure)
comment(; metadata, as well as easy access to a program's current 'execution)
comment(; state'. Put simply, provision of a powerful, highly customisable)
comment(; debugging / tracing facility is almost taken for granted. However, using)
comment(; it to perform as trivial a task as obtaining the current function name)
comment(; is less than trivial [at least it seems so in Guile] as it appears to)
comment(; require quite some setup work. Additionally, the documentation talks)
comment(; about facilities e.g. trap installation, that don't appear to be)
comment(; available [at least, I couldn't find them].)
comment(;)
comment(; Example below uses in-built debugging facilities to dump a backtrace)
comment(; to a string port and extract the caller's name from the resulting)
comment(; string. Not exactly elegant ...)

comment(; Execute using: guile --debug ... else no useful output seen)
operator_fat(()(use-modules) operator_fat(()(ice-9) (debug)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(child) (num)operator_fat(\))
  comment(; Create stack [i.e. activation record] object, discarding)
  comment(; irrelevant frames)
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(s) operator_fat(()(make-stack) pre_constant(#t) integer(3) integer(1)operator_fat(\))operator_fat(\))
        operator_fat(()(trace-string-port) operator_fat(()(open-output-string)operator_fat(\))operator_fat(\))
        operator_fat(()(parent-name) string<delimiter(")delimiter(")>operator_fat(\))operator_fat(\))

    comment(; Dump backtrace to string port)
    operator_fat(()(display-backtrace) (s) (trace-string-port)operator_fat(\))

    comment(; Extract caller's name from backtrace data)
    comment(; [shamefully crude - don't do this at home !])
    operator_fat(()reserved(set!) (parent-name)
      operator_fat(()(caddr) operator_fat(()(string-tokenize)
               operator_fat(()(cadr) operator_fat(()(string-split)
                       operator_fat(()(get-output-string) (trace-string-port)operator_fat(\))
                       char(#\\newline)operator_fat(\))operator_fat(\))
               (char-set:graphic)operator_fat(\))operator_fat(\))operator_fat(\))

    comment(; Who's your daddy ?)
    operator_fat(()(print) (parent-name)operator_fat(\))operator_fat(\))operator_fat(\))

comment(; Each invocation of 'child' should see 'parent' displayed as)
comment(; the caller)
operator_fat(()reserved(define) operator_fat(()(parent)operator_fat(\))
  operator_fat(()(child) integer(1)operator_fat(\))
  operator_fat(()(child) integer(2)operator_fat(\))
  operator_fat(()(child) integer(3)operator_fat(\))operator_fat(\))

operator_fat(()(parent)operator_fat(\)) 

comment(;; @@PLEAC@@_10.5)
comment(; Procedure parameters are references to entities, so there is no special)
comment(; treatment required. If an argument represents a mutable object such)
comment(; as an array, then care should be taken to not mutate the object within)
comment(; the procedure, or a copy of the object be made and used)

operator_fat(()(array-diff) (*array1*) (*array2*)operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) operator_fat(()(add-vector-pair) (x) (y)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(vector-length) operator_fat(()(vector-length) (x)operator_fat(\))operator_fat(\))
         operator_fat(()(new-vec) operator_fat(()(make-vector) (vector-length)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(let) (loop) operator_fat(()operator_fat(()(i) integer(0)operator_fat(\))operator_fat(\))
      operator_fat(()reserved(cond) 
        operator_fat(()operator_fat(()(=) (i) (vector-length)operator_fat(\)) (new-vec)operator_fat(\))
        operator_fat(()(else)
          operator_fat(()(vector-set!) (new-vec) (i) operator_fat(()(+) operator_fat(()(vector-ref) (x) (i)operator_fat(\)) operator_fat(()(vector-ref) (y) (i)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(()(loop) operator_fat(()(+) (i) integer(1)operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(define) (*a*) operator_fat(')operator_fat(#()integer(1) integer(2)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (*b*) operator_fat(')operator_fat(#()integer(5) integer(8)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (*c*) operator_fat(()(add-vector-pair) (*a*) (*b*)operator_fat(\))operator_fat(\))

operator_fat(()(print) (*c*)operator_fat(\))

comment(;; ----)

  (...)

  operator_fat(()reserved(if) operator_fat(()reserved(and) operator_fat(()(vector?) (a1)operator_fat(\)) operator_fat(()(vector?) (a2)operator_fat(\))operator_fat(\))
    operator_fat(()(print) operator_fat(()(add-vector-pair) (a1) (a2)operator_fat(\))operator_fat(\))
  comment(;else)
    operator_fat(()(print) string<delimiter(")content(usage: add-vector-pair a1 a2)delimiter(")>operator_fat(\))operator_fat(\))

  (...)

comment(;; @@PLEAC@@_10.6)
comment(; AFAIK there is no Scheme equivalent to Perl's 'return context' where)
comment(; it is possible to use language primitives [e.g. 'wantarray'] to )
comment(; dynamically specify the return type of a procedure. It is, however,)
comment(; possible to:)
comment(; * Return one of several types from a procedure, whether based on )
comment(;   processing results [e.g. 'false' on error, numeric on success], or)
comment(;   perhaps specified via control argument)
comment(; * Check procedure return type and take appropriate action)

operator_fat(()reserved(define) operator_fat(()(my-sub)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(datatype) operator_fat(()(vector) operator_fat(')operator_fat(()operator_fat(\)) integer(7) operator_fat(')operator_fat(()integer(1) integer(2) integer(3)operator_fat(\)) string<delimiter(")content(abc)delimiter(")> operator_fat(')(sym)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(vector-ref) (datatype) operator_fat(()(random) operator_fat(()(vector-length) (datatype)operator_fat(\))operator_fat(\))operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; ----)

comment(; '*result*' is bound to a randomly chosen datatype)
operator_fat(()reserved(define) (*result*) operator_fat(()(my-sub)operator_fat(\))operator_fat(\))

operator_fat(()reserved(cond)
  comment(; It is common to return an empty list to represent 'void')
  operator_fat(()operator_fat(()(null?) (*result*)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(void context)delimiter(")>operator_fat(\))operator_fat(\))

  operator_fat(()operator_fat(()(list?) (*result*)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(list context)delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()operator_fat(()(number?) (*result*)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(scalar context)delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()operator_fat(()(string?) (*result*)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(string context)delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()operator_fat(()(symbol?) (*result*)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(atom context)delimiter(")>operator_fat(\))operator_fat(\))
  operator_fat(()(else) operator_fat(()(print) string<delimiter(")content(Unknown type)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.7)
comment(; Keyword parameters are fully supported. Note that pairs have)
comment(; replaced Perl strings in the examples since they are easier to)
comment(; manipulate)

operator_fat(()(use-modules) operator_fat(()(ice-9) (optargs)operator_fat(\))operator_fat(\))

operator_fat(()(define*) operator_fat(()(the-func) error(#)(:key) operator_fat(()(increment) operator_fat(()reserved(cons) integer(10) operator_fat(')(s)operator_fat(\))operator_fat(\))
                         operator_fat(()(finish) operator_fat(()reserved(cons) integer(0) operator_fat(')(m)operator_fat(\))operator_fat(\))
                         operator_fat(()(start) operator_fat(()reserved(cons) integer(0) operator_fat(')(m)operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(print) (increment)operator_fat(\))
  operator_fat(()(print) (finish)operator_fat(\))
  operator_fat(()(print) (start)operator_fat(\))operator_fat(\))

operator_fat(()(the-func)operator_fat(\))
operator_fat(()(the-func) error(#)(:increment) operator_fat(()reserved(cons) integer(20) operator_fat(')(s)operator_fat(\)) error(#)(:start) operator_fat(()reserved(cons) integer(5) operator_fat(')(m)operator_fat(\)) error(#)(:finish) operator_fat(()reserved(cons) integer(30) operator_fat(')(m)operator_fat(\))operator_fat(\))
operator_fat(()(the-func) error(#)(:start) operator_fat(()reserved(cons) integer(5) operator_fat(')(m)operator_fat(\)) error(#)(:finish) operator_fat(()reserved(cons) integer(30) operator_fat(')(m)operator_fat(\))operator_fat(\))
operator_fat(()(the-func) error(#)(:finish) operator_fat(()reserved(cons) integer(30) operator_fat(')(m)operator_fat(\))operator_fat(\))
operator_fat(()(the-func) error(#)(:start) operator_fat(()reserved(cons) integer(5) operator_fat(')(m)operator_fat(\)) error(#)(:increment) operator_fat(()reserved(cons) integer(20) operator_fat(')(s)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.8)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_10.9)
comment(; The return of multiple values, whether arrays or other items, may be )
comment(; achieved via:)
comment(; * Packaging return items as a single list, structure or array, an)
comment(;   approach which is usable across many languages, though can be)
comment(;   clunky because the procedure caller must manually extract all)
comment(;   items)
comment(; * The 'values' procedure, a more Schemish idiom, is usually used in)
comment(;   conjunction with the 'call-with-values' procedure [the former combines)
comment(;   multiple values, the latter captures and cleanly extracts them]. It)
comment(;   comes into its own, however, when used to create a 'macro' [an)
comment(;   extension to the Scheme language] like 'let-values', a variation of)
comment(;   the 'let' form that allows multiple return values to be placed directly)
comment(;   into separate variables. Implementation shown here is from 'The)
comment(;   Scheme Programming Language, 3rd Edition' by R. Kent Dybvig, though)
comment(;   there exists a more standard implementation in SRFI-11. There is also)
comment(;   the 'receive' functionality accessable via: (use-modules (ice-9 receive\)\))

comment(; [1] Implementation of 'somefunc' returning muliple values via packaging)
comment(; items within a list that is returned)
operator_fat(()reserved(define) operator_fat(()(somefunc)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(a) operator_fat(()(make-vector) integer(5)operator_fat(\))operator_fat(\))
        operator_fat(()(h) operator_fat(()(make-hash-table) integer(5)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(list) (a) (h)operator_fat(\)) operator_fat(\))operator_fat(\))

comment(; Retrieving procedure values requires that the return list be captured)
comment(; and each contained item separately extracted ['let*' used in place of)
comment(; 'let' to ensure correct retrieval order])
operator_fat(()reserved(let*) operator_fat(()operator_fat(()(return-list) operator_fat(()(somefunc)operator_fat(\))operator_fat(\))
       operator_fat(()(a) operator_fat(()(car) (return-list)operator_fat(\))operator_fat(\))
       operator_fat(()(b) operator_fat(()(cadr) (return-list)operator_fat(\))operator_fat(\))operator_fat(\))

  (...) reserved(do) (something) (with) operator_fat(')(a)operator_fat(') reserved(and) operator_fat(')(b)operator_fat(') (...)operator_fat(\))

comment(;; ----------------------------)

comment(; [2] Implementation of 'somefunc' returning muliple values using the)
comment(; 'values' procedure )

operator_fat(()(use-syntax) operator_fat(()(ice-9) (syncase)operator_fat(\))operator_fat(\)) 

comment(; 'let-values' from: http://www.scheme.com/tspl3/syntax.html#fullletvalues)
operator_fat(()reserved(define-syntax) (let-values)
  operator_fat(()(syntax-rules) operator_fat(()operator_fat(\))
    operator_fat(()operator_fat(()(_) operator_fat(()operator_fat(\)) (f1) (f2) (...)operator_fat(\)) operator_fat(()reserved(let) operator_fat(()operator_fat(\)) (f1) (f2) (...)operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(_) operator_fat(()operator_fat(()(fmls1) (expr1)operator_fat(\)) operator_fat(()(fmls2) (expr2)operator_fat(\)) (...)operator_fat(\)) (f1) (f2) (...)operator_fat(\))
     operator_fat(()(lvhelp) (fmls1) operator_fat(()operator_fat(\)) operator_fat(()operator_fat(\)) (expr1) operator_fat(()operator_fat(()(fmls2) (expr2)operator_fat(\)) (...)operator_fat(\)) operator_fat(()(f1) (f2) (...)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) 

operator_fat(()reserved(define-syntax) (lvhelp)
  operator_fat(()(syntax-rules) operator_fat(()operator_fat(\))
    operator_fat(()operator_fat(()(_) operator_fat(()(x1) operator(.) (fmls)operator_fat(\)) operator_fat(()(x) (...)operator_fat(\)) operator_fat(()(t) (...)operator_fat(\)) (e) (m) (b)operator_fat(\))
     operator_fat(()(lvhelp) (fmls) operator_fat(()(x) (...) (x1)operator_fat(\)) operator_fat(()(t) (...) (tmp)operator_fat(\)) (e) (m) (b)operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(_) operator_fat(()operator_fat(\)) operator_fat(()(x) (...)operator_fat(\)) operator_fat(()(t) (...)operator_fat(\)) (e) (m) (b)operator_fat(\))
     operator_fat(()(call-with-values)
       operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) (e)operator_fat(\))
       operator_fat(()reserved(lambda) operator_fat(()(t) (...)operator_fat(\))
         operator_fat(()(let-values) (m) operator_fat(()reserved(let) operator_fat(()operator_fat(()(x) (t)operator_fat(\)) (...)operator_fat(\)) operator(.) (b)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(_) (xr) operator_fat(()(x) (...)operator_fat(\)) operator_fat(()(t) (...)operator_fat(\)) (e) (m) (b)operator_fat(\))
     operator_fat(()(call-with-values)
       operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) (e)operator_fat(\))
       operator_fat(()reserved(lambda) operator_fat(()(t) (...) operator(.) (tmpr)operator_fat(\))
         operator_fat(()(let-values) (m) operator_fat(()reserved(let) operator_fat(()operator_fat(()(x) (t)operator_fat(\)) (...) operator_fat(()(xr) (tmpr)operator_fat(\))operator_fat(\)) operator(.) (b)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\)) 

comment(;; ------------)

operator_fat(()reserved(define) operator_fat(()(somefunc)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(a) operator_fat(()(make-vector) integer(5)operator_fat(\))operator_fat(\))
        operator_fat(()(h) operator_fat(()(make-hash-table) integer(5)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(values) (a) (h)operator_fat(\)) operator_fat(\))operator_fat(\))

comment(; Multiple return items placed directly into separate variables)
operator_fat(()(let-values) operator_fat(() operator_fat(()operator_fat(()(a) (h)operator_fat(\)) operator_fat(()(somefunc)operator_fat(\))operator_fat(\)) operator_fat(\))
  operator_fat(()(print) operator_fat(()(array?) (a)operator_fat(\))operator_fat(\))
  operator_fat(()(print) operator_fat(()(hash-table?) (h)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.10)
comment(; Like most modern languages, Scheme supports exceptions for handling)
comment(; failure, something that will be illustrated in another section. However,)
comment(; conventions exist as to the choice of value used to indicate failure:)
comment(; * Empty list i.e. '(\) is often used for this task, as is it's string)
comment(;   counterpart, "", the empty string)
comment(; * Return false i.e. #f to indicate failed / not found etc, and a valid)
comment(;   value otherwise [e.g. testing set membership: if not a member, return)
comment(;   #f, but if a member, return the item itself rather than #t])

comment(; Return empty list as indicating 'failure')
operator_fat(()reserved(define) operator_fat(()(sub-failed)operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))

comment(;; ------------)

operator_fat(()reserved(define) operator_fat(()(look-for-something)operator_fat(\))
  (...)
  operator_fat(()reserved(if) operator_fat(()(something-found)operator_fat(\))
    comment(; Item found, return the item)
    (something)
  comment(;else)
    comment(; Not found, indicate failure)
    pre_constant(#f)
  operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(look-for-something)operator_fat(\))operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(Item could not be found ...)delimiter(")>operator_fat(\))
comment(;else)
  comment(; do something with item ...)
  (...)

comment(;; ------------)

comment(; An interesting variation on returning #f as a failure indicator is)
comment(; in using the, 'false-if-exception' procedure whereby a procedure is)
comment(; executed, any exceptions it may throw caught, and handled by simply)
comment(; returning #f. See example in section on Exception Handling below.)

comment(;; ------------)

operator_fat(()reserved(define) operator_fat(()(ioctl)operator_fat(\)) (...) pre_constant(#f)operator_fat(\))

operator_fat(()reserved(or) operator_fat(()(ioctl)operator_fat(\)) operator_fat(()reserved(begin) operator_fat(()(print) string<delimiter(")content(can't ioctl)delimiter(")>operator_fat(\)) operator_fat(()(exit) integer(1)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.11)
comment(; Whether Scheme is seen to support prototyping depends on the definition)
comment(; of this term used:)
comment(; * Prototyping along the lines used in Ada, Modula X, and even C / C++,)
comment(;   in which a procedure's interface is declared separately from its)
comment(;   implementation, is *not* supported)
comment(; * Prototyping in which, as part of the procedure definition, parameter )
comment(;   information must be supplied. This is a requirement in Scheme in that)
comment(;   parameter number and names must be given, though there is no need to)
comment(;   supply type information [optional and keyword parameters muddy the)
comment(;   waters somewhat, but the general principle applies])

operator_fat(()reserved(define) operator_fat(()(func-with-no-arg)operator_fat(\)) (...)operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(func-with-one-arg) (arg1)operator_fat(\)) (...)operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(func-with-two-arg) (arg1) (arg2)operator_fat(\)) (...)operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(func-with-three-arg) (arg1) (arg2) (arg3)operator_fat(\)) (...)operator_fat(\))

comment(;; @@PLEAC@@_10.12)
comment(; Not exactly like the Perl example, but a way of immediately)
comment(; exiting from an application)
operator_fat(()reserved(define) operator_fat(()(die) (msg) operator(.) (error-code)operator_fat(\))
  operator_fat(()(display) operator_fat(()(string-append) (msg) string<delimiter(")content(\\n)delimiter(")>operator_fat(\)) operator_fat(()(current-error-port)operator_fat(\))operator_fat(\))
  operator_fat(()(exit) operator_fat(()reserved(if) operator_fat(()(null?) (error-code)operator_fat(\)) integer(1) operator_fat(()(car) (error-code)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()(die) string<delimiter(")content(some message)delimiter(")>operator_fat(\))

comment(;; ------------)

comment(; An exception is thrown via 'throw'; argument must be a symbol)
operator_fat(()(throw) operator_fat(')(some-exception)operator_fat(\))

comment(; Invalid attempts - these, themselves force a 'wrong-type-arg)
comment(; exception to be thrown)
operator_fat(()(throw) pre_constant(#t)operator_fat(\))
operator_fat(()(throw) string<delimiter(")content(my message)delimiter(")>operator_fat(\))
operator_fat(()(throw) integer(1)operator_fat(\))

comment(;; ------------)

comment(; Example of a 'catch all' handler - 'proc' is executed, and any)
comment(; exception thrown is handled, in this case by simply returning false)
operator_fat(()reserved(define) operator_fat(()(false-if-exception) (proc)operator_fat(\))
  operator_fat(()(catch) pre_constant(#t)
    (proc)
    operator_fat(()reserved(lambda) operator_fat(()(key) operator(.) (args)operator_fat(\)) pre_constant(#f)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(func)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(Starting 'func' ...)delimiter(")>operator_fat(\))
  operator_fat(()(throw) operator_fat(')(myexception) integer(1)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(Leaving 'func' ...)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; ----)

operator_fat(()reserved(if) operator_fat(()(not) operator_fat(()(false-if-exception) (main)operator_fat(\))operator_fat(\))
  operator_fat(()(print) string<delimiter(")content('func' raised an exception)delimiter(")>operator_fat(\))
  operator_fat(()(print) string<delimiter(")content('func' executed normally)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; ------------)

comment(; More typical exception handling example in which:)
comment(; * 'func' is executed)
comment(; * 'catch' either:)
comment(;   - returns return value of 'func' [if successful])
comment(;   - executes handler(s\))

operator_fat(()reserved(define) operator_fat(()(full-moon-exception-handler) (key) operator(.) (args)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(I'm executing after stack unwound !)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(full-moon-exception-prewind-handler) (key) operator(.) (args)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(I'm executing with the stack still intact !)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) operator_fat(()(func)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(Starting 'func' ...)delimiter(")>operator_fat(\))
  operator_fat(()(throw) operator_fat(')(full-moon-exception) integer(1)operator_fat(\))
  operator_fat(()(print) string<delimiter(")content(Leaving 'func' ...)delimiter(")>operator_fat(\))operator_fat(\))

operator_fat(()(catch) operator_fat(')(full-moon-exception)
   (func)
   (full-moon-exception-handler)
   (full-moon-exception-prewind-handler)operator_fat(\))

comment(;; @@PLEAC@@_10.13)
comment(; Scheme is lexically-scoped, so same-name, higher-level variables)
comment(; are merely shadowed in lower-level blocks. Upon exit from those)
comment(; blocks the higher-level values are again available. Therefore, the)
comment(; saving of global variables, as required by Perl, is not necessary)

comment(; Global variable)
operator_fat(()reserved(define) (age) integer(18)operator_fat(\))

comment(; Procedure definition creates a closure - it captures the earlier)
comment(; version of, age', and will retain it)
operator_fat(()reserved(define) operator_fat(()(func)operator_fat(\))
  operator_fat(()(print) (age)operator_fat(\))operator_fat(\))

operator_fat(()reserved(if) operator_fat(()(condition)operator_fat(\))
  comment(; New 'local' variable created which acts to shadow the global)
  comment(; version)
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(age) integer(23)operator_fat(\))operator_fat(\))

    comment(; Prints 23 because the global variable is shadowed within )
    comment(; this block )
    operator_fat(()(print) (age)operator_fat(\))

    comment(; However, lexical-scoping ensures 'func' still accesses the)
    comment(; 'age' which was active when it was defined)
    operator_fat(()(func)operator_fat(\)) operator_fat(\))operator_fat(\))

comment(; The use of 'fluid-let' allows for similar behaviour to Perl's i.e.)
comment(; it mimics dynamic scope, but it does so cleanly in that once its)
comment(; scope ends any affected global variables are restored to previous)
comment(; values)
operator_fat(()reserved(if) operator_fat(()(condition)operator_fat(\))

  comment(; This does not create a new 'local' variables but temporarily)
  comment(; sets the global variable, 'age' to 23)
  operator_fat(()(fluid-let) operator_fat(()operator_fat(()(age) integer(23)operator_fat(\))operator_fat(\))

    comment(; Prints 23 because it is accessing the global version of 'age')
    operator_fat(()(print) (age)operator_fat(\))

    comment(; Prints 23 because it is its lexically-scoped version of 'age')
    comment(; that has its value altered, albeit temporarily)
    operator_fat(()(func)operator_fat(\)) operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.14)
comment(; Define two procedures, bind them to identifiers)
operator_fat(()reserved(define) operator_fat(()(grow)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(grow)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(shrink)operator_fat(\)) operator_fat(()(print) string<delimiter(")content(shrink)delimiter(")>operator_fat(\))operator_fat(\))

comment(; Separate procedures executed)
operator_fat(()(grow)operator_fat(\))
operator_fat(()(shrink)operator_fat(\))

comment(; Rebind identifier; now acts as alias for latter)
operator_fat(()reserved(define) (grow) (shrink)operator_fat(\))

comment(; Same procedure executed in both cases)
operator_fat(()(grow)operator_fat(\))
operator_fat(()(shrink)operator_fat(\))

comment(;; ------------)

comment(; As for previous except that rebinding is localised and)
comment(; ends once local scope exited)
operator_fat(()reserved(let) operator_fat(()operator_fat(()(grow) (shrink)operator_fat(\))operator_fat(\))
  operator_fat(()(grow)operator_fat(\))
  operator_fat(()(shrink)operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

comment(; Example of dynamically creating [from text data] and binding)
comment(; procedures. The example here is conceptually similar to the Perl)
comment(; example in that it makes use of an 'eval' type of facility to)
comment(; generate code from text. In Scheme such tasks are generally better)
comment(; dealt with using macros )

comment(; List of procedure name / first argument pairs)
operator_fat(()reserved(define) (*colours*)
  operator_fat(()(list)
    operator_fat(')operator_fat(()string<delimiter(")content(red)delimiter(")> operator(.) string<delimiter(")content(baron)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()string<delimiter(")content(blue)delimiter(")> operator(.) string<delimiter(")content(zephyr)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()string<delimiter(")content(green)delimiter(")> operator(.) string<delimiter(")content(beret)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()string<delimiter(")content(yellow)delimiter(")> operator(.) string<delimiter(")content(ribbon)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()string<delimiter(")content(orange)delimiter(")> operator(.) string<delimiter(")content(county)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()string<delimiter(")content(purple)delimiter(")> operator(.) string<delimiter(")content(haze)delimiter(")>operator_fat(\))
    operator_fat(')operator_fat(()string<delimiter(")content(violet)delimiter(")> operator(.) string<delimiter(")content(temper)delimiter(")>operator_fat(\)) operator_fat(\))operator_fat(\))

comment(; Build a series of procedures dynamically by traversing the)
comment(; *colours* list and obtaining:)
comment(; * Procedure name from first item of pair)
comment(; * Procedure argument from second item of pair)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(colour)operator_fat(\))
    operator_fat(()reserved(let) operator_fat(()operator_fat(()(proc-string)
            operator_fat(()(string-append)
              string<delimiter(")content((define )delimiter(")> operator_fat(()(car) (colour)operator_fat(\)) string<delimiter(")content( (lambda (\) )delimiter(")>
              string<delimiter(")content(\\")content(<FONT COLOR=)delimiter(")> operator_fat(()(car) (colour)operator_fat(\)) string<delimiter(")content(>)delimiter(")> operator_fat(()(cdr) (colour)operator_fat(\))
              string<delimiter(")content(</FONT>)content(\\")content(\)\))delimiter(")> operator_fat(\))operator_fat(\))operator_fat(\))
      operator_fat(()(eval-string) (proc-string)operator_fat(\))operator_fat(\))operator_fat(\))
   (*colours*)operator_fat(\))

comment(; Apply each of the dynamically-built procedures)
operator_fat(()(for-each)
  operator_fat(()reserved(lambda) operator_fat(()(colour)operator_fat(\))
    operator_fat(()(print) operator_fat(()(apply) operator_fat(()(string->procedure) operator_fat(()(car) (colour)operator_fat(\))operator_fat(\)) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
  (*colours*)operator_fat(\))

comment(;; @@PLEAC@@_10.15)
comment(; AFAICT Guile doesn't implement an AUTOLOAD facility in which a)
comment(; 'replacement' function is available should another one fail to)
comment(; load [though there is an autoload feature available with modules)
comment(; which is a load-on-demand facility aimed at conserving memory and)
comment(; speeding up initial program load time].)
comment(;)
comment(; One might think it would be feasable, however, to use exception)
comment(; handling to provide roughly similar functionality:)

comment(; Catch all exceptions)
operator_fat(()(catch) pre_constant(#t)
  comment(; Undefined procedure, 'x')
  (x)
  comment(; Exception handler could load missing code ?)
  operator_fat(()reserved(lambda) operator_fat(()(key) operator(.) (args)operator_fat(\)) (...) operator_fat(\))operator_fat(\))

comment(; However, an undefined function call is reported as:)
comment(;)
comment(;    ERROR: Unbound variable: ...)
comment(;)
comment(; and this situation doesn't appear to be user-trappable. )
comment(;)

comment(;; @@PLEAC@@_10.16)
comment(; Both implementations below  are correct, and exhibit identical)
comment(; behaviour )

operator_fat(()reserved(define) operator_fat(()(outer) (arg)operator_fat(\))
  operator_fat(()reserved(let*) operator_fat(()operator_fat(()(x) operator_fat(()(+) (arg) integer(35)operator_fat(\))operator_fat(\))
         operator_fat(()(inner) operator_fat(()reserved(lambda) operator_fat(()operator_fat(\)) operator_fat(()(*) (x) integer(19)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(+) (x) operator_fat(()(inner)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; ----------------------------)

operator_fat(()reserved(define) operator_fat(()(outer) (arg)operator_fat(\))
  operator_fat(()reserved(let) operator_fat(()operator_fat(()(x) operator_fat(()(+) (arg) integer(35)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()reserved(define) operator_fat(()(inner)operator_fat(\)) operator_fat(()(*) (x) integer(19)operator_fat(\))operator_fat(\))
    operator_fat(()(+) (x) operator_fat(()(inner)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_10.17)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_13.0)
comment(;; Guile OOP is in the (oop goops\) module (based on CLOS\).  All)
comment(;; following sections assume you have (oop goops loaded\).)
operator_fat(()(use-modules) operator_fat(()(oop) (goops)operator_fat(\))operator_fat(\))
operator_fat(()(define-class) (<data-encoder>) operator_fat(()operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (obj) operator_fat(()(make) (<data-encoder>)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (obj) operator_fat(#()integer(3) integer(5)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A ~A)content(\\n)delimiter(")> operator_fat(()(class-of) (obj)operator_fat(\)) operator_fat(()(array-ref) (obj) integer(1)operator_fat(\))operator_fat(\))
operator_fat(()(change-class) (v) (<human-cannibal>)operator_fat(\)) comment(; has to be defined)
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A ~A)content(\\n)delimiter(")> operator_fat(()(slot-ref) (obj) (stomach)operator_fat(\)) operator_fat(()(slot-ref) (obj) (name)operator_fat(\))operator_fat(\))

operator_fat(()(slot-ref) (obj) operator_fat(')(stomach)operator_fat(\))
operator_fat(()(slot-set!) (obj) operator_fat(')(stomach) string<delimiter(")content(Empty)delimiter(")>operator_fat(\))
operator_fat(()(name) (obj)operator_fat(\))
operator_fat(()reserved(set!) operator_fat(()(name) (obj)operator_fat(\)) string<delimiter(")content(Thag)delimiter(")>operator_fat(\))

comment(;; inheritance)
operator_fat(()(define-class) (<lawyer>) operator_fat(()(<human-cannibal>)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (lector) operator_fat(()(make) (<human-cannibal>)operator_fat(\))operator_fat(\))
operator_fat(()(feed) (lector) string<delimiter(")content(Zak)delimiter(")>operator_fat(\))
operator_fat(()(move) (lector) string<delimiter(")content(New York)delimiter(")>operator_fat(\))

comment(;; @@PLEAC@@_13.1)
operator_fat(()(define-class) (<my-class>) operator_fat(()operator_fat(\))
  operator_fat(()(start) error(#)(:init-form) operator_fat(()(current-time)operator_fat(\))operator_fat(\))
  operator_fat(()(age) error(#)(:init-value) integer(0)operator_fat(\))operator_fat(\))

comment(;; classes must have predefined slots, but you could use one as a)
comment(;; dictionary:)
operator_fat(()(define-class) (<my-class>) operator_fat(()operator_fat(\))
  operator_fat(()(start) error(#)(:init-form) operator_fat(()(current-time)operator_fat(\))operator_fat(\))
  operator_fat(()(age) error(#)(:init-value) integer(0)operator_fat(\))
  operator_fat(()(properties) error(#)(:init-value) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) operator_fat(()(initialize) operator_fat(()(m) (<my-class>)operator_fat(\)) (initargs)operator_fat(\))
  operator_fat(()(and-let*) operator_fat(()operator_fat(()(extra) operator_fat(()(memq) error(#)(:extra) (initargs)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()(slot-set!) (m) operator_fat(')(properties) operator_fat(()(cdr) (extra)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_13.2)
comment(;; For smobs (external C objects\), you can specify a callback to be)
comment(;; performed when the object is garbage collected with the C API)
comment(;; function `scm_set_smob_free'.  This solves the problem of cleaning up)
comment(;; after external objects and connections.  Guile doesn't use reference)
comment(;; count garbage collection, so circular data structures aren't a)
comment(;; problem.)

comment(;; @@PLEAC@@_13.3)
comment(;; either use slot-ref/set!)
operator_fat(()(slot-ref) (obj) operator_fat(')(name)operator_fat(\))
operator_fat(()(slot-set!) (obj) operator_fat(')(name) (value)operator_fat(\))

comment(;; or define the class with accessors)
operator_fat(()(define-class) (<my-class>) operator_fat(()operator_fat(\))
  operator_fat(()(name) error(#)(:accessor) (name)operator_fat(\))operator_fat(\))
operator_fat(()(name) (obj)operator_fat(\))
operator_fat(()reserved(set!) operator_fat(()(name) (obj)operator_fat(\)) (value)operator_fat(\))

comment(;; or use getters/setters to implement read/write-only slots)
operator_fat(()(define-class) (<my-class>) operator_fat(()operator_fat(\))
  operator_fat(()(name) error(#)(:getter) (name)operator_fat(\))
  operator_fat(()(age) error(#)(:setter) (age)operator_fat(\))operator_fat(\))
operator_fat(()(name) (obj)operator_fat(\))
operator_fat(()reserved(set!) operator_fat(()(age) (obj)operator_fat(\)) (value)operator_fat(\))

comment(;; or implement getters/setters manually)
operator_fat(()(define-method) operator_fat(()operator_fat(()(setter) (name)operator_fat(\)) operator_fat(()(obj) (<my-class>)operator_fat(\)) (value)operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(string-match) string<delimiter(")content([^-)content(\\\\)content(w0-9'])delimiter(")> (value)operator_fat(\))
         operator_fat(()(warn) string<delimiter(")content(funny characters in name)delimiter(")>operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(string-match) string<delimiter(")content([0-9])delimiter(")> (value)operator_fat(\))
         operator_fat(()(warn) string<delimiter(")content(numbers in name)delimiter(")>operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(not) operator_fat(()(string-match) string<delimiter(")content(\\\\)content(w+)content(\\\\)content(W+)content(\\\\)content(w+)delimiter(")> (value)operator_fat(\))operator_fat(\))
         operator_fat(()(warn) string<delimiter(")content(prefer multiword names)delimiter(")>operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(not) operator_fat(()(string-match) string<delimiter(")content(\\\\)content(w)delimiter(")> (value)operator_fat(\))operator_fat(\))
         operator_fat(()(warn) string<delimiter(")content(name is blank)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(slot-set!) (obj) operator_fat(')(name) operator_fat(()(string-downcase) (value)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_13.4)
comment(;; override the initialize method)
operator_fat(()reserved(define) (body-count) integer(0)operator_fat(\))

operator_fat(()(define-method) operator_fat(()(initialize) operator_fat(()(obj) (<person>)operator_fat(\)) (initargs)operator_fat(\))
  operator_fat(()reserved(set!) (body-count) operator_fat(()integer(1)(+) (body-count)operator_fat(\))operator_fat(\))
  operator_fat(()(next-method)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (people) operator_fat(')operator_fat(()operator_fat(\))operator_fat(\))
operator_fat(()reserved(do) operator_fat(()operator_fat(()(i) integer(1) operator_fat(()integer(1)(+) (i)operator_fat(\))operator_fat(\))operator_fat(\))
    operator_fat(()operator_fat(()(>) (i) integer(10)operator_fat(\))operator_fat(\))
  operator_fat(()reserved(set!) (people) operator_fat(()reserved(cons) operator_fat(()(make) (<person>)operator_fat(\)) (people)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(There are ~A people alive.)content(\\n)delimiter(")> (body-count)operator_fat(\))

operator_fat(()reserved(define) (him) operator_fat(()(make) (<person>)operator_fat(\))operator_fat(\))
operator_fat(()(slot-set!) (him) operator_fat(')(gender) string<delimiter(")content(male)delimiter(")>operator_fat(\))

operator_fat(()reserved(define) (her) operator_fat(()(make) (<person>)operator_fat(\))operator_fat(\))
operator_fat(()(slot-set!) (her) operator_fat(')(gender) string<delimiter(")content(female)delimiter(")>operator_fat(\))

comment(;; use the :class allocation method)
operator_fat(()(slot-set!) operator_fat(()(make) (<fixed-array>)operator_fat(\)) operator_fat(')(max-bounds) integer(100)operator_fat(\)) comment(; set for whole class)
operator_fat(()reserved(define) (alpha) operator_fat(()(make) (<fixed-array>)operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Bound on alpha is ~D)content(\\n)delimiter(")> operator_fat(()(slot-ref) (alpha) operator_fat(')(max-bounds)operator_fat(\))operator_fat(\))
comment(;; 100)

operator_fat(()reserved(define) (beta) operator_fat(()(make) (<fixed-array>)operator_fat(\))operator_fat(\))
operator_fat(()(slot-set!) (beta) operator_fat(')(max-bounds) integer(50)operator_fat(\))          comment(; still sets for whole class)
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(Bound on alpha is ~D)content(\\n)delimiter(")> operator_fat(()(slot-ref) (alpha) operator_fat(')(max-bounds)operator_fat(\))operator_fat(\))
comment(;; 50)

comment(;; defined simply as)
operator_fat(()(define-class) (<fixed-array>) operator_fat(()operator_fat(\))
  operator_fat(()(max-bounds) error(#)(:init-value) integer(7) error(#)(:allocation) error(#)(:class)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_13.5)
comment(;; Guile classes are basically structs by definition.  If you don't care)
comment(;; about OO programming at all, you can use records, which are portable)
comment(;; across most Schemes.  This is, however, an OO chapter so I'll stick)
comment(;; to classes.)
operator_fat(()(define-class) (<person>) operator_fat(()operator_fat(\)) (name) (age) (peers)operator_fat(\))

operator_fat(()reserved(define) (p) operator_fat(()(make) (<person>)operator_fat(\))operator_fat(\))
operator_fat(()(slot-set!) (p) operator_fat(')(name) string<delimiter(")content(Jason Smythe)delimiter(")>operator_fat(\))
operator_fat(()(slot-set!) (p) operator_fat(')(age) integer(13)operator_fat(\))
operator_fat(()(slot-set!) (p) operator_fat(')(peers) operator_fat(')operator_fat(()string<delimiter(")content(Wilbur)delimiter(")> string<delimiter(")content(Ralph)delimiter(")> string<delimiter(")content(Fred)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()(format) pre_constant(#t) string<delimiter(")content(At age ~D, ~A's first friend is ~A.)content(\\n)delimiter(")>
        operator_fat(()(slot-ref) (p) operator_fat(')(age)operator_fat(\)) operator_fat(()(slot-ref) (p) operator_fat(')(name)operator_fat(\)) operator_fat(()(car) operator_fat(()(slot-ref) (p) operator_fat(')(peers)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; For type-checking and field validation, define the setters)
comment(;; accordingly.)
operator_fat(()(define-class) (<person>) operator_fat(()operator_fat(\))
  operator_fat(()(name) error(#)(:accessor) (name)operator_fat(\))
  operator_fat(()(age) error(#)(:accessor) (age)operator_fat(\))operator_fat(\))

operator_fat(()(define-method) operator_fat(()operator_fat(()(setter) (age)operator_fat(\)) operator_fat(()(p) (<person>)operator_fat(\)) (a)operator_fat(\))
  operator_fat(()reserved(cond) operator_fat(()operator_fat(()(not) operator_fat(()(number?) (a)operator_fat(\))operator_fat(\))
         operator_fat(()(warn) string<delimiter(")content(age)delimiter(")> (a) string<delimiter(")content(isn't numeric)delimiter(")>operator_fat(\))operator_fat(\))
        operator_fat(()operator_fat(()(>) (a) integer(150)operator_fat(\))
         operator_fat(()(warn) string<delimiter(")content(age)delimiter(")> (a) string<delimiter(")content(is unreasonable)delimiter(")>operator_fat(\))operator_fat(\))operator_fat(\))
  operator_fat(()(slot-set!) (p) operator_fat(')(age) (a)operator_fat(\))operator_fat(\))

operator_fat(()(define-class) (<family>) operator_fat(()operator_fat(\))
  operator_fat(()(head) error(#)(:init-form) operator_fat(()(make) (<person>)operator_fat(\)) error(#)(:accessor) (head)operator_fat(\))
  operator_fat(()(address) error(#)(:init-value) string<delimiter(")delimiter(")> error(#)(:accessor) (address)operator_fat(\))
  operator_fat(()(members) error(#)(:init-value) operator_fat(')operator_fat(()operator_fat(\)) error(#)(:accessor) (members)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (folks) operator_fat(()(make) (<family>)operator_fat(\))operator_fat(\))

operator_fat(()reserved(define) (dad) operator_fat(()(head) (folks)operator_fat(\))operator_fat(\))
operator_fat(()reserved(set!) operator_fat(()(name) (dad)operator_fat(\)) string<delimiter(")content(John)delimiter(")>operator_fat(\))
operator_fat(()reserved(set!) operator_fat(()(age) (dad)operator_fat(\)) integer(34)operator_fat(\))

operator_fat(()(format) pre_constant(#t) string<delimiter(")content(~A's age is ~D)content(\\n)delimiter(")> operator_fat(()(name) (dad)operator_fat(\)) operator_fat(()(age) (dad)operator_fat(\))operator_fat(\))

comment(;; Macros are the usual way to add syntactic sugar)

comment(;; For all fields of the same type, let's use _ to mean the slot name in)
comment(;; the options expansion.)
operator_fat(()(define-macro) operator_fat(()(define-uniform-class) (name) (supers) (slots) operator(.) (options)operator_fat(\))
  error(`)operator_fat(()(define-class) error(,)(name) error(,)(supers)
     error(,)(@)operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(s)operator_fat(\)) operator_fat(()reserved(cons) (s) operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(o)operator_fat(\)) operator_fat(()reserved(if) operator_fat(()(eq?) (o) operator_fat(')(_)operator_fat(\)) (s) (o)operator_fat(\))operator_fat(\)) (options)operator_fat(\))operator_fat(\))operator_fat(\))
            (slots)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(define-uniform-class) (<card>) operator_fat(()(name) (color) (cost) (type) (release) (text)operator_fat(\))
  error(#)(:accessor) (_) error(#)(:init-value) string<delimiter(")delimiter(")>operator_fat(\))

comment(;; If you *really* wanted to enforce slot types you could use something)
comment(;; like the above with the custom setter.  To illustrate reversing)
comment(;; normal slot definition args, we'll reverse an init-value:)
operator_fat(()(define-macro) operator_fat(()(define-default-class) (name) (supers) operator(.) (default&slots)operator_fat(\))
  error(`)operator_fat(()(define-class) error(,)(name) error(,)(supers)
     error(,)(@)operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(d&s)operator_fat(\)) operator_fat(()(list) operator_fat(()(cadr) (d&s)operator_fat(\))
                                error(#)(:init-value) operator_fat(()(car) (d&s)operator_fat(\))
                                error(#)(:accessor) operator_fat(()(cadr) (d&s)operator_fat(\))operator_fat(\))operator_fat(\))
            (default&slots)operator_fat(\))operator_fat(\))operator_fat(\))

operator_fat(()(define-default-class) (hostent) operator_fat(()operator_fat(\))
  operator_fat(()string<delimiter(")delimiter(")> (name)operator_fat(\))
  operator_fat(()operator_fat(')operator_fat(()operator_fat(\)) (aliases)operator_fat(\))
  operator_fat(()string<delimiter(")delimiter(")> (addrtype)operator_fat(\))
  operator_fat(()integer(0)  (length)operator_fat(\))
  operator_fat(()operator_fat(')operator_fat(()operator_fat(\)) (addr-list)operator_fat(\))operator_fat(\))

comment(;; Nothing special needed for Aliases - all names are equal)
operator_fat(()reserved(define) (type) (addrtype)operator_fat(\))
operator_fat(()(define-method) operator_fat(()(addr) operator_fat(()(h) (<hostent>)operator_fat(\))operator_fat(\))
  operator_fat(()(car) operator_fat(()(addr-list) (h)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_13.6)
comment(;; A little more clear than the Perl, but not very useful.)
operator_fat(()reserved(define) (obj1) operator_fat(()(make) (<some-class>)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (obj2) operator_fat(()(make) operator_fat(()(class-of) (obj1)operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; Use the shallow-clone or deep-clone methods to initialize from)
comment(;; another instance.)
operator_fat(()reserved(define) (obj1) operator_fat(()(make) (<widget>)operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (obj2) operator_fat(()(deep-clone) (obj1)operator_fat(\))operator_fat(\))

comment(;; @@PLEAC@@_13.7)
comment(;; Use eval or a variant to convert from a symbol or string to the)
comment(;; actual method.  As shown in 13.5 above, methods are first class and)
comment(;; you'd be more likely to store the actual method than the name in a)
comment(;; real Scheme program.)
operator_fat(()reserved(define) (methname) string<delimiter(")content(flicker)delimiter(")>operator_fat(\))
operator_fat(()(apply-generic) operator_fat(()(eval-string) (methname)operator_fat(\)) (obj) integer(10)operator_fat(\))

operator_fat(()(for-each) operator_fat(()reserved(lambda) operator_fat(()(m)operator_fat(\)) operator_fat(()(apply-generic) (obj) operator_fat(()(eval-string) (m)operator_fat(\))operator_fat(\))operator_fat(\))
          operator_fat(')operator_fat(()string<delimiter(")content(start)delimiter(")> string<delimiter(")content(run)delimiter(")> string<delimiter(")content(stop)delimiter(")>operator_fat(\))operator_fat(\))

comment(;; really, don't do this...)
operator_fat(()reserved(define) (methods) operator_fat(')operator_fat(()string<delimiter(")content(name)delimiter(")> string<delimiter(")content(rank)delimiter(")> string<delimiter(")content(serno)delimiter(")>operator_fat(\))operator_fat(\))
operator_fat(()reserved(define) (his-info)
  operator_fat(()(map) operator_fat(()reserved(lambda) operator_fat(()(m)operator_fat(\)) operator_fat(()reserved(cons) (m) operator_fat(()(apply-generic) operator_fat(()(eval-string) (m)operator_fat(\)) (obj)operator_fat(\))operator_fat(\))operator_fat(\))
       (methods)operator_fat(\))operator_fat(\))

comment(;; same as this:)
operator_fat(()reserved(define) (his-info) operator_fat(()(list) operator_fat(()reserved(cons) string<delimiter(")content(name)delimiter(")> operator_fat(()(name) (obj)operator_fat(\))operator_fat(\))
                       operator_fat(()reserved(cons) string<delimiter(")content(rank)delimiter(")> operator_fat(()(rank) (obj)operator_fat(\))operator_fat(\))
                       operator_fat(()reserved(cons) string<delimiter(")content(serno)delimiter(")> operator_fat(()(serno) (obj)operator_fat(\))operator_fat(\))operator_fat(\))operator_fat(\))

comment(;; a closure works)
operator_fat(()reserved(define) (fnref) operator_fat(()reserved(lambda) (args) operator_fat(()(method) (obj) (args)operator_fat(\))operator_fat(\))operator_fat(\))
operator_fat(()(fnref) integer(10) string<delimiter(")content(fred)delimiter(")>operator_fat(\))
operator_fat(()(method) (obj) integer(10) (fred)operator_fat(\))

comment(;; @@PLEAC@@_13.8)
comment(;; use is-a?)
operator_fat(()(is-a?) (obj) (<http-message>)operator_fat(\))
operator_fat(()(is-a?) (<http-response>) (<http-message>)operator_fat(\))